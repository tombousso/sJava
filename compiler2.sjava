(package compiler2)

(import java.util.*)
(import java.nio.file.*)
(import gnu.bytecode.*)
(import java.io.*)

(define-class Main () 'public
	(ML int 'static) ;max length of a special token
	(MP int 'static) ;max precedence
	(precs String[][]  'static) ;precedence to special token array
	(s2prec HashMap{String Integer} 'static) ;special token to precedence
	(specialChars HashMap{String Character} 'static)
	(unboxMethods HashMap{Type Method} 'static)
	(constTypes HashMap{String Type} 'static)
	(accessModifiers HashMap{String Short} 'static)
	(binOps HashMap{String Integer} 'static)
	(compare2Ops HashMap{String Integer} 'static)
	(compare1Ops HashMap{String Integer} 'static)
	(unknownType Type 'static 'public)
	(returnType Type 'static)
	(throwType Type 'static)
	((main args String[]) void 'public 'static
		(set Main:unknownType (Type:getType "unknownType"))
		(set Main:returnType (Type:getType "returnType"))
		(set Main:throwType (Type:getType "throwType"))

		(set Main:unboxMethods (HashMap{Type Method}))
		(Main:unboxMethods:put (Type:shortType:boxedType) (Type:javalangNumberType:getDeclaredMethod "shortValue" 0))
		(Main:unboxMethods:put (Type:intType:boxedType) (Type:javalangNumberType:getDeclaredMethod "intValue" 0))
		(Main:unboxMethods:put (Type:longType:boxedType) (Type:javalangNumberType:getDeclaredMethod "longValue" 0))
		(Main:unboxMethods:put (Type:doubleType:boxedType) (Type:javalangNumberType:getDeclaredMethod "doubleValue" 0))
		(Main:unboxMethods:put (Type:booleanType:boxedType) (Type:javalangBooleanType:getDeclaredMethod "booleanValue" 0))
		(Main:unboxMethods:put (Type:charType:boxedType) (Type:javalangCharacterType:getDeclaredMethod "charValue" 0))

		(set Main:constTypes (HashMap{String Type}))
		(Main:constTypes:put "bool" Type:booleanType)
		(Main:constTypes:put "byte" Type:byteType)
		(Main:constTypes:put "char" Type:charType)
		(Main:constTypes:put "double" Type:doubleType)
		(Main:constTypes:put "float" Type:floatType)
		(Main:constTypes:put "int" Type:intType)
		(Main:constTypes:put "long" Type:longType)
		(Main:constTypes:put "short" Type:shortType)
		(Main:constTypes:put "void" Type:voidType)

		(set Main:accessModifiers (HashMap{String Short}))
		(Main:accessModifiers:put "static" Access:STATIC)
		(Main:accessModifiers:put "public" Access:PUBLIC)
		(Main:accessModifiers:put "abstract" Access:ABSTRACT)
		(Main:accessModifiers:put "final" Access:FINAL)
		(Main:accessModifiers:put "private" Access:PRIVATE)
		(Main:accessModifiers:put "protected" Access:PROTECTED)
		(Main:accessModifiers:put "synchronized" Access:SYNCHRONIZED)
		(Main:accessModifiers:put "transient" Access:TRANSIENT)
		(Main:accessModifiers:put "volatile" Access:VOLATILE)
		(Main:accessModifiers:put "native" Access:NATIVE)
		(Main:accessModifiers:put "interface" Access:INTERFACE)
		(Main:accessModifiers:put "super" Access:SUPER)

		(set Main:binOps (HashMap{String Integer}))
		(Main:binOps:put "+" 96)
		(Main:binOps:put "-" 100)
		(Main:binOps:put "*" 104)
		(Main:binOps:put "/" 108)
		(Main:binOps:put "%" 112)
		(Main:binOps:put "&" 126)
		(Main:binOps:put "|" 128)
		(Main:binOps:put "^" 130)

		(set Main:compare2Ops (HashMap{String Integer}))
		;opposites
		(Main:compare2Ops:put "!=" 153)
		(Main:compare2Ops:put "=" 154)
		(Main:compare2Ops:put ">=" 155)
		(Main:compare2Ops:put "<" 156)
		(Main:compare2Ops:put "<=" 157)
		(Main:compare2Ops:put ">" 158)

		(set Main:compare1Ops (HashMap{String Integer}))
		;opposites
		(Main:compare1Ops:put "!=0" 153)
		(Main:compare1Ops:put "==0" 154)
		(Main:compare1Ops:put ">=0" 155)
		(Main:compare1Ops:put "<0" 156)
		(Main:compare1Ops:put "<=0" 157)
		(Main:compare1Ops:put ">0" 158)
		(Main:compare1Ops:put "!=null" 198)
		(Main:compare1Ops:put "==null" 199)
		
		(set Main:precs (String[][]
			(String[] ":" "{")
			(String[] "(" ")" "}" "'" "," ",$" "`" "\n" "\r\n" ";")
		))

		(set Main:specialChars (HashMap{String Character}))
		(Main:specialChars:put "space" #\space)
		(Main:specialChars:put "singlequote" #\singlequote)
		(Main:specialChars:put "newline" #\newline)
		(Main:specialChars:put "lparen" #\lparen)
		(Main:specialChars:put "rparen" #\rparen)

		(set Main:MP (- (alen Main:precs) 1))

		(set Main:ML 2)

		(set Main:s2prec (HashMap{String Integer}))

		(define i 0)
		(while (!= i (alen Main:precs))
			(define a (aget Main:precs i))
			(define j 0)
			(while (!= j (alen a))
				(Main:s2prec:put (aget a j) (+ i 1))
				(set j (+ j 1))
			)
			(set i (+ i 1))
		)

		(define files (LinkedHashMap{String List{Token}}))

		(define i 0)
		(while (!= i (- (alen args) 2))
			(define name (aget args i))
			(define s (String (Files:readAllBytes (Paths:get name (String[])))))
			(define toks ((Lexer s):lex))
			;((Parser toks):parse 0 (toks:size) Main:MP 0)
			(set toks ((Parser toks):parseAll))
			(files:put name toks)
			(set i (+ i 1))
		)
		;((System:console):readLine)
		(Main:compile files (aget args (- (alen args) 1)))
		;((System:console):readLine)
	)
	((compile files HashMap{String ArrayList{Token}} dir String) void 'static
		(define locals (HashMap))
		(define fileScopes (LinkedHashMap{String FileScope}))
		(define macroNames (HashMap{String ClassInfo}))

		(begin
			(define it ((files:entrySet):iterator))
			(while (it:hasNext)
				(define entry (it:next))
				(define toks (entry:getValue))
				(define fs (FileScope (entry:getKey) toks locals))
				(set fs:macroNames macroNames)
				(fileScopes:put (entry:getKey) fs)
				(fs:compileRoot)
			)
		)

		(begin
			(define it ((fileScopes:entrySet):iterator))
			(while (it:hasNext)
				(define entry (it:next))
				(define fs (entry:getValue))
				(fs:compileDefs)
			)
		)

		(define cl (ArrayClassLoader))
		(begin
			(define it ((fileScopes:entrySet):iterator))
			(while (it:hasNext)
				(define entry (it:next))
				(define fs (entry:getValue))
				(fs:compileMacros cl)
			)
		)

		(begin
			(define it ((fileScopes:entrySet):iterator))
			(while (it:hasNext)
				(define entry (it:next))
				(define fs (entry:getValue))
				(fs:compileIncludes)
			)
		)

		(begin
			(define it ((fileScopes:entrySet):iterator))
			(while (it:hasNext)
				(define entry (it:next))
				(define fs (entry:getValue))
				(fs:compileMethods GenHandler:inst)
			)
		)

		(begin
			(define it ((fileScopes:entrySet):iterator))
			(while (it:hasNext)
				(define entry (it:next))
				(define fs (entry:getValue))
				(define i 0)
				(while (!= i (fs:newClasses:size))
					((fs:newClasses:get i):writeFile dir)
					(set i (+ i 1))
				)
				(set i 0)
				(while (!= i (fs:anonClasses:size))
					((fs:anonClasses:get i):writeFile dir)
					(set i (+ i 1))
				)
			)
		)
	)
	((resolveType map Map{TypeVariable Type} pt Type t Type) Type 'static
		(if (instance? t TypeVariable)
			(if (instance? pt ParameterizedType)
				(begin
					(define tvs ((as ClassType ((as ParameterizedType pt):getRawType)):getTypeParameters))
					(define s String ((as TypeVariable t):getName))
					(define i 0)
					(while (!= i (alen tvs))
						(if (((aget tvs i):getName):equals s)
							(return ((as ParameterizedType pt):getTypeArgumentType i))
						)
						(set i (+ i 1))
					)
					(t:getRawType)
				)
			(if (&& (!= map null) (map:containsKey (as TypeVariable t)))
				(map:get (as TypeVariable t))
				(t:getRawType)
			)
			)
		(if (instance? t ArrayType)
			(ArrayType (Main:resolveType map pt (as ArrayType t):elements))
		(if (instance? t ParameterizedType)
			(begin
				(define types ((as ParameterizedType t):getTypeArgumentTypes))
				(define parameterized (Type[] len:(alen types)))
				(define i 0)
				(while (!= i (alen types))
					(aset parameterized i (Main:resolveType map pt (aget types i)))
					(set i (+ i 1))
				)
				(ParameterizedType (as ClassType (t:getRawType)) parameterized)
			)
			t
		)
		)
		)
	)
	((resolveType pt Type t Type) Type 'static
		(Main:resolveType null pt t)
	)
	((unresolveTv tv TypeVariable generic Type real Type) Type 'static
		(if (instance? generic TypeVariable)
			(if (tv:equals generic)
				(Main:tryBox real)
				null
			)
		(if (&&
				(instance? generic ParameterizedType)
				(instance? real ParameterizedType)
				((generic:getRawType):equals (real:getRawType))
			)
			(begin
				(define gtypes ((as ParameterizedType generic):getTypeArgumentTypes))
				(define rtypes ((as ParameterizedType real):getTypeArgumentTypes))
				(define n (alen gtypes))
				(define i 0)
				(while (!= i n)
					(define ret (Main:unresolveTv tv (aget gtypes i) (aget rtypes i)))
					(if (!= ret null)
						(return ret)
					)
					(set i (+ i 1))
				)
				null
			)
		(if (&& (instance? generic ArrayType) (instance? real ArrayType))
			(Main:unresolveTv tv (as ArrayType generic):elements (as ArrayType real):elements)
			null
		)
		)
		)
	)
	((unresolveTvs tvs TypeVariable[] generics Type[] reals Type[]) Map{TypeVariable Type} 'static
		(if (|| (= tvs null) (!= (alen generics) (alen reals)))
			null
			(begin
				(define out (HashMap{TypeVariable Type}))
				(define i 0)
				(while (!= i (alen tvs))
					(define tv (aget tvs i))
					(define j 0)
					(define t Type null)
					(while (&& (= t null) (!= j (alen generics)))
						(set t (Main:unresolveTv tv (aget generics j) (aget reals j)))
						(set j (+ j 1))
					)
					(out:put tv t)
					(set i (+ i 1))
				)
				out
			)
		)
	)
	((arrayDim t Type) int 'static
		(define out 0)
		(while (instance? t ArrayType)
			(set t (as ArrayType t):elements)
			(set out (+ out 1))
		)
		out
	)
	((shiftDown toks List i int n int) void 'static
		;shift down n elements at i
		(define l (toks:size))
		(define nl (- l n))
		(while (!= i nl)
			(toks:set i (toks:get (+ i n)))
			(set i (+ i 1))
		)
		((toks:subList (- l n) l):clear)
	)
	((compileClassMod tok Token c ClassType) bool 'static
		(if (instance? tok QuoteToken)
			(begin
				(define nmod int (Main:accessModifiers:get (as VToken (tok:toks:get 0)):val))
				(c:addModifiers nmod)
				true
			)
			false
		)
	)
	((getParams ci ClassInfo tok Token scope HashMap i int n int) Type[] 'static
		(define types (Type[] len: (/ (- (tok:toks:size) i) 2)))
		(define j 0)
		(while (!= j (alen types))
			(define type (ci:getType (tok:toks:get (+ (* j 2) i 1))))
			(aset types j type)
			(scope:put (as VToken (tok:toks:get (+ (* j 2) i))):val (Arg (+ n j) type))
			(set j (+ j 1))
		)
		types
	)
	((transformBlock block Token mi AMethodInfo transform bool) Token 'static
		(if (&& (!= block:toks null) (! block:transformed))
			(begin
				(if (&& (instance? block BlockToken) (> (block:toks:size) 0) (instance? (block:toks:get 0) VToken))
					(begin
						(define val (as VToken (block:toks:get 0)):val)
						(define ret Token
							(if (&& transform (val:equals "object"))
								(ObjectToken block:line block:toks)
							(if (&& transform (val:equals "lambda"))
								(LambdaToken block:line block:toks)
							(if (&& transform (mi:ci:fs:macroNames:containsKey val))
								(MacroCallToken block:line block:toks)
							(if (val:equals "quote")
								(Main:transformBlock (QuoteToken block:line (block:toks:subList 1 (block:toks:size))) mi)
							(if (val:equals "unquote")
								(Main:transformBlock (UnquoteToken block:line (block:toks:subList 1 (block:toks:size)) false) mi)
							(if (val:equals "varunquote")
								(Main:transformBlock (UnquoteToken block:line (block:toks:subList 1 (block:toks:size)) true) mi)
								null
							)
							)
							)
							)
							)
							)
						)
						(if (!= ret null)
							(begin
								(set ret:transformed true)
								(return ret)
							)
						)
					)
				)
				(if (&& transform (instance? block BlockToken))
					(set (as BlockToken block):labels (HashMap))
				)
				(define i 0)
				(while (!= i (block:toks:size))
					(define tok (block:toks:get i))
					(define ntok (Main:transformBlock tok mi
						(||
							(&&
								transform
								(! block:neverTransform)
							)
							block:alwaysTransform
						)
					))
					(if transform (set ntok:transformed true))
					(block:toks:set i ntok)
					(if (&& transform (instance? tok BlockToken) (> (tok:toks:size) 0) (instance? (tok:toks:get 0) VToken))
						(begin
							(define val (as VToken (tok:toks:get 0)):val)
							(if (val:equals "label")
								((as BlockToken block):labels:put (as VToken (tok:toks:get 1)):val (Label))
							)
						)
					)
					(set i (+ i 1))
				)
			)
		)
		block
	)
	((transformBlock block Token mi AMethodInfo) Token 'static 'public
		(Main:transformBlock block mi (! block:neverTransform))
	)
	((numericOpType types Type[]) Type 'static
		(define l (Arrays:asList types))
		(define otype Type:intType)
		(if (|| (l:contains Type:doubleType) (l:contains (ClassType:make "java.lang.Double")))
			(set otype Type:doubleType)
		(if (|| (l:contains Type:longType) (l:contains (ClassType:make "java.lang.Long")))
			(set otype Type:longType)
		)
		)
		otype
	)
	((allNumeric types Type[]) bool 'static
		(define i 0)
		(while (!= i (alen types))
			(define t (Main:tryUnbox (aget types i)))
			(if (! (instance? t PrimType))
				(return false)
			)
			(set i (+ i 1))
		)
		true
	)
	((tryBox t Type) Type 'static
		(if (instance? t PrimType)
			((as PrimType t):boxedType)
			t
		)
	)
	((tryUnbox t Type) Type 'static
		(define o (PrimType:unboxedType t))
		(if (= o null)
			t
			o
		)
	)
	((isCompare s String) bool 'static
		(|| (s:equals "!") (s:equals "&&") (s:equals "||") (Main:compare1Ops:containsKey s) (Main:compare2Ops:containsKey s))
	)
	((invertComp inv bool n int) int 'static
		(if inv
			(if (& n 1) (+ n 1) (- n 1))
			n
		)
	)
	((emitInvoke h Handler name String type Type emitter Emitters mi AMethodInfo code CodeAttr needed Type special bool) Type 'static
		(define output (!= code null))
		(define types (emitter:emitAll h mi null Main:unknownType))
		;(System:out:println name)
		;(System:out:println type)
		;(System:out:println (Arrays:toString types))
		(define filter (MFilter name types type))
		(filter:searchAll)
		(define mc (filter:getMethodCall))
		(define method mc:m)
		;(System:out:println method)
		(define typeParameters (method:getTypeParameters))
		(define params (method:getGenericParameterTypes))
		(define varargs (!= (& (method:getModifiers) Access:TRANSIENT) 0))
		(begin
			(define j 0)
			(define n
				(if
					(&&
						varargs
						(||
							(< (alen types) (alen params))
							(!= (Main:arrayDim (aget params (- (alen params) 1))) (Main:arrayDim (aget types (- (alen params) 1))))
						)
					)
					1
					0
				)
			)
			(while (!= j (- (alen params) n))
				((emitter:emitters:get j):emit h mi code (Main:resolveType mc:tvs mc:t (aget params j)))
				(set j (+ j 1))
			)
			(if (= n 1)
				(begin
					(define at ArrayType (aget params (- (alen params) 1)))
					(define et (Main:resolveType mc:tvs mc:t at:elements))
					(if output (code:emitPushInt (+ 1 (- (alen types) (alen params)))))
					(if output (code:emitNewArray (at:elements:getRawType)))
					(define oj j)
					(while (!= j (alen types))
						(if output (code:emitDup))
						(if output (code:emitPushInt (- j oj)))
						((emitter:emitters:get j):emit h mi code et)
						(if output (code:emitArrayStore))
						(set j (+ j 1))
					)
				)
			)
		)
		(if special
			(if output (code:emitInvokeSpecial method))
			(if output (code:emitInvoke method))
		)
		(define out (Main:resolveType mc:tvs mc:t (method:getReturnType)))
		(if (&& (!= out Type:voidType) (!= needed Type:voidType))
			(if output (code:emitCheckcast (out:getRawType)))
		)
		(Main:castMaybe code out needed)
	)
	((emitInvoke h Handler name String type Type emitter Emitters mi AMethodInfo code CodeAttr needed Type) Type 'static
		(Main:emitInvoke h name type emitter mi code needed false)
	)
	((compareType types Type[]) Type 'static
		(if (Main:allNumeric types)
			(Main:numericOpType types)
			Type:objectType
		)
	)
	;tok = condition
	((emitIf_ h Handler inv bool tok Token i int e int compare String trueE Emitter falseE Emitter mi AMethodInfo code CodeAttr needed Type) Type 'static
		(define output (!= code null))
		(if (compare:equals "!")
			(begin
				(Main:emitIf h (! inv) tok i trueE falseE mi code needed)
			)
		(if (|| (&& (! inv) (compare:equals "&&")) (&& inv (compare:equals "||")))
			(begin
				(define skipL (Label))
				(define falseL (Label))
				(define falseG (Goto falseL))
				(define i 1)
				(while (!= i (- e 1))
					(Main:emitIf h inv tok i Nothing:inst falseG mi code needed)
					(set i (+ i 1))
				)
				(Main:emitIf h inv tok (- e 1) (Emitters (Emitter[] trueE (Goto skipL))) null mi code needed)
				(if output (falseL:define code))
				(if (!= falseE null)
					(begin
						(falseE:emit h mi code needed)
					)
				)
				(if output (skipL:define code))
				(trueE:emit h mi null needed)
			)
		(if (|| (&& (! inv) (compare:equals "||")) (&& inv (compare:equals "&&")))
			(begin
				(define skipL (Label))
				(define trueL (Label))
				(define trueG (Goto trueL))
				(define i 1)
				(while (!= i (- e 1))
					(Main:emitIf h (! inv) tok i Nothing:inst trueG mi code needed)
					(set i (+ i 1))
				)
				(Main:emitIf h (! inv) tok (- e 1) (Emitters (Emitter[] falseE (Goto skipL))) null mi code needed)
				(if output (trueL:define code))
				(define type (trueE:emit h mi code needed))
				(if output (skipL:define code))
				type
			)
			(begin
				(define falseLabel (instance? falseE Goto))
				(define skip (Label))
				(define label
					(if falseLabel
						(as Goto falseE):label
						skip
					)
				)
				(if (Main:compare1Ops:containsKey compare)
					(begin
						(define j i)
						(while (!= j e)
							(define types (h:compileAll tok:toks j (+ j 1) mi null Main:unknownType))
							(define otype (Main:compareType types))
							(h:compileAll tok:toks j (+ j 1) mi code otype)
							(if output (code:emitGotoIfCompare1 label (Main:invertComp inv (Main:compare1Ops:get compare))))
							(set j (+ j 1))
						)
					)
					(begin
						(define j i)
						(while (!= (+ j 1) e)
							(define types (h:compileAll tok:toks j (+ j 2) mi null Main:unknownType))
							(define otype (Main:compareType types))
							(h:compileAll tok:toks j (+ j 2) mi code otype)
							(if output (code:emitGotoIfCompare2 label (Main:invertComp inv (Main:compare2Ops:get compare))))
							(set j (+ j 1))
						)
					)
				)
				(define type (trueE:emit h mi code needed))
				(if (! falseLabel)
					(begin
						(define end (Label))
						(if (&& (! (instance? trueE Nothing)) (!= falseE null))
							(if (&& output (code:reachableHere)) (code:emitGoto end))
						)
						(if output (skip:define code))
						(if (! (= falseE null))
							(begin
								(falseE:emit h mi code needed)
								(if output (end:define code))
							)
						)
					)
				)
				type
			)
		)
		)
		)
	)
	((emitIf h Handler inv bool tok Token i int trueE Emitter falseE Emitter mi AMethodInfo code CodeAttr needed Type) Type 'static
		(define cond (tok:toks:get i))
		(if (&& (instance? cond BlockToken) (instance? (cond:toks:get 0) VToken) (Main:isCompare (as VToken (cond:toks:get 0)):val))
			(Main:emitIf_ h inv cond 1 (cond:toks:size) (as VToken (cond:toks:get 0)):val trueE falseE mi code needed)
			(Main:emitIf_ h inv tok i (+ i 1) "!=0" trueE falseE mi code needed)
		)
	)
	((generateBridgeMethod target Method params Type[] ret Type) void 'static
		(define c (target:getDeclaringClass))
		(define rparams (Type[] len:(alen params)))
		(define i 0)
		(while (!= i (alen params))
			(aset rparams i ((aget params i):getRawType))
			(set i (+ i 1))
		)
		(define found (c:getDeclaredMethod (target:getName) rparams))
		(if (|| (= found null) (! (Type:isSame (found:getReturnType) ret)))
			(begin
				(define m (c:addMethod (target:getName) rparams (ret:getRawType) (| Access:PUBLIC Access:BRIDGE Access:SYNTHETIC)))
				(define code (m:startCode))
				(define i 0)
				(code:emitPushThis)
				(while (!= i (alen rparams))
					(code:emitLoad (code:getArg (+ i 1)))
					(Main:castMaybe code (aget rparams i) (aget (target:getGenericParameterTypes) i))
					(set i (+ i 1))
				)
				(code:emitInvoke target)
				(Main:castMaybe code (target:getReturnType) (ret:getRawType))
				(code:emitReturn)
			)
		)
	)
	((castMaybe code CodeAttr result Type needed Type) Type 'static
		(define output (!= code null))
		(if (|| (= needed Main:unknownType) (= result Main:returnType) (= result Main:throwType))
			result
		(begin
			(if (= needed Type:voidType)
				(if (!= result Type:voidType)
					(if output (code:emitPop 1))
				)
			(if (! (Type:isSame needed result))
				(if (instance? result PrimType)
					(begin
						(if (instance? needed ClassType)
							(if (= result Type:voidType)
								(if output (code:emitPushNull))
								(begin
									(define prim (PrimType:unboxedType needed))
									(define box
										(if (= prim null)
											(begin
												(set prim result)
												((as PrimType result):boxedType)
											)
											(begin
												(if output (code:emitConvert (as PrimType result) prim))
												(as ClassType needed)
											)
										)
									)
									(if output (code:emitInvoke (box:getMethod "valueOf" (Type[] prim))))
								)
							)
							(if output (code:emitConvert (as PrimType result) (as PrimType needed)))
						)
					)
				(if (instance? needed PrimType)
					(begin
						(define unbox (Main:unboxMethods:get result))
						(if output (code:emitInvoke unbox))
						(if output (code:emitConvert (as PrimType (unbox:getReturnType)) (as PrimType needed)))
					)
					(if output (code:emitCheckcast (needed:getRawType)))
				)
				)
			)
			)
			needed
		)
		)
	)
	((getCompilerType name String) ClassType 'static 'public
		(ClassType:make ("compiler2.":concat name))
	)
)

(define-class Emitter ()
	((<init>) void
		(super:<init>)
	)
	((emit h Handler mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define types (this:emitAll h mi code needed))
		(if (= types null)
			Type:voidType
			(begin
				(define l (alen types))
				(if (= l 0)
					Type:voidType
					(aget types (- l 1))
				)
			)
		)
	)
	((emitAll h Handler mi AMethodInfo code CodeAttr needed Object) Type[] 'public (Type[] (this:emit h mi code (as Type needed))))
)

(define-class Token (Emitter) 'public
	(line int 'public)
	(prec int 'public)
	(what String 'public)
	(toks List{Token} 'public)
	(alwaysTransform bool 'public)
	(neverTransform bool 'public)
	(transformed bool 'public 'transient)
	((<init>) void 'public
		(super:<init>)
		(set this:prec -1)
		(set this:what "")
		(set this:alwaysTransform false)
		(set this:neverTransform false)
		(set this:transformed false)
	)
	((<init> line int) void
		(set this:line line)
		(this:<init>)
	)
	((<init> line int prec int) void
		(this:<init> line)
		(set this:prec prec)
	)
	((<init> line int prec int what String) void 'public
		(this:<init> line prec)
		(set this:what what)
	)
	((<init> line int toks List{Token}) void 'public
		(this:<init> line)
		(set this:toks toks)
	)
	((repr) String 'public
		((this:getClass):getName)
	)
	((toString) String
		(define stoks "")
		(if (!= this:toks null)
			(begin
				(set stoks (stoks:concat " { "))
				(define i 0)
				(while (!= i (this:toks:size))
					(set stoks ((stoks:concat ((this:toks:get i):toString)):concat " "))
					(set i (+ i 1))
				)
				(set stoks (stoks:concat "} "))
			)
		)
		((org.apache.commons.lang3.StringEscapeUtils:escapeJava (this:repr)):concat stoks)
	)
	((emit h Handler mi AMethodInfo code CodeAttr needed Type) Type 'public
		(h:compile this mi code needed)
	)
)

(define-class SToken (Token) 'public
	(val String 'public)
	((<init> line int val String) void
		(super:<init> line)
		(set this:val val)
	)
	((<init>) void 'public
		(super:<init>)
	)
)

(define-class NToken (Token) 'public
	(val Number 'public)
	((<init> line int sval String) void
		(super:<init> line)
		(if (org.apache.commons.lang3.math.NumberUtils:isNumber sval)
			(set this:val (org.apache.commons.lang3.math.NumberUtils:createNumber sval))
		)
	)
	((<init>) void 'public
		(super:<init>)
	)
)

(define-class CToken (Token) 'public
	(val Character)
	((<init> line int val Character) void
		(super:<init> line)
		(set this:val val)
	)
	((<init>) void 'public
		(super:<init>)
	)
)

(define-class VToken (Token) 'public
	(val String 'public)
	(macro int 'public 'transient)
	((<init> line int val String macro int) void
		(super:<init> line)
		(set this:val val)
		(set this:macro macro)
	)
	((<init> line int val String) void
		(this:<init> line val 0)
	)
	((toString) String
		this:val
	)
	((<init>) void 'public
		(super:<init>)
	)
)

(define-class ConstToken (Token) 'public
	(val String 'public)
	((<init> line int val String) void
		(super:<init> line)
		(set this:val val)
	)
	((toString) String
		this:val
	)
	((<init>) void 'public
		(super:<init>)
	)
)

(define-class Lexer ()
	(code String)
	(i int)
	(ml int)
	(s String)
	(line int)
	((<init> code String) void
		(super:<init>)
		(set this:code code)
		(set this:ml (code:length))
		(set this:line 1)
	)
	((getprec) int
		;check if code at i is a special token
		(define ii this:i)
		(define p -1)
		(define l Main:ML)
		(while (! (|| (>= p 0) (= l 0)))
			(if (<= (+ ii l) this:ml)
				(begin
					(set this:s (this:code:substring ii (+ ii l)))
					(if (Main:s2prec:containsKey this:s)
						(set p (Main:s2prec:get this:s))
					)
				)
			)
			(set l (- l 1))
		)
		p
	)
	((nextTok) void
		(while (! (|| (= this:i this:ml) (= (this:code:charAt this:i) #\space) (>= (this:getprec) 0)))
			(set this:i (+ this:i 1))
		)
	)
	((token) Token
		(while (! (|| (! (Character:isWhitespace (this:code:charAt this:i))) (>= (this:getprec) 0)))
			(set this:i (+ this:i 1))
		)
		(define p (this:getprec))
		(if (< p 0)
			(begin
				(define oi this:i)
				(define c (this:code:charAt this:i))
				(if (= c #\")
					(begin
						(set this:i (+ this:i 1))
						(define esc false)
						(while (|| esc (!= (this:code:charAt this:i) #\"))
							(set esc (&& (! esc) (= (this:code:charAt this:i) #\\)))
							(set this:i (+ this:i 1))
						)
						(set this:i (+ this:i 1))
						(SToken this:line (org.apache.commons.lang3.StringEscapeUtils:unescapeJava (this:code:substring (+ oi 1) (- this:i 1))))
					)
				(if (= c #\#)
					(begin
						(set this:i (+ this:i 2))
						(this:nextTok)
						(define schar (this:code:substring (+ oi 2) this:i))
						(CToken this:line
							(if (= (schar:length) 1)
								(schar:charAt 0)
								(Main:specialChars:get schar)
							)
						)
					)
				(if (|| (Character:isDigit c) (&& (= c #\-) (Character:isDigit (this:code:charAt (+ this:i 1)))))
					(begin
						(this:nextTok)
						(NToken this:line (this:code:substring oi this:i))
					)
					(begin
						(this:nextTok)
						(define s (this:code:substring oi this:i))
						(if (|| (s:equals "null") (s:equals "true") (s:equals "false"))
							(ConstToken this:line s)
							(VToken this:line s)
						)
					)
				)
				)
				)
			)
			(begin
				(set this:i (+ this:i (this:s:length)))
				(if (this:s:contains "\n")
					(set this:line (+ this:line 1))
				)
				(Token this:line p this:s)
			)
		)
	)
	((lex) ArrayList
		(set this:i 0)
		(define out (ArrayList))
		(while
			(!= this:i this:ml)
			(out:add (this:token))
		)
		out
	)
)

(define-class BlockToken (Token) 'public
	(labels HashMap)
	((<init> line int toks List{Token}) void 'public
		(super:<init> line toks)
	)
	((<init>) void 'public
		(super:<init>)
	)
)

(define-class GenericToken (Token) 'public
	(tok Token 'public)
	((<init> line int tok Token toks List{Token}) void 'public
		(super:<init> line toks)
		(set this:tok tok)
	)
	((<init>) void 'public
		(super:<init>)
	)
)

(define-class ColonToken (Token) 'public
	((<init> line int toks List{Token}) void 'public
		(super:<init> line toks)
	)
	((<init>) void 'public
		(super:<init>)
	)
)

(define-class QuoteToken (Token) 'public
	((<init> line int toks List{Token}) void
		(super:<init> line toks)
		(set this:neverTransform true)
	)
	((<init>) void 'public
		(super:<init>)
	)
)

(define-class UnquoteToken (Token) 'public
	(var bool 'public)
	((<init> line int toks List{Token} var bool) void
		(super:<init> line toks)
		(set this:var var)
		(set this:alwaysTransform true)
	)
	((<init>) void 'public
		(super:<init>)
	)
)

(define-class Parser ()
	(toks ArrayList{Token})
	(i int)
	((<init> toks ArrayList{Token}) void
		(super:<init>)
		(set this:toks toks)
		(set this:i 0)
	)
	((next) Token
		(define ret (this:toks:get this:i))
		(set this:i (+ this:i 1))
		ret
	)
	((peek n int) Token
		(this:toks:get (+ this:i n))
	)
	((subToks end String) List{Token}
		(define toks (ArrayList{Token}))
		(while (! ((this:peek 0):what:equals end))
			(define t (this:parse 0))
			(if (!= t null) (toks:add t))
		)
		(this:next)
		toks
	)
	((parse prec int) Token
		(define t (this:next))
		(define w t:what)
		(define left Token
			(if (w:equals "(")
				(BlockToken t:line (this:subToks ")"))
			(if (w:equals ";")
				(begin
					(while (&& (!= this:i (this:toks:size)) (! ((this:next):what:contains "\n")))
						()
					)
					null
				)
			(if (|| (w:equals "'") (w:equals "`") (w:equals ",$") (w:equals ","))
				(begin
					(define al (ArrayList (Arrays:asList (Object[] (this:parse 0)))))
					(if (|| (w:equals ",") (w:equals ",$"))
						(UnquoteToken t:line al (w:equals ",$"))
						(QuoteToken t:line al)
					)
				)
			(if (&& (!= (w:length) 0) (Character:isWhitespace (w:charAt 0)))
					null
					t
			)
			)
			)
			)
		)
		(define cont true)
		(while (&& cont (!= this:i (this:toks:size)) (> (this:prec) prec))
			(define w (this:peek 0):what)
			(if (w:equals ":")
				(begin
					(this:next)
					(define right (this:parse 1))
					(set left (ColonToken t:line (ArrayList (Arrays:asList (Object[] left right)))))
				)
			(if (w:equals "{")
				(begin
					(this:next)
					(set left (GenericToken t:line left (this:subToks "}")))
				)
				(set cont false)
			)
			)
		)
		left
	)
	((prec) int
		(define w (this:peek 0):what)
		(if (Main:s2prec:containsKey w)
			(Main:s2prec:get w)
			0
		)
	)
	((parseAll) List{Token}
		(define out (ArrayList{Token}))
		(while (!= this:i (this:toks:size))
			(define t (this:parse 0))
			(if (!= t null) (out:add t))
		)
		out
	)
)

(define-class AVar ()
	(type Type)
	((<init> type Type) void (super:<init>) (set this:type type))
	((load code CodeAttr) Type this:type)
	((store code CodeAttr) void ())
)

(define-class Var (AVar)
	(var Variable)
	((<init> var Variable type Type) void (super:<init> type) (set this:var var))
	((load code CodeAttr) Type
		(define output (!= code null))
		(if output (code:emitLoad this:var))
		this:type
	)
	((store code CodeAttr) void
		(define output (!= code null))
		(if output (code:emitStore this:var))
	)
)

(define-class Arg (AVar)
	(n int)
	((<init> n int type Type) void (super:<init> type) (set this:n n))
	((load code CodeAttr) Type
		(define output (!= code null))
		(if output (code:emitLoad (code:getArg this:n)))
		(if output (code:emitCheckcast (this:type:getRawType)))
		this:type
	)
	((store code CodeAttr) void
		(define output (!= code null))
		(if output (code:emitStore (code:getArg this:n)))
	)
)

(define-class FileScope ()
	(name String)
	(toks List{Token})
	(locals HashMap)
	(imports HashMap)
	(starImports ArrayList{String})
	(found HashMap{String Boolean})
	(includes ClassInfo)
	(newClasses List{ClassInfo})
	(anonClasses List{ClassInfo})
	(package String)
	(macros ArrayList{ClassInfo})
	(macroNames HashMap{String List{ClassInfo}})
	((<init> name String toks List{Token} locals HashMap) void
		(super:<init>)
		(set this:name name)
		(set this:toks toks)
		(set this:locals locals)
		(set this:imports (HashMap))
		(set this:starImports (ArrayList))
		(this:starImports:add "java.lang.")
		(this:starImports:add "sjava.std.")
		(set this:found (HashMap{String Boolean}))
		(set this:newClasses (ArrayList{ClassInfo}))
		(set this:anonClasses (ArrayList{ClassInfo}))
		(set this:macros (ArrayList))
		(set this:package
			(if (&&
					(> (toks:size) 0)
					(instance? (toks:get 0) BlockToken)
					(instance? ((toks:get 0):toks:get 0) VToken)
					((as VToken ((toks:get 0):toks:get 0)):val:equals "package")
				)
				((as VToken ((toks:get 0):toks:get 1)):val:concat ".")
				""
			)
		)
	)
	((classExists name String) bool
		(if (this:found:containsKey name)
			(this:found:get name)
			(begin
				(define b
					(try
						(begin
							(Class:forName name)
							true
						)
						(e Throwable false)
					)
				)
				(this:found:put name b)
				b
			)
		)
	)
	((getNewType tok Token) ClassType
		(if (instance? tok GenericToken)
			(begin
				(define tok GenericToken tok)
				(define c (ClassType (this:package:concat (as VToken tok:tok):val)))
				(define params tok:toks)
				(define tparams (Type[] len:(params:size)))
				(define i 0)
				(while (!= i (params:size))
					(define name (as VToken (params:get i)):val)
					(define tv (TypeVariable name))
					(aset tparams i tv)
					(set i (+ i 1))
				)
				(c:setTypeParameters tparams)
				c
			)
		(if (instance? tok VToken)
			(ClassType (this:package:concat (as VToken tok):val))
			null
		)
		)
	)
	((compileRoot) void
		(define i 0)
		(while (!= i (this:toks:size))
			(this:compileRoot (this:toks:get i))
			(set i (+ i 1))
		)
	)
	((compileRoot tok Token) void
		(if (instance? (tok:toks:get 0) VToken)
			(begin
				(define first VToken (tok:toks:get 0))
				(if (first:val:equals "define-class")
					(begin
						(define c (this:getNewType (tok:toks:get 1)))
						(define name (c:getName))
						(define ci (ClassInfo c this))
						(set ci:toks tok:toks)
						(this:newClasses:add ci)
						(this:locals:put name ci:c)
						(define run true)
						(define i 3)
						(while (&& run (!= i (ci:toks:size)))
							(set run (Main:compileClassMod (ci:toks:get i) ci:c))
							(if run (set i (+ i 1)))
						)
					)
				(if (first:val:equals "import")
					(begin
						(define import (as VToken (tok:toks:get 1)):val)
						(if (import:equals "%tokens%")
							(begin
								(this:imports:put "Token" (Main:getCompilerType "Token"))
								(this:imports:put "BlockToken" (Main:getCompilerType "BlockToken"))
								(this:imports:put "VToken" (Main:getCompilerType "VToken"))
								(this:imports:put "ConstToken" (Main:getCompilerType "ConstToken"))
							)
						(if (import:contains "*")
							(this:starImports:add (import:replace "*" ""))
							(this:imports:put (import:substring (+ (import:lastIndexOf ".") 1)) (Type:getType import))
						)
						)
					)
				(if (first:val:equals "define-macro")
					(begin
						(define scope (HashMap))
						(define params (tok:toks:get 1))
						(define name (as VToken (params:toks:get 0)):val)
						(define o 4)
						(define types (Type[] len:(+ o (- (params:toks:size) 1)) (Type:getType "compiler2.AMethodInfo") (Type:getType "gnu.bytecode.Type") Type:intType (Type:getType "compiler2.Handler")))
						(scope:put "mi" (Arg 0 (Main:getCompilerType "AMethodInfo")))
						(define mods (| Access:PUBLIC Access:STATIC))
						(begin
							(define i 0)
							(while (!= (+ o i) (alen types))
								(define t (Type:getType "compiler2.Token"))
								(define name (as VToken (params:toks:get (+ i 1))):val)
								(if (name:contains "@")
									(begin
										(set name (name:replace "@" ""))
										(set mods (| mods Access:TRANSIENT))
										(set t (ArrayType t))
									)
								)
								(aset types (+ o i) t)
								(scope:put name (Arg (+ o i) t))
								(set i (+ i 1))
							)
						)
						(define cname ((("Macros$":concat (this:name:replace "/" "-")):concat "$"):concat (Integer:toString (this:macros:size))))
						(define macros (ClassInfo cname this))
						(macros:c:setModifiers Access:PUBLIC)
						(set tok:toks (tok:toks:subList 2 (tok:toks:size)))
						(define macro (MacroInfo macros (as BlockToken tok) (macros:c:addMethod name types (Type:getType "compiler2.Token") mods) scope))
						(if (this:macroNames:containsKey name)
							((this:macroNames:get name):add macros)
							(begin
								(define al (ArrayList{ClassInfo}))
								(al:add macros)
								(this:macroNames:put name al)
							)
						)
						(this:macros:add macros)
						(macros:methods:add macro)
					)
				)
				)
				)
			)
		)
	)
	((compileDefs) void
		(define i 0)
		(while (!= i (this:newClasses:size))
			((this:newClasses:get i):compileDefs)
			(set i (+ i 1))
		)
	)
	((compileMacros cl ArrayClassLoader) void
		(define i 0)
		(while (!= i (this:macros:size))
			(define macros (this:macros:get i))
			((macros:methods:get 0):compileMethodBody)
			(define cname (macros:c:getName))
			(define ba (macros:c:writeToArray))
			;(Files:write (Paths:get (("macros/":concat cname):concat ".class") (String[])) ba (OpenOption[]))
			(cl:addClass cname ba)
			(set macros:rc (cl:loadClass cname true))
			(set i (+ i 1))
		)
	)
	((compileIncludes) void
		(define includes (ClassInfo "Includes" this))
		(set this:includes includes)
		(includes:c:setModifiers Access:PUBLIC)
		(define n 0)
		(define i 0)
		(while (!= i (this:newClasses:size))
			(define methods (this:newClasses:get i):methods)
			(define j 0)
			(while (!= j (methods:size))
				(define method (methods:get j))
				(set n (this:compileIncludes method:block:toks n))
				(set j (+ j 1))
			)
			(set i (+ i 1))
		)
		(define cl (ArrayClassLoader))
		(cl:addClass "Includes" (includes:c:writeToArray))
		(set this:includes:rc (cl:loadClass "Includes" true))
	)
	((compileIncludes toks List{Token} n int) int
		(define i 0)
		(while (!= i (toks:size))
			(define tok (toks:get i))
			(if (&& (!= tok:toks null) (> (tok:toks:size) 0))
				(if (&& (instance? (tok:toks:get 0) VToken) ((as VToken (tok:toks:get 0)):val:equals "include"))
					(begin
						(define name ("$":concat (Integer:toString n)))
						(set tok:toks (tok:toks:subList 1 (tok:toks:size)))
						(define mi (MacroInfo this:includes (as BlockToken tok) (this:includes:c:addMethod name (Type[] (Type:getType "compiler2.AMethodInfo") (Type:getType "gnu.bytecode.Type") Type:intType (Type:getType "compiler2.Handler")) (Type:getType "compiler2.Token") (| Access:PUBLIC Access:STATIC)) (HashMap)))
						(toks:set i (IncludeToken tok:line mi))
						(this:includes:methods:add mi)
						(mi:compileMethodBody)
						(set n (+ n 1))
					)
					(set n (this:compileIncludes tok:toks n))
				)
			)
			(set i (+ i 1))
		)
		n
	)
	((compileMethods h Handler) void
		(define i 0)
		(while (!= i (this:newClasses:size))
			((this:newClasses:get i):compileMethods h)
			(set i (+ i 1))
		)
	)
)

(define-class ClassInfo () 'public
	(name String)
	(c ClassType)
	(fs FileScope)
	(toks List{Token})
	(methods List{AMethodInfo} 'public)
	(anonymous int)
	(rc Class)
	(tvs HashMap{String TypeVariable})
	((<init> c ClassType fs FileScope) void
		(super:<init>)
		(set this:fs fs)
		(set this:c c)
		(set this:toks (ArrayList{Token}))
		(set this:methods (ArrayList{AMethodInfo}))
		(set this:anonymous 1)
		(if (!= c null)
			(begin
				(this:c:setClassfileVersion ClassType:JDK_1_8_VERSION)
				(this:c:setSuper Type:javalangObjectType)
				(define args (c:getTypeParameters))
				(if (!= args null)
					(begin
						(set this:tvs (HashMap{String TypeVariable}))
						(define i 0)
						(while (!= i (alen args))
							(define tv Type (aget args i))
							(if (instance? tv TypeVariable)
								(this:tvs:put (tv:getName) (as TypeVariable tv))
							)
							(set i (+ i 1))
						)
					)
				)
			)
		)
	)
	((<init> name String fs FileScope) void
		(this:<init> (ClassType name) fs)
	)
	((writeFile dir String) void
		(define pre (dir:concat (this:fs:package:replace "." "/")))
		((File pre):mkdirs)
		(this:c:writeToFile ((pre:concat (this:c:getSimpleName)):concat ".class"))
	)
	((getType name String) Type
		(define i 0)
		(define dims -1)
		(while (!= i -1)
			(set i (name:indexOf "[]" (+ i 1)))
			(set dims (+ dims 1))
		)
		(set name (name:replace "[" ""))
		(set name (name:replace "]" ""))
		(define rel (name:contains "."))
		(define type Type
			(if (&& (!= this:tvs null) (this:tvs:containsKey name))
				(this:tvs:get name)
			(if (Main:constTypes:containsKey name)
				(Main:constTypes:get name)
			(if (this:fs:locals:containsKey name)
				(this:fs:locals:get name)
			(if (&& (! rel) (this:fs:locals:containsKey (this:fs:package:concat name)))
				(this:fs:locals:get (this:fs:package:concat name))
			(if (this:fs:imports:containsKey name)
				(this:fs:imports:get name)
				(begin
					(define type Type null)
					(define i 0)
					(while (&& (! rel) (= type null) (!= i (this:fs:starImports:size)))
						(define fullname ((this:fs:starImports:get i):concat name))
						(if (this:fs:locals:containsKey fullname)
							(set type (this:fs:locals:get fullname))
						(if (this:fs:classExists fullname)
							(set type (Type:getType fullname))
						)
						)
						(set i (+ i 1))
					)
					(if (&& (= type null) (this:fs:classExists name))
						(Type:getType name)
						type
					)
				)
			)
			)
			)
			)
			)
		)
		(set i 0)
		(while (!= i dims)
			(set type (ArrayType type))
			(set i (+ i 1))
		)
		type
	)
	((getType tok Token) Type
		(if (instance? tok GenericToken)
			(begin
				(define tok GenericToken tok)
				(define c ClassType ((this:getType (as VToken tok:tok):val):getRawType))
				(define params tok:toks)
				(define tparams (Type[] len:(params:size)))
				(define i 0)
				(while (!= i (params:size))
					(aset tparams i (this:getType (params:get i)))
					(set i (+ i 1))
				)
				(ParameterizedType c tparams)
			)
		(if (instance? tok VToken)
			(this:getType (as VToken tok):val)
			null
		)
		)
	)
	((compileDef tok Token) void
		(if (instance? tok BlockToken)
			(begin
				(define first (tok:toks:get 0))
				(if (instance? first BlockToken) ;method definition
					(begin
						(define scope (HashMap))
						(define mods 0)
						(define end false)
						(define i 2)
						(while (! (|| end (= i (tok:toks:size))))
							(define mod (tok:toks:get i))
							(if (instance? mod QuoteToken)
								(begin
									(set mods (| mods (Main:accessModifiers:get (as VToken (mod:toks:get 0)):val)))
									(set i (+ i 1))
								)
								(set end true)
							)
						)
						(define n 0)
						(if (= (& mods Access:STATIC) 0)
							(begin
								(scope:put "this" (Arg 0 this:c))
								(set n 1)
							)
						)
						(define types (Main:getParams this first scope 1 n))
						(define m Method (this:c:addMethod (as VToken (first:toks:get 0)):val types (this:getType (tok:toks:get 1)) mods))
						(define block (BlockToken tok:line (ArrayList (tok:toks:subList i (tok:toks:size)))))
						(this:methods:add (MethodInfo this block m scope))
					)
					(begin ;field definition
						(define mods 0)
						(define end false)
						(define i 2)
						(while (! (|| (= i (tok:toks:size)) end))
							(define mod (tok:toks:get i))
							(if (instance? mod QuoteToken)
								(begin
									(define nmod (Main:accessModifiers:get (as VToken (mod:toks:get 0)):val))
									(set mods (| mods nmod))
								)
								(set end true)
							)
							(set i (+ i 1))
						)
						(define t (this:getType (tok:toks:get 1)))
						(this:c:addField (as VToken first):val t mods)
					)
				)
			)
		)
	)
	((compileDefs) void
		(define c this:c)
		(define supers (this:toks:get 2):toks)
		(define i 0)
		(while (! (= i (supers:size)))
			(define related Type (this:getType (supers:get i)))
			(if (related:isInterface)
				(c:addInterface related)
				(c:setSuper related)
			)
			(set i (+ i 1))
		)
		(set i 3)
		(while (!= i (this:toks:size))
			(this:compileDef (this:toks:get i))
			(set i (+ i 1))
		)
	)
	((compileMethods h Handler) void
		(define i 0)
		(while (!= i (this:methods:size))
			(define mi (this:methods:get i))
			(mi:compileMethodBody h)
			(set i (+ i 1))
		)
	)
)

(define-class AMethodInfo () 'public
	(ci ClassInfo 'public)
	(block BlockToken)
	(method Method 'public)
	(scopes ArrayList{ArrayDeque{HashMap}})
	(labels ArrayDeque{HashMap})
	((<init> ci ClassInfo block BlockToken method Method scope HashMap) void
		(super:<init>)
		(set this:ci ci)
		(set this:block block)
		(set this:method method)
		(set this:scopes (ArrayList))
		(define h (ArrayDeque))
		(this:scopes:add h)
		(h:push scope)
		(set this:labels (ArrayDeque))
	)
	((pushScope code CodeAttr label HashMap) void
		(define output (!= code null))
		(define i 0)
		(while (!= i (this:scopes:size))
			((this:scopes:get i):push (HashMap))
			(set i (+ i 1))
		)
		(this:labels:push label)
		;(if output (code:pushScope))
	)
	((popScope code CodeAttr) void
		(define output (!= code null))
		(define i 0)
		(while (!= i (this:scopes:size))
			((this:scopes:get i):pop)
			(set i (+ i 1))
		)
		(this:labels:pop)
		;(if output (code:popScope))
	)
	((pushLevel) void 'public
		(this:scopes:add (ArrayDeque))
	)
	((popLevel) void 'public
		(this:scopes:remove (- (this:scopes:size) 1))
	)
	((getVar tok VToken) AVar
		(define scopes (this:scopes:get tok:macro))
		(define found AVar null)
		(define it (scopes:iterator))
		(while (&& (it:hasNext) (= found null))
			(define vars (it:next))
			(if (vars:containsKey tok:val)
				(set found (vars:get tok:val))
			)
		)
		found
	)
	((getLabel name String) Label
		(define found Label null)
		(define it Iterator (this:labels:iterator))
		(while (&& (it:hasNext) (= found null))
			(define vars HashMap (it:next))
			(if (vars:containsKey name)
				(set found (vars:get name))
			)
		)
		found
	)
	((newVar code CodeAttr tok VToken type Type) Variable
		(define output (!= code null))
		(define name tok:val)
		(define var Variable (if output (code:addLocal (type:getRawType) name) null))
		((as HashMap ((this:scopes:get tok:macro):getFirst)):put name (Var var type))
		var
	)
	((getType tok Token) Type
		(this:ci:getType tok)
	)
	((compileMethodBody h Handler) void
		(if (! (this:method:isAbstract))
			(begin
				(define tok this:block)
				(Main:transformBlock tok this)

				(this:pushScope null tok:labels)
				(h:compileAll tok:toks 0 (- (tok:toks:size) 1) this null Type:voidType)
				(h:compile (tok:toks:get (- (tok:toks:size) 1)) this null (this:method:getReturnType))
				(this:popScope null)

				(define filter (BridgeFilter this:method))
				(filter:searchAll)

				(define code (this:method:startCode))
				(this:pushScope code tok:labels)
				(h:compileAll tok:toks 0 (- (tok:toks:size) 1) this code Type:voidType)
				(define ret (h:compile (tok:toks:get (- (tok:toks:size) 1)) this code (this:method:getReturnType)))
				(this:popScope code)
				(code:popScope)

				(if (&& (!= ret Main:returnType) (code:reachableHere))
					(code:emitReturn)
				)
			)
		)
	)
	((compileMethodBody) void
		(this:compileMethodBody GenHandler:inst)
	)
)

(define-class MethodInfo (AMethodInfo)
	((<init> ci ClassInfo block BlockToken method Method scope HashMap) void
		(super:<init> ci block method scope)
	)
)

(define-class MacroInfo (AMethodInfo)
	((<init> ci ClassInfo block BlockToken method Method scope HashMap) void
		(super:<init> ci block method scope)
	)
)

(define-class IncludeToken (Token)
	(mi MacroInfo)
	(ret Token)
	((<init> line int mi MacroInfo) void
		(super:<init> line)
		(set this:mi mi)
	)
)

(define-class ObjectToken (Token) 'public
	(ci ClassInfo)
	(captured AVar[])
	(t Type)
	(params Type[])
	((<init> line int toks List{Token}) void
		(super:<init> line toks)
	)
)

(define-class LambdaToken (ObjectToken) 'public
	((<init> line int toks List{Token}) void
		(super:<init> line toks)
	)
)

(define-class MacroCallToken (Token) 'public
	(ret Token)
	((<init> line int toks List{Token}) void
		(super:<init> line toks)
	)
)

(define-class Goto (Emitter)
	(label Label)
	((<init> label Label) void (super:<init>) (set this:label label))
	((emit h Handler mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(if (&& output (code:reachableHere)) (code:emitGoto this:label))
		Type:voidType
	)
)

(define-class Null (Emitter)
	((<init>) void (super:<init>))
	((emit h Handler mi AMethodInfo code CodeAttr needed Type) Type 'public (if (! (= code null)) (code:emitPushNull)) Type:nullType)
)

(define-class LoadAVar (Emitter)
	(avar AVar)
	((<init> avar AVar) void
		(super:<init>)
		(set this:avar avar)
	)
	((emit h Handler mi AMethodInfo code CodeAttr needed Type) Type 'public
		(this:avar:load code)
	)
)

(define-class Emitters (Emitter)
	(emitters List{Emitter})
	((<init> emitters Emitter[]) void (super:<init>) (set this:emitters (Arrays:asList emitters)))
	((<init> emitters List{Emitter}) void (super:<init>) (set this:emitters emitters))
	((emitAll h Handler mi AMethodInfo code CodeAttr needed Object) Type[] 'public
		(define types (Type[] len:(this:emitters:size)))
		(define i 0)
		(while (< i (alen types))
			(define emitter (this:emitters:get i))
			(if (!= emitter null)
				(begin
					(aset types i (emitter:emit h mi code
						(if (instance? needed Type[])
							(aget (as Type[] needed) i)
							(as Type needed)
						)
					))
				)
			)
			(set i (+ i 1))
		)
		types
	)
)

(define-class MethodCall ()
	(m Method)
	(t Type)
	(tvs Map{TypeVariable Type})
	((<init> m Method t Type tvs Map{TypeVariable Type}) void
		(super:<init>)
		(set this:m m)
		(set this:t t)
		(set this:tvs tvs)
	)
)

(define-class AFilter ()
	(pt Type)
	((<init> pt Type) void
		(super:<init>)
		(set this:pt pt)
	)
	((select method Method generic Type) void 'abstract)
	((search t Type) void
		(define m ((as ClassType (t:getRawType)):getDeclaredMethods))
		(while (!= m null)
			(this:select m t)
			(set m (m:getNext))
		)
	)
	((searchAll) void
		(if (instance? this:pt ArrayType)
			(this:searchArray)
			(begin
				(define t this:pt)
				(define supers (ArrayList{Type}))
				(while (!= t null)
					(this:search t)
					(supers:add t)
					(set t (Main:resolveType t ((as ClassType (t:getRawType)):getGenericSuperclass)))
				)
				(define i 0)
				(while (!= i (supers:size))
					(define superC (supers:get i))
					(this:searchIntfs superC ((as ClassType (superC:getRawType)):getGenericInterfaces))
					(set i (+ i 1))
				)
			)
		)
	)
	((searchIntfs sub Type intfs Type[]) void
		(define j 0)
		(if (!= intfs null)
			(while (!= j (alen intfs))
				(define gintf (Main:resolveType sub (aget intfs j)))
				(this:search gintf)
				(this:searchIntfs gintf ((as ClassType (gintf:getRawType)):getGenericInterfaces))
				(set j (+ j 1))
			)
		)
	)
	((searchDeclared) void
		(this:search this:pt)
	)
	((searchArray) void
		(this:search Type:objectType)
	)
)

(define-class BridgeFilter (AFilter)
	(m Method)
	((<init> m Method) void
		(super:<init> (m:getDeclaringClass))
		(set this:m m)
	)
	((select method Method generic Type) void
		(define p1 (this:m:getGenericParameterTypes))
		(define p2 (method:getGenericParameterTypes))
		(define r1 (this:m:getReturnType))
		(define r2 (method:getReturnType))
		(if (&&
				((method:getName):equals (this:m:getName))
				(= (alen p1) (alen p2))
				(! (Type:isSame generic this:pt))
			)
			(begin
				(define n (alen p1))
				(define i 0)
				(define diff (! (Type:isSame (r1:getRawType) (r2:getRawType))))
				(define overrides true)
				(while (&& overrides (!= i n))
					(if (&&
							(! diff)
							(! (Type:isSame ((aget p1 i):getRawType) ((aget p2 i):getRawType)))
						)
						(set diff true)
					)
					(set overrides (Type:isSame (Main:resolveType generic (aget p1 i)) (Main:resolveType generic (aget p2 i))))
					(set i (+ i 1))
				)
				(if (&& diff overrides)
					(Main:generateBridgeMethod this:m p2 r2)
				)
			)
		)
	)
)

(define-class MFilter (AFilter)
	(methods0 ArrayList{MethodCall})
	(methods1 ArrayList{MethodCall})
	(varmethods ArrayList{MethodCall})
	(name String)
	(types Type[])
	((<init> name String types Type[] pt Type) void
		(super:<init> pt)
		(set this:methods0 (ArrayList))
		(set this:methods1 (ArrayList))
		(set this:varmethods (ArrayList))
		(set this:name name)
		(set this:types types)
	)
	((select method Method generic Type) void
		(define c (method:getDeclaringClass))
		(if (&&
				((method:getName):equals this:name)
				(||
					(! (c:isInterface))
					((as ClassType (generic:getRawType)):isInterface)
					(! (method:isAbstract))
				)
				(= 0 (& (method:getModifiers) Access:SYNTHETIC))
			)
			(begin
				(define varargs (!= (& (method:getModifiers) Access:TRANSIENT) 0))
				(define na (alen this:types))
				(define params (method:getGenericParameterTypes))
				(define np (alen params))
				(if (|| (= na np) (&& varargs (>= na (- np 1))))
					(begin
						(define arrayNeeded
							(&&
								varargs
								(||
									(= na (- np 1))
									(!= (Main:arrayDim (aget params (- np 1))) (Main:arrayDim (aget this:types (- np 1))))
								)
							)
						)
						(define reals
							(if arrayNeeded
								(begin
									(define types (Type[] len:np))
									(define default (= na (- np 1)))
									(System:arraycopy this:types 0 types 0 (- np 1))
									(aset types (- np 1)
										(if default
											(aget params (- np 1))
											(ArrayType (aget this:types (- np 1)))
										)
									)
									types
								)
								this:types
							)
						)
						(define tvs (Main:unresolveTvs (method:getTypeParameters) params reals))
						(define stop false)
						(define maxLevel 0)
						(define i 0)
						(while (! (|| stop (= i (alen this:types))))
							(define at
								(Main:resolveType tvs generic
									(if (&&
											arrayNeeded
											(>= i (- np 1))
										)
										(as ArrayType (aget params (- np 1))):elements
										(aget params i)
									)
								)
							)
							(define level (at:compare (aget this:types i)))
							(if (> level maxLevel)
								(set maxLevel level)
							)
							(if (< level 0)
								(set stop true)
							)
							(set i (+ i 1))
						)
						(define mc (MethodCall method generic tvs))
						(if (! stop)
							(if varargs
								(this:varmethods:add mc)
								(if (= maxLevel 0)
									(this:methods0:add mc)
									(this:methods1:add mc)
								)
							)
						)
					)
				)
			)
		)
	)
	((getMethodCall) MethodCall
		(if (= (this:methods0:size) 0)
			(if (= (this:methods1:size) 0)
				(if (= (this:varmethods:size) 0)
					null
					(this:varmethods:get 0)
				)
				(this:methods1:get 0)
			)
			(this:methods0:get 0)
		)
	)
	((getMethod) Method
		(define mc (this:getMethodCall))
		(if (= mc null)
			null
			mc:m
		)
	)
)

(define-class Handler () 'public
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool false)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type null)
	((compile tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(this:compile null tok mi code needed)
	)
	((compileAll toks List{Token} i int e int mi AMethodInfo code CodeAttr needed Object) Type[]
		(define l (toks:size))
		(define types (Type[] len: (- e i)))
		(define j i)
		(while (! (>= j e))
			(aset types (- j i)
				(this:compile (toks:get j) mi code
					(if (instance? needed Type[])
						(aget (as Type[] needed) (- j i))
						needed
					)
				)
			)
			(set j (+ j 1))
		)
		types
	)
	((tryHandlers h Handler default Type handlers List{Handler} tok Token mi AMethodInfo code CodeAttr needed Type) Type 'static
		(define i 0)
		(define type default)
		(define run true)
		(while (&& run (< i (handlers:size)))
			(define s (handlers:get i))
			(if (s:valid tok mi needed)
				(begin
					(set type (s:compile h tok mi code needed))
					(set run false)
				)
			)
			(set i (+ i 1))
		)
		type
	)
)

(define-class GenHandler (Handler) 'public
	(inst GenHandler 'static 'public)
	((<clinit>) void 'static (set GenHandler:inst (GenHandler)))
	(handlers List{Handler})
	((<init> handlers List{Handler}) void
		(super:<init>)
		(set this:handlers handlers)
	)
	((<init>) void
		(this:<init> (Arrays:asList (Object[]
			SHandler:inst
			CHandler:inst
			NHandler:inst
			ColonHandler:inst
			QuasiHandler:inst
			ConstsHandler:inst
			VHandler:inst
			IncludeHandler:inst
			ObjectHandler:inst
			MacroCallHandler:inst
			BlockHandler:inst
		)))
	)
	((compile tok Token mi AMethodInfo code CodeAttr needed Type) Type
		(define output (!= code null))
		(if output (code:putLineNumber (mi:ci:fs:name:substring (+ (mi:ci:fs:name:lastIndexOf "/") 1)) tok:line))
		(try
			(begin
				(define type (Handler:tryHandlers this Type:voidType this:handlers tok mi code needed))
				(Main:castMaybe code type needed)
			)
			(e Throwable
				(System:out:println (mi:ci:fs:name:concat (": Error compiling line ":concat (Integer:toString tok:line))))
				(throw e)
			)
		)
	)
)

(define-class MacroCallHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set MacroCallHandler:inst (MacroCallHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(instance? tok MacroCallToken)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define tok MacroCallToken tok)
		(if (= tok:ret null)
			(begin
				(define name (as VToken (tok:toks:get 0)):val)
				(define o 4)
				(define l (- (tok:toks:size) 1))
				(define types (Type[] len:(+ o l) (Type:getType "compiler2.AMethodInfo") (Type:getType "gnu.bytecode.Type") Type:intType (Type:getType "compiler2.Handler")))
				(define j 0)
				(while (!= j l)
					(aset types (+ o j) (Type:getType "compiler2.Token"))
					(set j (+ j 1))
				)
				(define method Method null)
				(define ci ClassInfo null)
				(define i 0)
				(while (= method null)
					(set ci ((mi:ci:fs:macroNames:get name):get i))
					(define filter (MFilter name types ci:c))
					(filter:searchDeclared)
					(set method (filter:getMethod))
					(set i (+ i 1))
				)
				(define params (method:getGenericParameterTypes))
				(define classes (Class[] len:(alen params)))
				(set j 0)
				(while (!= j (alen params))
					(aset classes j ((aget params j):getReflectClass))
					(set j (+ j 1))
				)
				(define args (ArrayList (Arrays:asList (Object[] mi needed (mi:scopes:size) h))))
				(args:addAll
					(if (&& (> (alen params) 0) (instance? (aget params (- (alen params) 1)) ArrayType))
						(begin
							(define var (- (alen params) o))
							(define al (ArrayList (tok:toks:subList 1 var)))
							(define out (Token[] len:(- (tok:toks:size) var)))
							((tok:toks:subList var (tok:toks:size)):toArray out)
							(al:add out)
							al
						)
						(tok:toks:subList 1 (tok:toks:size))
					)
				)
				(set tok:ret (Main:transformBlock (as Token ((ci:rc:getMethod name classes):invoke null (args:toArray))) mi))
			)
		)
		(mi:pushLevel)
		(define out (h:compile tok:ret mi code needed))
		(mi:popLevel)
		out
	)
)

(define-class IncludeHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set IncludeHandler:inst (IncludeHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(instance? tok IncludeToken)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define tok IncludeToken tok)
		(if (= tok:ret null)
			(set tok:ret
				(Main:transformBlock
					(as Token ((mi:ci:fs:includes:rc:getMethod ((as IncludeToken tok):mi:method:getName) (Class[]
						(class AMethodInfo)
						(class gnu.bytecode.Type)
						Integer:TYPE
						(class Handler)
					)):invoke null (Object[] mi needed 0 h)))
					mi
				)
			)
		)
		(h:compile tok:ret mi code needed)
	)
)

(define-class SHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set SHandler:inst (SHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(instance? tok SToken)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(if output (code:emitPushString (as SToken tok):val))
		Type:javalangStringType
	)
)

(define-class CHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set CHandler:inst (CHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(instance? tok CToken)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define c int (as CToken tok):val)
		(if (! (instance? needed PrimType))
			(begin
				(if output (code:emitPushInt c))
				Type:charType
			)
			(begin
				(if output (code:emitPushConstant c needed))
				needed
			)
		)
	)
)

(define-class NHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set NHandler:inst (NHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(instance? tok NToken)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define tok NToken tok)
		(if (instance? tok:val Double)
			(begin
				(if output (code:emitPushDouble (as Double tok:val)))
				Type:doubleType
			)
			(begin
				(if (! (instance? needed PrimType))
					(begin
						(if output (code:emitPushInt (as Integer tok:val)))
						Type:intType
					)
					(begin
						(if output (code:emitPushConstant (as Integer tok:val) needed))
						needed
					)
				)
			)
		)
	)
)

(define-class ColonHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set ColonHandler:inst (ColonHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(instance? tok ColonToken)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:toks:get 0))
		(define t (mi:getType first))
		(if (= t null)
			(set t (h:compile first mi code Main:unknownType))
		)
		(define class ClassType (t:getRawType))
		(define field Field (class:getField (as VToken (tok:toks:get 1)):val -1))
		(if (field:getStaticFlag)
			(if output (code:emitGetStatic field))
			(if output (code:emitGetField field))
		)
		(define out (Main:resolveType t (field:getType)))
		(if (!= out Type:voidType)
			(if output (code:emitCheckcast (out:getRawType)))
		)
		out
	)
)

(define-class QuasiHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set QuasiHandler:inst (QuasiHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(instance? tok QuoteToken)
	)
	((compileQuasi h Handler o Object mi AMethodInfo code CodeAttr needed Type) Type
		(define output (!= code null))
		(define result
			(if (= o null)
				(begin
					(if output (code:emitPushNull))
					Type:nullType
				)
			(if (instance? o Token)
				(begin
					(define tok Token o)
					(define t (if (instance? tok UnquoteToken) (h:compile (tok:toks:get 0) mi null Main:unknownType) null))
					(if (&& (instance? tok UnquoteToken) (|| (= t (Type:getType "compiler2.Token")) (&& (instance? t ArrayType) (= (as ArrayType t):elements (Type:getType "compiler2.Token"))) ((t:getRawType):isSubtype (Type:getType "java.util.List"))))
						(h:compile (tok:toks:get 0) mi code Main:unknownType)
						(if (instance? tok UnquoteToken)
							(begin
								(define const (tok:toks:get 0))
								(define t (h:compile const mi null Main:unknownType))
								(define type ClassType
									(if (as UnquoteToken tok):var
										(Type:getType "compiler2.VToken")
									(if (= t Type:charType)
										(Type:getType "compiler2.CToken")
									(if (instance? t PrimType)
										(Type:getType "compiler2.NToken")
										(Type:getType "compiler2.SToken")
									)
									)
									)
								)
								(if output (code:emitNew type))
								(if output (code:emitDup))
								(if output (code:emitInvoke (type:getDeclaredMethod "<init>" 0)))
								(if output (code:emitDup))
								(h:compile const mi code Type:objectType)
								(if output (code:emitPutField (type:getField "val")))
								(Type:getType "compiler2.Token")
							)	
							(begin
								(define type ClassType (Type:getType ((o:getClass):getName)))
								(if output (code:emitNew type))
								(if output (code:emitDup))
								(if output (code:emitInvoke (type:getDeclaredMethod "<init>" 0)))
								(define superC type)
								(while (!= superC null)
									(define field (superC:getFields))
									(while (!= field null)
										(if (&&
												(!= (& (field:getModifiers) Access:PUBLIC) 0)
												(= (& (field:getModifiers) Access:TRANSIENT) 0)
											)
											(begin
												(if output (code:emitDup))
												(if (= (field:getType) Type:intType)
													(this:compileQuasi h ((field:getReflectField):getInt tok) mi code (field:getType))
													(this:compileQuasi h ((field:getReflectField):get tok) mi code (field:getType))
												)
												(if output (code:emitPutField field))
											)
										)
										(set field (field:getNext))
									)
									(set superC (superC:getSuperclass))
								)
								(if (= type (Type:getType "compiler2.VToken"))
									(begin
										(if output (code:emitDup))
										(if output (code:emitLoad (code:getArg 2)))
										(if output (code:emitPutField (type:getField "macro")))
									)
								)
								(Type:getType "compiler2.Token")
							)
						)
					)
				)
			(if (instance? o String)
				(begin
					(if output (code:emitPushString (as String o)))
					Type:javalangStringType
				)
			(if (instance? o Integer)
				(begin
					(if output (code:emitPushInt (as Integer o)))
					Type:intType
				)
			(if (instance? o Boolean)
				(begin
					(if output (code:emitPushInt (as int (as Boolean o))))
					Type:booleanType
				)
			(if (instance? o List)
				(begin
					(define o List o)
					(define al ClassType (Type:getType "java.util.ArrayList"))
					(if output (code:emitNew al))
					(if output (code:emitDup))
					(if output (code:emitInvoke (al:getMethod "<init>" (Type[]))))
					(define i 0)
					(while (!= i (o:size))
						(define t (this:compileQuasi h (o:get i) mi null Main:unknownType))
						(if (= t (Type:getType "compiler2.Token"))
							(begin
								(if output (code:emitDup))
								(this:compileQuasi h (o:get i) mi code Main:unknownType)
								(if output (code:emitInvoke (al:getMethod "add" (Type[] Type:objectType))))
								(if output (code:emitPop 1))
							)
						(if (instance? t ArrayType)
							(begin
								(if output (code:emitDup))
								(this:compileQuasi h (o:get i) mi code Main:unknownType)
								(if output (code:emitInvoke ((as ClassType (Type:getType "java.util.Collections")):getDeclaredMethod "addAll" 2)))
								(if output (code:emitPop 1))
							)
							(begin
								(if output (code:emitDup))
								(this:compileQuasi h (o:get i) mi code Main:unknownType)
								(if output (code:emitInvoke ((as ClassType (Type:getType "java.util.List")):getDeclaredMethod "addAll" 1)))
								(if output (code:emitPop 1))
							)
						)
						)
						(set i (+ i 1))
					)
					al
				)
				(throw (Exception))
			)
			)
			)
			)
			)
			)
		)
		(Main:castMaybe code result needed)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(this:compileQuasi h (tok:toks:get 0) mi code (Type:getType "compiler2.Token"))
	)
)

(define-class ConstsHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set ConstsHandler:inst (ConstsHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(instance? tok ConstToken)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define val (as ConstToken tok):val)
		(if (val:equals "true")
			(begin
				(if output (code:emitPushInt 1))
				Type:booleanType
			)
		(if (val:equals "false")
			(begin
				(if output (code:emitPushInt 0))
				Type:booleanType
			)
			(begin
				(if output (code:emitPushNull))
				Type:nullType
			)
		)
		)
	)
)

(define-class VHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set VHandler:inst (VHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(instance? tok VToken)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define found (mi:getVar (as VToken tok)))
		(found:load code)
	)
)

(define-class CaptureVHandler (Handler)
	(enc AMethodInfo)
	(captured Map{AVar Field})
	(n int)
	((<init> enc AMethodInfo) void
		(super:<init>)
		(set this:enc enc)
		(set this:captured (LinkedHashMap))
	)
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(instance? tok VToken)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define found (mi:getVar (as VToken tok)))
		(if (= found null)
			(begin
				(define outer (this:enc:getVar (as VToken tok)))
				(if (= outer null) (throw (Exception)))
				(define field
					(if output
						(if (this:captured:containsKey outer)
							(this:captured:get outer)
							(begin
								(define new (mi:ci:c:addField ("captured$":concat (Integer:toString this:n)) outer:type Access:SYNTHETIC))
								(set this:n (+ this:n 1))
								(this:captured:put outer new)
								new
							)
						)
						null
					)
				)
				(if output (code:emitPushThis))
				(if output (code:emitGetField field))
				outer:type
			)
			(found:load code)
		)
	)
)

(define-class BeginBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set BeginBlockHandler:inst (BeginBlockHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(if (instance? (tok:toks:get 0) VToken)
			(begin
				(define first VToken (tok:toks:get 0))
				(first:val:equals "begin")
			)
			false
		)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first VToken (tok:toks:get 0))
		;(define newLevel (= first:macro (mi:scopes:size)))
		;(if (< (mi:scopes:size) first:macro)
		;	(throw (Exception))
		;)
		;(if newLevel (mi:scopes:add (ArrayDeque)))
		(mi:pushScope code (as BlockToken tok):labels)
		(h:compileAll tok:toks 1 (- (tok:toks:size) 1) mi code Type:voidType)
		(define type (h:compile (tok:toks:get (- (tok:toks:size) 1)) mi code needed))
		;(if newLevel (mi:scopes:remove (- (mi:scopes:size) 1)))
		(mi:popScope code)
		type
	)
)

(define-class LabelBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set LabelBlockHandler:inst (LabelBlockHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(if (instance? (tok:toks:get 0) VToken)
			(begin
				(define first VToken (tok:toks:get 0))
				(first:val:equals "label")
			)
			false
		)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:toks:get 0))
		(define label (mi:getLabel (as VToken (tok:toks:get 1)):val))
		(if output (label:define code))
		Type:voidType
	)
)

(define-class GotoBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set GotoBlockHandler:inst (GotoBlockHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(if (instance? (tok:toks:get 0) VToken)
			(begin
				(define first VToken (tok:toks:get 0))
				(first:val:equals "goto")
			)
			false
		)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:toks:get 0))
		(define label (mi:getLabel (as VToken (tok:toks:get 1)):val))
		(if output (code:emitGoto label))
		Type:voidType
	)
)

(define-class DefineBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set DefineBlockHandler:inst (DefineBlockHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(if (instance? (tok:toks:get 0) VToken)
			(begin
				(define first VToken (tok:toks:get 0))
				(first:val:equals "define")
			)
			false
		)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first VToken (tok:toks:get 0))
		(define type (mi:getType (tok:toks:get 2)))
		(if (= type null)
			(set type (h:compile (tok:toks:get 2) mi code Main:unknownType))
		(if (= (tok:toks:size) 4)
			(h:compile (tok:toks:get 3) mi code type)
			(if output (code:emitPushDefaultValue needed))
		)
		)
		(define var (mi:newVar code (as VToken (tok:toks:get 1)) type))
		(if output (code:emitStore var))
		Type:voidType
	)
)

(define-class TryBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set TryBlockHandler:inst (TryBlockHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(if (instance? (tok:toks:get 0) VToken)
			(begin
				(define first VToken (tok:toks:get 0))
				(first:val:equals "try")
			)
			false
		)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(if output (code:emitTryStart false null))
		(define type (h:compile (tok:toks:get 1) mi code needed))
		(define catch (tok:toks:get 2))
		(mi:pushScope code (as BlockToken catch):labels)
		(define var (mi:newVar code (as VToken (catch:toks:get 0)) Type:javalangThrowableType))
		(if output (code:emitCatchStart var))
		(h:compileAll catch:toks 2 (catch:toks:size) mi code Main:unknownType)
		(if output (code:emitCatchEnd))
		(mi:popScope code)
		(if output (code:emitTryCatchEnd))
		type
	)
)

(define-class InstanceBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set InstanceBlockHandler:inst (InstanceBlockHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(if (instance? (tok:toks:get 0) VToken)
			(begin
				(define first VToken (tok:toks:get 0))
				(first:val:equals "instance?")
			)
			false
		)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:toks:get 0))
		(h:compile (tok:toks:get 1) mi code Main:unknownType)
		(if output (code:emitInstanceof (mi:getType (tok:toks:get 2))))
		Type:booleanType
	)
)

(define-class SetBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set SetBlockHandler:inst (SetBlockHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(if (instance? (tok:toks:get 0) VToken)
			(begin
				(define first VToken (tok:toks:get 0))
				(first:val:equals "set")
			)
			false
		)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:toks:get 0))
		(define out (tok:toks:get 1))
		(if (instance? out ColonToken)
			(begin
				(define first (out:toks:get 0))
				(define t (mi:getType first))
				(if (= t null)
					(set t (h:compile first mi code Main:unknownType))
				)
				(define class ClassType (t:getRawType))
				(define field Field (class:getField (as VToken (out:toks:get 1)):val -1))
				(h:compile (tok:toks:get 2) mi code (Main:resolveType t (field:getType)))
				(if (field:getStaticFlag)
					(if output (code:emitPutStatic field))
					(if output (code:emitPutField field))
				)
			)
			(begin
				(define var (mi:getVar (as VToken (tok:toks:get 1))))
				(h:compile (tok:toks:get 2) mi code var:type)
				(var:store code)
			)
		)
		Type:voidType
	)
)

(define-class ASetBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set ASetBlockHandler:inst (ASetBlockHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(if (instance? (tok:toks:get 0) VToken)
			(begin
				(define first VToken (tok:toks:get 0))
				(first:val:equals "aset")
			)
			false
		)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:toks:get 0))
		(define type ArrayType (h:compile (tok:toks:get 1) mi code Main:unknownType))
		(h:compile (tok:toks:get 2) mi code Main:unknownType)
		(h:compile (tok:toks:get 3) mi code type:elements)
		(if output (code:emitArrayStore))
		Type:voidType
	)
)

(define-class AGetBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set AGetBlockHandler:inst (AGetBlockHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(if (instance? (tok:toks:get 0) VToken)
			(begin
				(define first VToken (tok:toks:get 0))
				(first:val:equals "aget")
			)
			false
		)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:toks:get 0))
		(define type ArrayType (h:compile (tok:toks:get 1) mi code Main:unknownType))
		(h:compile (tok:toks:get 2) mi code Type:intType)
		(if output (code:emitArrayLoad))
		type:elements
	)
)

(define-class ALenBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set ALenBlockHandler:inst (ALenBlockHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(if (instance? (tok:toks:get 0) VToken)
			(begin
				(define first VToken (tok:toks:get 0))
				(first:val:equals "alen")
			)
			false
		)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:toks:get 0))
		(h:compile (tok:toks:get 1) mi code Main:unknownType)
		(if output (code:emitArrayLength))
		Type:intType
	)
)

(define-class AsBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set AsBlockHandler:inst (AsBlockHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(if (instance? (tok:toks:get 0) VToken)
			(begin
				(define first VToken (tok:toks:get 0))
				(first:val:equals "as")
			)
			false
		)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:toks:get 0))
		(define cast (mi:getType (tok:toks:get 1)))
		(h:compile (tok:toks:get 2) mi code cast)
	)
)

(define-class BinOpsBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set BinOpsBlockHandler:inst (BinOpsBlockHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(if (instance? (tok:toks:get 0) VToken)
			(begin
				(define first VToken (tok:toks:get 0))
				(Main:binOps:containsKey first:val)
			)
			false
		)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first VToken (tok:toks:get 0))
		(define otype (Main:numericOpType (h:compileAll tok:toks 1 (tok:toks:size) mi null Main:unknownType)))
		(h:compile (tok:toks:get 1) mi code otype)
		(define i 2)
		(while (!= i (tok:toks:size))
			(h:compile (tok:toks:get i) mi code otype)
			(if output (code:emitBinop (Main:binOps:get first:val) otype))
			(set i (+ i 1))
		)
		otype
	)
)

(define-class IfBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set IfBlockHandler:inst (IfBlockHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(if (instance? (tok:toks:get 0) VToken)
			(begin
				(define first VToken (tok:toks:get 0))
				(first:val:equals "if")
			)
			false
		)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:toks:get 0))
		(Main:emitIf h false tok 1 (tok:toks:get 2) (if (= (tok:toks:size) 4) (tok:toks:get 3) null) mi code needed)
	)
)

(define-class Add1 (Emitter)
	(e Emitter)
	((<init> e Emitter) void
		(super:<init>)
		(set this:e e)
	)
	((emit h Handler mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(this:e:emit h mi code needed)
		(if output (code:emitPushInt 1))
		(if output (code:emitAdd Type:intType))
		Type:intType
	)
)

;(define-class MacroBlockHandler (Handler)
	;(inst Handler 'static)
	;((<clinit>) void 'static (set MacroBlockHandler:inst (MacroBlockHandler)))
	;((<init>) void (super:<init>))
	;((valid tok Token mi AMethodInfo needed Type) bool 'public
		;(if (instance? (tok:toks:get 0) VToken)
			;(begin
				;(define first VToken (tok:toks:get 0))
				;(first:val:equals "macro")
			;)
			;false
		;)
	;)
	;((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		;(define output (!= code null))
		;(define first (tok:toks:get 0))
		;(define name String (as VToken (tok:toks:get 1)):val)
		;(define emitters List{Emitter} (ArrayList (Arrays:asList (Emitter[]
			;(LoadAVar (Arg 0 (Type:getType "AMethodInfo")))
			;(LoadAVar (Arg 1 (Type:getType "gnu.bytecode.Type")))
			;(Add1 (LoadAVar (Arg 2 Type:intType)))
		;))))
		;(emitters:addAll (Emitters:tokenEmitters tok:toks 2 (tok:toks:size)))
		;(define types ((Emitters emitters):emitAll h mi null Main:unknownType))
		;(define macro ClassInfo null)
		;(define i 0)
		;(while (= macro null)
			;(define test ((mi:ci:fs:macroNames:get name):get i))
			;(define filter (MFilter name types test:c))
			;(filter:searchDeclared)
			;(if (!= (filter:getMethod) null)
				;(set macro test)
			;)
		;)
		;(Main:emitInvoke h name macro:c (Emitters emitters) mi code Main:unknownType)
	;)
;)

(define-class WhileBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set WhileBlockHandler:inst (WhileBlockHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(if (instance? (tok:toks:get 0) VToken)
			(begin
				(define first VToken (tok:toks:get 0))
				(first:val:equals "while")
			)
			false
		)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:toks:get 0))
		(mi:pushScope code (as BlockToken tok):labels)
		(define start Label (Label))
		(if output (start:define code))
		(define t (Main:emitIf h false tok 1 (Emitters (Emitter[] (Emitters (tok:toks:subList 2 (tok:toks:size))) (Goto start))) null mi code needed))
		(mi:popScope code)
		t
	)
)

(define-class CompareBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set CompareBlockHandler:inst (CompareBlockHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(if (instance? (tok:toks:get 0) VToken)
			(begin
				(define first VToken (tok:toks:get 0))
				(Main:isCompare first:val)
			)
			false
		)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:toks:get 0))
		(Main:emitIf_ h false tok 1 (tok:toks:size) (as VToken first):val (ConstToken tok:line "true") (ConstToken tok:line "false") mi code Type:booleanType)
	)
)

(define-class ColonBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set ColonBlockHandler:inst (ColonBlockHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(instance? (tok:toks:get 0) ColonToken)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:toks:get 0))
		(define name (as VToken (first:toks:get 1)):val)
		(define special
			(&&
				(instance? (first:toks:get 0) VToken)
				((as VToken (first:toks:get 0)):val:equals "super")
			)
		)
		(define t
			(if special
				(begin
					(if output (code:emitPushThis))
					(mi:ci:c:getGenericSuperclass)
				)
				(mi:getType (first:toks:get 0))
			)
		)
		(if (= t null)
			(set t (h:compile (first:toks:get 0) mi code Main:unknownType))
		)
		(Main:emitInvoke h name t (Emitters (tok:toks:subList 1 (tok:toks:size))) mi code needed special)
	)
)

(define-class DefaultBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set DefaultBlockHandler:inst (DefaultBlockHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		true
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:toks:get 0))
		(define type Type (mi:getType first))
		(if (= type null)
			(begin
				(define t (h:compile first mi code Main:unknownType))
				(define c ClassType (t:getRawType))
				(define method (c:getDeclaredMethods))
				(define i 0)
				(define tocall Method null)
				(while (!= method null)
					(if (&& (! ((method:getName):equals "<init>")) (= 0 (& Access:SYNTHETIC (method:getModifiers))))
						(if (= tocall null)
							(set tocall method)
							(throw (Exception))
						)
					)
					(set method (method:getNext))
				)
				(Main:emitInvoke h (tocall:getName) t (Emitters (tok:toks:subList 1 (tok:toks:size))) mi code Main:unknownType)
			)
			(if (instance? type ArrayType)
				(begin
					(define array ArrayType type)
					(define len Token (if (> (tok:toks:size) 1) (tok:toks:get 1) null))
					(define i0
						(if (&& (!= len null) (instance? len ColonToken) ((as VToken (len:toks:get 0)):val:equals "len"))
							(begin (h:compile (len:toks:get 1) mi code Main:unknownType) 2)
							(begin (if output (code:emitPushInt (- (tok:toks:size) 1))) 1)
						)
					)
					(if output (code:emitNewArray (array:elements:getRawType)))
					(define i i0)
					(while (!= i (tok:toks:size))
						(if output (code:emitDup))
						(if output (code:emitPushInt (- i i0)))
						(h:compile (tok:toks:get i) mi code array:elements)
						(if output (code:emitArrayStore))
						(set i (+ i 1))
					)
					type
				)
				(begin
					(define class ClassType (type:getRawType))
					(if output (code:emitNew class))
					(if output (code:emitDup))
					(Main:emitInvoke h "<init>" type (Emitters (tok:toks:subList 1 (tok:toks:size))) mi code Main:unknownType)
					type
				)
			)
		)
	)
)

(define-class ThrowBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set ThrowBlockHandler:inst (ThrowBlockHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(if (instance? (tok:toks:get 0) VToken)
			(begin
				(define first VToken (tok:toks:get 0))
				(first:val:equals "throw")
			)
			false
		)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(h:compile (tok:toks:get 1) mi code Main:unknownType)
		(if output (code:emitThrow))
		Main:throwType
	)
)

(define-class ClassBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set ClassBlockHandler:inst (ClassBlockHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(if (instance? (tok:toks:get 0) VToken)
			(begin
				(define first VToken (tok:toks:get 0))
				(first:val:equals "class")
			)
			false
		)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(if output (code:emitPushClass (as ObjectType (mi:getType (tok:toks:get 1)))))
		Type:javalangClassType
	)
)

(define-class SynchronizedBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set SynchronizedBlockHandler:inst (SynchronizedBlockHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(if (instance? (tok:toks:get 0) VToken)
			(begin
				(define first VToken (tok:toks:get 0))
				(first:val:equals "synchronized")
			)
			false
		)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(h:compile (tok:toks:get 1) mi code Main:unknownType)
		(mi:pushScope code (as BlockToken tok):labels)
		(if output (code:emitDup))
		(if output (code:emitMonitorEnter))
		(h:compileAll tok:toks 2 (- (tok:toks:size) 1) mi code Type:voidType)
		(define type (h:compile (tok:toks:get (- (tok:toks:size) 1)) mi code needed))
		(if output (code:emitMonitorExit))
		(mi:popScope code)
		type
	)
)

(define-class TypeBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set TypeBlockHandler:inst (TypeBlockHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(if (instance? (tok:toks:get 0) VToken)
			(begin
				(define first VToken (tok:toks:get 0))
				(first:val:equals "type")
			)
			false
		)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(if output (code:emitLoad (code:getArg 0)))
		(if output (code:emitInvoke ((ClassType:make "compiler2.AMethodInfo"):getDeclaredMethod "pushLevel" 0)))
		(if output (code:emitLoad (code:getArg 3)))
		(h:compile (tok:toks:get 1) mi code Main:unknownType)
		(if output (code:emitLoad (code:getArg 0)))
		(if output (code:emitInvoke ((ClassType:make "compiler2.Main"):getDeclaredMethod "transformBlock" 2)))
		(if output (code:emitLoad (code:getArg 0)))
		(if output (code:emitPushNull))
		(if output (code:emitGetStatic ((ClassType:make "compiler2.Main"):getField "unknownType")))
		(if output (code:emitInvoke ((ClassType:make "compiler2.Handler"):getDeclaredMethod "compile" 4)))
		(if output (code:emitLoad (code:getArg 0)))
		(if output (code:emitInvoke ((ClassType:make "compiler2.AMethodInfo"):getDeclaredMethod "popLevel" 0)))
		(Type:getType "gnu.bytecode.Type")
	)
)

(define-class ReturnBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set ReturnBlockHandler:inst (ReturnBlockHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(if (instance? (tok:toks:get 0) VToken)
			(begin
				(define first VToken (tok:toks:get 0))
				(first:val:equals "return")
			)
			false
		)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(if (= (tok:toks:size) 2)
			(h:compile (tok:toks:get 1) mi code Main:unknownType)
		)
		(if output (code:emitReturn))
		Main:returnType
	)
)

(define-class ObjectHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set ObjectHandler:inst (ObjectHandler)))
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(instance? tok ObjectToken)
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define tok ObjectToken tok)
		(define lambda (instance? tok LambdaToken))
		(define ci tok:ci)
		(define superT (tok:toks:get 1))
		(define FunctionN (&& lambda (instance? superT BlockToken)))
		(define emitters
			(Emitters (if
				(|| lambda (! (instance? superT BlockToken)))
					(ArrayList)
					(superT:toks:subList 1 (superT:toks:size))
				)
			)
		)
		(if (= ci null)
			(begin
				(define handlers (ArrayList GenHandler:inst:handlers))
				(define captureH (CaptureVHandler mi))
				(handlers:set (handlers:indexOf VHandler:inst) captureH)
				(define h (GenHandler handlers))
				(if output
					(begin
						(set ci (ClassInfo ((mi:ci:c:getName):concat ("$":concat (Integer:toString mi:ci:anonymous))) mi:ci:fs))
						(set tok:ci ci)
						(mi:ci:fs:anonClasses:add ci)
						(set mi:ci:anonymous (+ mi:ci:anonymous 1))
					)
				)
				(if FunctionN
					(begin
						(define scope (HashMap))
						(define params (Main:getParams mi:ci superT scope 0 1))
						(define generics (Type[] len:(+ (alen params) 1)))
						(System:arraycopy params 0 generics 0 (alen params))
						(define block (BlockToken tok:line (tok:toks:subList 2 (tok:toks:size))))
						(define fakemi (MethodInfo (ClassInfo null mi:ci:fs) block null scope))
						(h:compileAll block:toks 0 (- (block:toks:size) 1) fakemi null Type:voidType)
						(define ret (Main:tryBox (h:compile (block:toks:get (- (block:toks:size) 1)) fakemi null Main:unknownType)))
						(aset generics (alen params) ret)
						(define t (ParameterizedType (ClassType:make ("sjava.std.Function":concat (Integer:toString (alen params)))) generics))
						(set tok:t t)
						(if output
							(begin
								(define m (ci:c:addMethod "apply" params ret Access:PUBLIC))
								(ci:c:addInterface t)
								(define mi (MethodInfo ci block m scope))
								(mi:compileMethodBody h)
							)
						)
					)
				(if lambda
					(begin
						(define t (mi:getType superT))
						(set tok:t t)
						(if output
							(begin
								(define sam ((as ClassType (t:getRawType)):checkSingleAbstractMethod))
								(define scope (HashMap))
								(define args (tok:toks:get 2))
								(define i 0)
								(define params (Type[] len:(args:toks:size)))
								(while (!= i (args:toks:size))
									(define arg VToken (args:toks:get i))
									(define param (Main:resolveType t (aget (sam:getGenericParameterTypes) i)))
									(scope:put arg:val (Arg (+ i 1) param))
									(aset params i param)
									(set i (+ i 1))
								)
								(ci:c:addInterface t)
								(define m (ci:c:addMethod (sam:getName) params (Main:resolveType t (sam:getReturnType)) Access:PUBLIC))
								(define block (BlockToken tok:line (tok:toks:subList 3 (tok:toks:size))))
								(define mi (MethodInfo ci block m scope))
								(mi:compileMethodBody h)
							)
						)
					)
					(begin
						(define t
							(if (instance? superT BlockToken)
								(mi:getType (superT:toks:get 0))
								(mi:getType superT)
							)
						)
						(set tok:t t)
						(if output
							(begin
								(if ((as ClassType (t:getRawType)):isInterface)
									(ci:c:addInterface t)
									(ci:c:setSuper t)
								)
								(define i 2)
								(while (!= i (tok:toks:size))
									(ci:compileDef (tok:toks:get i))
									(set i (+ i 1))
								)
								(set i 0)
								(while (!= i (ci:methods:size))
									(define mi (ci:methods:get i))
									(mi:compileMethodBody h)
									(set i (+ i 1))
								)
							)
						)
					)
				)
				)
				(if output
					(begin
						(define superC (ci:c:getSuperclass))
						(define types (emitters:emitAll h mi null Main:unknownType))
						(define filter (MFilter "<init>" types superC))
						(filter:searchDeclared)
						(define superCons (filter:getMethod))
						(set tok:captured (AVar[] len:(captureH:captured:size)))
						((captureH:captured:keySet):toArray tok:captured)
						(define fields (Field[] len:(captureH:captured:size)))
						((captureH:captured:values):toArray fields)
						(define n (alen (superCons:getGenericParameterTypes)))
						(define params (Type[] len:(+ n (alen fields))))
						(System:arraycopy (superCons:getGenericParameterTypes) 0 params 0 n)
						(define i 0)
						(while (!= i (alen fields))
							(aset params (+ n i) ((aget fields i):getType))
							(set i (+ i 1))
						)
						(define cons (ci:c:addMethod "<init>" params Type:voidType 0))
						(define code (cons:startCode))
						(code:emitLoad (code:getArg 0))
						(set i 0)
						(while (!= i n)
							(code:emitLoad (code:getArg (+ i 1)))
							(set i (+ i 1))
						)
						(code:emitInvoke superCons)
						(set i 0)
						(while (!= i (alen fields))
							(code:emitPushThis)
							(code:emitLoad (code:getArg (+ n i 1)))
							(code:emitPutField (aget fields i))
							(set i (+ i 1))
						)
						(code:emitReturn)
					)
				)
			)
		)
		(if output (code:emitNew ci:c))
		(if output (code:emitDup))
		(if output
			(begin
				(define i 0)
				(while (!= i (alen tok:captured))
					(emitters:emitters:add (LoadAVar (aget tok:captured i)))
					(set i (+ i 1))
				)
				(Main:emitInvoke h "<init>" ci:c emitters mi code Main:unknownType)
			)
		)
		tok:t
	)
)

(define-class Nothing (Emitter)
	(inst Nothing 'static)
	((<clinit>) void 'static
		(set Nothing:inst (Nothing))
	)
	((<init>) void
		(super:<init>)
	)
	((emit h Handler mi AMethodInfo code CodeAttr needed Type) Type 'public
		Type:voidType
	)
)

(define-class BlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set BlockHandler:inst (BlockHandler)))
	(handlers List{Handler})
	((<init> handlers List{Handler}) void
		(super:<init>)
		(set this:handlers handlers)
	)
	((<init>) void
		(this:<init> (Arrays:asList (Object[]
			BeginBlockHandler:inst
			LabelBlockHandler:inst
			GotoBlockHandler:inst
			DefineBlockHandler:inst
			TryBlockHandler:inst
			InstanceBlockHandler:inst
			SetBlockHandler:inst
			ASetBlockHandler:inst
			AGetBlockHandler:inst
			ALenBlockHandler:inst
			AsBlockHandler:inst
			BinOpsBlockHandler:inst
			IfBlockHandler:inst
			WhileBlockHandler:inst
			CompareBlockHandler:inst
			ColonBlockHandler:inst
			ThrowBlockHandler:inst
			ClassBlockHandler:inst
			SynchronizedBlockHandler:inst
			TypeBlockHandler:inst
			ReturnBlockHandler:inst
			DefaultBlockHandler:inst
		)))
	)
	((valid tok Token mi AMethodInfo needed Type) bool 'public
		(&& (instance? tok BlockToken) (> (tok:toks:size) 0))
	)
	((compile h Handler tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define type (Handler:tryHandlers h null this:handlers tok mi code needed))
		type
	)
)
