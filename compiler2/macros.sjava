(import gnu.bytecode.*)
(import java.util.*)
(import %tokens%)

(define-macro (inc v n)
	`(set ,v (+ ,v ,n))
)
(define-macro (inc v)
	`(inc ,v 1)
)
(define-macro (dec v n)
	`(set ,v (- ,v ,n))
)
(define-macro (dec v)
	`(dec ,v 1)
)
(define-macro (forEachI item iterable index @block)
	(if (instance? (type iterable) ArrayType)
		`(begin
			(define array ,iterable)
			(define ,index 0)
			(while (!= ,index (alen array))
				(define ,item (aget array ,index))
				,block
				(inc ,index)
			)
		)
		`(begin
			(define iterable ,iterable)
			(define it (iterable:iterator))
			(define ,index 0)
			(while (it:hasNext)
				(define ,item (it:next))
				,block
				(inc ,index)
			)
		)
	)
)
(define-macro (forEach item iterable @block)
	`(forEachI ,item ,iterable notused ,block)
)
(define-macro (print @objects)
	`(System:out:print (concat ,objects))
)
(define-macro (println @objects)
	`(System:out:println (concat ,objects))
)
(define-macro (mapAI item collection i @block)
	(define t (type collection))
	(define itemT
		(if (instance? t ArrayType)
			((as ArrayType t):getComponentType)
			(type
				`(begin
					(define collection ,collection)
					((collection:iterator):next)
				)
			)
		)
	)
	(define len
		(if (instance? t ArrayType)
			`(alen collection)
			`(collection:size)
		)
	)
	(define arrElement `(begin (define ,item ,$(itemT:getName)) (define ,i int) ,block))
	(define o (type arrElement))
	`(begin
		(define collection ,collection)
		(define out (,$((o:getName):concat "[]") len:,len))
		(forEachI ,item collection ,i (aset out ,i (begin ,block)))
		out
	)
)
(define-macro (mapA item iterable @block)
	`(mapAI ,item ,iterable i ,block)
)
(define-macro (concat @objects)
	(define appends
		(mapA o objects
			(if (instance? (type o) ArrayType)
				`(sb:append (java.util.Arrays:toString ,o))
				`(sb:append ,o)
			)
		)
	)
	`(begin
		(define sb (StringBuilder))
		,appends
		(sb:toString)
	)
)
(define-macro (let inits @block)
	(define defines
		(mapA init inits:toks
			`(define (unquote init:toks))
		)
	)
	`(begin
		,defines
		,block
	)
)
(define-macro (for inits test step @block)
	`(let ,inits
		(while ,test
			(begin
				,block
			)
			,step
		)
	)
)
(define-macro (repeat n @block)
	`(for ((i ,n)) (> i 0) (dec i) ,block)
)
(define-macro (cond @cases)
	(define out (aget cases (- (alen cases) 1)))
	(define n
		(if
			(&&
				(instance? (out:toks:get 0) ConstToken)
				((as ConstToken (out:toks:get 0)):val:equals "true")
			)
			(begin
				(set out `(begin ,(out:toks:subList 1 (out:toks:size))))
				2
			)
			(begin
				(set out `())
				1
			)
		)
	)
	(for ((i (- (alen cases) n))) (>= i 0) (dec i)
		(define case (aget cases i))
		(set out
			`(if ,(case:toks:get 0)
				(begin
					,(case:toks:subList 1 (case:toks:size))
				)
				,out
			)
		)
	)
	out
)
(define-macro (instanceCond var @cases)
	(define newCases
		(mapA case cases
			(if
				(&&
					(instance? (case:toks:get 0) ConstToken)
					((as ConstToken (case:toks:get 0)):val:equals "true")
				)
				case
				`((instance? ,var ,(case:toks:get 0))
					(define ,var ,(case:toks:get 0) ,var)
					,(case:toks:subList 1 (case:toks:size))
				)
			)
		)
	)
	`(cond
		,newCases
	)
)
(define-macro (doubleDispatch call arg)
	(define j 1)
	(define special 0)
	(while (&& (!= j (call:toks:size)) (= special 0))
		(define arg VToken (call:toks:get j))
		(if (arg:val:equals "_")
			(set special j)
		)
		(inc j)
	)
	(define conds (ArrayList))
	(define mname (as VToken ((call:toks:get 0):toks:get 1)):val)
	(define nargs (alen (mi:method:getParameterTypes)))
	(forEach omi mi:ci:methods
		(if
			(&&
				((omi:method:getName):equals mname) (!= mi omi)
				(= nargs (alen (omi:method:getParameterTypes)))
			)
			(begin
				(define t (aget (omi:method:getParameterTypes) (- special 1)))
				(define ncall `((unquote call:toks)))
				(ncall:toks:set special `(as ,$(t:getName) ,arg))
				(conds:add
					`((instance? ,arg ,$(t:getName))
						,ncall
					)
				)
			)
		)
	)
	(define out
		`(cond
			,conds
			(true (throw (RuntimeException (concat "Double dispatch with " ,arg))))
		)
	)
	out
)
(define-macro (with obj @calls)
	`(begin
		(define obj ,obj)
		,(mapA call calls
			`(obj:,(call:toks:get 0) ,(call:toks:subList 1 (call:toks:size)))
		)
		obj
	)
)
(define-macro (chain obj @calls)
	(define out obj)
	(forEach call calls
		(set out `((unquote out):(unquote (call:toks:get 0)) ,(call:toks:subList 1 (call:toks:size))))
	)
	out
)
