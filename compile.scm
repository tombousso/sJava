(define-alias Field gnu.bytecode.Field)
(define-alias ClassType gnu.bytecode.ClassType)
(define-alias Access gnu.bytecode.Access)
(define-alias Method gnu.bytecode.Method)
(define-alias CodeAttr gnu.bytecode.CodeAttr)
(define-alias Type gnu.bytecode.Type)
(define-alias ArrayType gnu.bytecode.ArrayType)
(define-alias Label gnu.bytecode.Label)
(define-alias PrimType gnu.bytecode.PrimType)
(define-alias Variable gnu.bytecode.Variable)
(define-alias ClassTypeWriter gnu.bytecode.ClassTypeWriter)
(define-alias ArrayClassLoader gnu.bytecode.ArrayClassLoader)
(define-alias TypeVariable gnu.bytecode.TypeVariable)
(define-alias ParameterizedType gnu.bytecode.ParameterizedType)
(define-alias ObjectType gnu.bytecode.ObjectType)

(define-alias System java.lang.System)
(define-alias Class java.lang.Class)
(define-alias Integer java.lang.Integer)

(define println (lambda (. rest)
	(write rest)
	(newline)
))

(define readln (lambda ()
	((java.lang.System:console):readLine)
))

(define found ::java.util.HashMap (java.util.HashMap))

(define (classExists name ::String)
	(if (found:containsKey name)
		(found:get name)
		(begin
			(define b
				(try-catch
					(begin
						(java.lang.Class:forName name)
						#t
					)
					(exp java.lang.Throwable #f)
				)
			)
			(found:put name b)
			b
		)
	)
)

(define precs ::String[][] (String[][]
	(String[] ":" "'" "{" "}")
	(String[] "(" ")")
	(String[] "\n" "\r\n")
	(String[] ";")
))

(define MP (- (length precs) 1))

(define ML 2)

(define s2prec ::java.util.HashMap (java.util.HashMap))

(do ((i 0 (+ i 1)))
	((= i (length precs)))
	(for-each
		(lambda (s)
			(s2prec:put s i)
		)
		(precs i)
	)
)

(define-simple-class Token ()
	(what ::String)
	(val)
	(ops ::java.util.List)
	(prec init: 0)
	(line)
	((*init* line0 what0 val0)
		(set! line line0)
		(set! what what0)
		(set! val val0)
	)
	((*init* line0 what0 val0 prec0)
		(invoke-special Token (this) '*init* line0 what0 val0)
		(set! prec prec0)
	)
	((*init* line0 what0 val0 prec0 ops0)
		(invoke-special Token (this) '*init* line0 what0 val0 prec0)
		(set! ops ops0)
	)
	((repr)
		(string-append
			(number->string line)
			":"
			(number->string prec)
			":"
			(if (eq? val #!null)
				what
				((string-append what ":" (val:toString)):toString)
			)
		)
	)
	((toString)
		(define sops ::String "")
		(if (not (eq? ops #!null))
			(set! sops (string-append " | " (apply string-append (map (lambda (t) (string-append (t:toString) " ")) ops)) "| "))
		)
		((string-append (org.apache.commons.lang3.StringEscapeUtils:escapeJava (repr)) sops):toString)
	)
)

(define specialChars ::java.util.HashMap (java.util.HashMap))
(specialChars:put "space" #\space)
(specialChars:put "\\" #\\)

(define-simple-class Lexer ()
	(code ::String)
	(i)
	(ml)
	(s ::String)
	(line)
	((*init* code0 ::String)
		(set! code code0)
		(set! ml (length code))
		(set! line 1)
	)
	((getprec)
		(define ii i)
		(define p -1)
		(do ((l ML (- l 1)))
			((or (>= p 0) (= l 0)))
			(if (<= (+ ii l) ml)
				(begin
					(set! s (code:substring ii (+ ii l)))
					(if (s2prec:containsKey s)
						(set! p (s2prec:get s))
					)
				)
			)
		)
		p
	)
	((nextTok)
		(do ()
			((or (= i ml) (eq? (code:charAt i) #\space) (>= (getprec) 0)))
			(set! i (+ i 1))
		)
	)
	((token) ::Token
		(do ()
			((or (not (java.lang.Character:isWhitespace (code:charAt i))) (>= (getprec) 0)))
			(set! i (+ i 1))
		)
		(define p (getprec))
		(if (< p 0)
			(begin
				(define oi i)
				(define c (code:charAt i))
				(if (eq? c #\")
					(begin
						(set! i (+ i 1))
						(define esc #f)
						(do ()
							((and (not esc) (eq? (code:charAt i) #\")))
							(set! esc (and (not esc) (eq? (code:charAt i) #\\)))
							(set! i (+ i 1))
						)
						(set! i (+ i 1))
						(Token line "S" (org.apache.commons.lang3.StringEscapeUtils:unescapeJava (code:substring (+ oi 1) (- i 1))))
					)
				(if (eq? c #\#)
					(begin
						(set! i (+ i 2))
						(nextTok)
						(define schar ::String (code:substring (+ oi 2) i))
						(Token line "C"
							(if (= (schar:length) 1)
								(schar:charAt 0)
								(specialChars:get schar)
							)
						)
					)
				(if (or (java.lang.Character:isDigit c) (eq? c #\-))
					(begin
						(nextTok)
						(Token line "N" (code:substring oi i))
					)
					(begin
						(nextTok)
						(Token line "V" (code:substring oi i))
					)
				)
				)
				)
			)
			(begin
				(set! i (+ i (s:length)))
				(if (s:contains "\n")
					(set! line (+ line 1))
				)
				(Token line s #!null p)
			)
		)
	)
	((lex)
		(set! i 0)
		(define out ::java.util.ArrayList (java.util.ArrayList))
		(do
			()
			((= i ml))
			(out:add (token))
		)
		out
	)
)

(define (shiftDown toks ::java.util.List i n)
	(define l (toks:size))
	(define nl (- l n))
	(do ((i i (+ i 1)))
		((= i nl))
		(toks:set i (toks:get (+ i n)))
	)
	((toks:subList (- l n) l):clear)
)

(define-simple-class Parser ()
	(toks ::java.util.ArrayList)
	((*init* toks0)
		(set! toks toks0)
	)
	((block i e o c)
		(define oi i)
		(define oe e)
		(define end #f)
		(do ((i (+ i 1) (+ i 1)))
			(end)
			(define t ::Token (toks:get i))
			(define w t:what)
			(if (w:equals o)
				(begin
					(set! e (- e (block i e o c)))
				)
			)
			(if (w:equals c)
				(begin
					(define d (parse (+ oi 1) i MP 0))
					(set! i (- i d))
					(set! e (- e d))
					(define n (- i oi))
					(set! (toks oi) (Token (as Token (toks oi)):line o #!null -1 (java.util.ArrayList (toks:subList (+ oi 1) i))))
					(shiftDown toks (+ oi 1) n)
					(set! e (- e n))
					(set! end #t)
				)
			)
		)
		(- oe e)
	)
	((generic i e o c)
		(define oi i)
		(define oe e)
		(define end #f)
		(do ((i (+ i 1) (+ i 1)))
			(end)
			(define t ::Token (toks:get i))
			(define w t:what)
			(if (w:equals o)
				(begin
					(set! e (- e (generic i e o c)))
					(set! i (- i 1))
				)
			)
			(if (w:equals c)
				(begin
					(define d (parse (+ oi 1) i MP 0))
					(set! i (- i d))
					(set! e (- e d))
					(define n (+ (- i oi) 1))
					(set! (toks (- oi 1)) (Token t:line "generic" "" -1 (java.util.ArrayList (toks:get (- oi 1)) (Token (as Token (toks oi)):line o #!null -1 (java.util.ArrayList (toks:subList (+ oi 1) i))))))
					(shiftDown toks oi n)
					(set! e (- e n))
					(set! end #t)
				)
			)
		)
		(- oe e)
	)
	((comment i e)
		(define oi i)
		(define oe e)
		(define end #f)
		(do ((i i (+ i 1)))
			(end)
			(if (or (= i (toks:size)) ((as Token (toks:get i)):what:contains "\n"))
				(begin
					(define n (- i oi))
					(shiftDown toks oi n)
					(set! e (- e n))
					(set! end #t)
				)
			)
		)
		(- oe e)
	)
	((parse i e p mp)
		;(println i e p mp (toks:get i) (toks:get (- e 1)))
		(define oi i)
		(define oe e)
		(define end #f)
		(do ((i i (+ i 1)))
			((or end (= i e)))
			(define t ::Token (toks:get i))
			(define w t:what)
			(if (= t:prec p)
				(begin
					(if (w:equals "(")
						(set! e (- e (block i e "(" ")")))
					)
					(if (w:equals "{")
						(begin
							(set! e (- e (generic i e "{" "}")))
							(set! i (- i 1))
						)
					)
					(if (w:equals ";")
						(begin
							(set! e (- e (comment i e)))
							(set! i (- i 1))
						)
					)
					(if (w:equals ":")
						(begin
							(set! (toks (- i 1)) (Token t:line w "" -1 (java.util.ArrayList (toks (- i 1)) (toks (+ i 1)))))
							(shiftDown toks i 2)
							(set! e (- e 2))
							(set! i (- i 1))
						)
					)
					(if (w:equals "'")
						(begin
							(set! (toks i) (Token t:line w "" -1 (java.util.ArrayList (java.util.Arrays:asList (toks (+ i 1))))))
							(shiftDown toks (+ i 1) 1)
							(set! e (- e 1))
						)
					)
					(if (java.lang.Character:isWhitespace (w:charAt 0))
						(begin
							(shiftDown toks i 1)
							(set! e (- e 1))
							(set! i (- i 1))
						)
					)
				)
			)
		)
		(if (> p mp)
			(set! e (- e (parse oi e (- p 1) mp)))
		)
		(- oe e)
	)
)

(define-simple-class AVar ()
	((*init*) ())
	(type ::Type)
	((load code ::CodeAttr) ())
	((store code ::CodeAttr) ())
)

(define-simple-class Var (AVar)
	(var ::Variable)
	((*init* var0 ::Variable type0) (set! var var0) (set! (this):type type0))
	((load code ::CodeAttr)
		(code:emitLoad var)
	)
	((store code ::CodeAttr)
		(code:emitStore var)
	)
)

(define-simple-class Arg (AVar)
	(n)
	((*init* n0 type0 ::Type)
		(set! n n0)
		(set! (this):type type0)
	)
	((load code ::CodeAttr)
		(code:emitLoad (code:getArg n))
	)
	((store code ::CodeAttr)
		(code:emitStore (code:getArg n))
	)
)

(define-simple-class Emitter ()
	((emit compiler ::Compiler classes ::Classes c ::ClassType mi ::MethodInfo code ::CodeAttr needed ::Type) ::Type Type:voidType)
)

(define-simple-class TokensEmitter (Emitter)
	(toks ::java.util.ArrayList)
	(i)
	(l)
	((*init* toks0 i0 l0)
		(set! toks toks0)
		(set! i i0)
		(set! l l0)
	)
	((emit compiler ::Compiler classes ::Classes c ::ClassType mi ::MethodInfo code ::CodeAttr needed ::Type) ::Type
		(define type ::Type Type:voidType)
		(do ((j i (+ j 1)))
			((= j l))
			(set! type (compiler:compile_ classes (toks:get j) c mi code needed))
		)
		type
	)
)

(define-simple-class TokenEmitter (Emitter)
	(tok ::Token)
	((*init* tok0)
		(set! tok tok0)
	)
	((emit compiler ::Compiler classes ::Classes c ::ClassType mi ::MethodInfo code ::CodeAttr needed ::Type) ::Type
		(compiler:compile_ classes tok c mi code needed)
	)
)

(define-simple-class Goto (Emitter)
	(label ::Label)
	((*init* label0) (set! label label0))
	((emit compiler ::Compiler classes ::Classes c ::ClassType mi ::MethodInfo code ::CodeAttr needed ::Type) ::Type (if (not (eq? code #!null)) (code:emitGoto label)) Type:voidType)
)

(define-simple-class Emitters (Emitter)
	(emitters ::Emitter[])
	((*init* emitters0) (set! emitters emitters0))
	((emit compiler ::Compiler classes ::Classes c ::ClassType mi ::MethodInfo code ::CodeAttr needed ::Type) ::Type
		(define type ::Type  Type:voidType)
		(for-each
			(lambda (emitter) (set! type (emitter:emit compiler classes c mi code needed)))
			emitters
		)
		type
	)
)

(define-simple-class MethodInfo ()
	(method ::Method)
	(scopes ::java.util.ArrayDeque)
	(labels ::java.util.ArrayDeque)
	((*init* method0 scope0)
		(set! method method0)
		(set! scopes (java.util.ArrayDeque))
		(scopes:push scope0)
		(set! labels (java.util.ArrayDeque))
	)
	((pushScope code ::CodeAttr label ::java.util.HashMap)
		(define output (not (eq? code #!null)))
		(scopes:push (java.util.HashMap))
		(labels:push label)
		(if output (code:pushScope))
	)
	((popScope code ::CodeAttr)
		(define output (not (eq? code #!null)))
		(scopes:pop)
		(labels:pop)
		(if output (code:popScope))
	)
	((getVar name) ::AVar
		;(println "SEARCH" name)
		(define found ::AVar #!null)
		(define it ::java.util.Iterator (scopes:iterator))
		(do ()
			((not (eq? found #!null)))
			(define vars ::java.util.HashMap (it:next))
			(if (vars:containsKey name)
				(set! found (vars:get name))
			)
		)
		found
	)
	((getLabel name) ::Label
		(define found ::Label #!null)
		(define it ::java.util.Iterator (labels:iterator))
		(do ()
			((not (eq? found #!null)))
			(define vars ::java.util.HashMap (it:next))
			(if (vars:containsKey name)
				(set! found (vars:get name))
			)
		)
		found
	)
)

(define unboxMethods ::java.util.HashMap (java.util.HashMap))
(unboxMethods:put (Type:shortType:boxedType) (*:getDeclaredMethod Type:javalangNumberType "shortValue" 0))
(unboxMethods:put (Type:intType:boxedType) (*:getDeclaredMethod Type:javalangNumberType "intValue" 0))
(unboxMethods:put (Type:longType:boxedType) (*:getDeclaredMethod Type:javalangNumberType "longValue" 0))
(unboxMethods:put (Type:doubleType:boxedType) (*:getDeclaredMethod Type:javalangNumberType "doubleValue" 0))
(unboxMethods:put (Type:booleanType:boxedType) (*:getDeclaredMethod Type:javalangBooleanType "booleanValue" 0))
(unboxMethods:put (Type:charType:boxedType) (*:getDeclaredMethod Type:javalangCharacterType "charValue" 0))

(define constTypes ::java.util.HashMap (java.util.HashMap))
(constTypes:put "bool" Type:booleanType)
(constTypes:put "byte" Type:byteType)
(constTypes:put "char" Type:charType)
(constTypes:put "double" Type:doubleType)
(constTypes:put "float" Type:floatType)
(constTypes:put "int" Type:intType)
(constTypes:put "long" Type:longType)
(constTypes:put "short" Type:shortType)
(constTypes:put "void" Type:voidType)

(define accessModifiers ::java.util.HashMap (java.util.HashMap))
(accessModifiers:put "static" Access:STATIC)
(accessModifiers:put "public" Access:PUBLIC)
(accessModifiers:put "abstract" Access:ABSTRACT)
(accessModifiers:put "final" Access:FINAL)
(accessModifiers:put "private" Access:PRIVATE)
(accessModifiers:put "protected" Access:PROTECTED)
(accessModifiers:put "synchronized" Access:SYNCHRONIZED)
(accessModifiers:put "transient" Access:TRANSIENT)
(accessModifiers:put "volatile" Access:VOLATILE)
(accessModifiers:put "native" Access:NATIVE)
(accessModifiers:put "interface" Access:INTERFACE)
(accessModifiers:put "super" Access:SUPER)

(define binOps ::java.util.HashMap (java.util.HashMap))
(binOps:put "+" 96)
(binOps:put "-" 100)
(binOps:put "*" 104)
(binOps:put "/" 108)
(binOps:put "%" 112)
(binOps:put "&" 126)
(binOps:put "|" 128)
(binOps:put "^" 130)

(define compare2Ops ::java.util.HashMap (java.util.HashMap))
;opposites
(compare2Ops:put "!=" 153)
(compare2Ops:put "=" 154)
(compare2Ops:put ">=" 155)
(compare2Ops:put "<" 156)
(compare2Ops:put "<=" 157)
(compare2Ops:put ">" 158)

(define compare1Ops ::java.util.HashMap (java.util.HashMap))
;opposites
(compare1Ops:put "!=0" 153)
(compare1Ops:put "==0" 154)
(compare1Ops:put ">=0" 155)
(compare1Ops:put "<0" 156)
(compare1Ops:put "<=0" 157)
(compare1Ops:put ">0" 158)
(compare1Ops:put "!=null" 198)
(compare1Ops:put "==null" 199)

(define compareOpposites ::java.util.HashMap (java.util.HashMap))
(compareOpposites:put 153 154)
(compareOpposites:put 154 153)
(compareOpposites:put 155 156)
(compareOpposites:put 156 155)
(compareOpposites:put 157 158)
(compareOpposites:put 158 157)
(compareOpposites:put 198 199)
(compareOpposites:put 199 198)

(define-simple-class Classes ()
	(locals ::java.util.HashMap)
	(imports ::java.util.HashMap)
	(starImports ::java.util.ArrayList)
	((*init* locals0)
		(set! locals locals0)
		(set! imports (java.util.HashMap))
		(set! starImports (java.util.ArrayList))
		(starImports:add "java.lang.")
	)
	((get name ::String) ::Type
		(define i 0)
		(define dims -1)
		(do ()
			((= i -1))
			(set! i (name:indexOf "[]" (+ i 1)))
			(set! dims (+ dims 1))
		)
		(set! name (name:replace "[" ""))
		(set! name (name:replace "]" ""))
		(define type ::Type
			(if (constTypes:containsKey name)
				(constTypes:get name)
			(if (locals:containsKey name)
				(locals:get name)
			(if (imports:containsKey name)
				(imports:get name)
			(if (classExists name)
				(Type:getType name)
			(begin
				(define type ::Type #!null)
				(do ((i 0 (+ i 1)))
					((or (not (eq? type #!null)) (= i (starImports:size))))
					(if (classExists (string-append (starImports:get i) name))
						(set! type (Type:getType (string-append (starImports:get i) name)))
					)
				)
				type
			)
			)
			)
			)
			)
		)
		(do ((i 0 (+ i 1)))
			((= i dims))
			(set! type (ArrayType type))
		)
		type
	)
	((get tok ::Token) ::Type
		(if (tok:what:equals "generic")
			(begin
				(define c ::ClassType ((this):get (as String (as Token (tok:ops:get 0)):val)))
				(define params ::Token (tok:ops:get 1))
				(define tparams ::Type[] (Type[] length:(params:ops:size)))
				(do ((i 0 (+ i 1)))
					((= i (params:ops:size)))
					(set! (tparams i) ((this):get (as Token (params:ops:get i))))
				)
				(ParameterizedType c tparams)
			)
			((this):get (as String tok:val))
		)
	)
)

(define (resolveParam pt ::Type t ::Type) ::Type
	(if (and (instance? t TypeVariable) (instance? pt ParameterizedType))
		(begin
			(define tvs ::TypeVariable[] (*:getTypeParameters ((as ParameterizedType pt):getRawType)))
			(define s ::String ((as TypeVariable t):getName))
			(define end #f)
			(define ret ::Type #!null)
			(do ((i 0 (+ i 1)))
				((or end (= i (length tvs))))
				(if (((tvs i):getName):equals s)
					(begin
						(set! ret ((as ParameterizedType pt):getTypeArgumentType i))
						(set! end #t)
					)
				)
			)
			ret
		)
		(t:getRawType)
	)
)

(define-simple-class MFilter (gnu.bytecode.Filter)
	(methods0 ::java.util.ArrayList)
	(methods1 ::java.util.ArrayList)
	(name ::java.lang.String)
	(types ::Type[])
	(pt ::Type)
	((*init* name0 ::java.lang.String types0 ::Type[] pt0 ::Type)
		(set! methods0 (java.util.ArrayList))
		(set! methods1 (java.util.ArrayList))
		(set! name name0)
		(set! types types0)
		(set! pt pt0)
	)
	((select v ::java.lang.Object) ::boolean
		(define method ::Method v)
		(if ((method:getName):equals name)
			(if (= (length (method:getParameterTypes)) (length types))
				(begin
					(define stop #f)
					(define minLevel 1)
					(do ((i 0 (+ i 1)))
						((or stop (= i (length types))))
						(define level ((resolveParam pt ((method:getParameterTypes) i)):compare (types i)))
						(if (< level minLevel)
							(set! minLevel level)
						)
						(if (< level 0)
							(set! stop #t)
						)
					)
					(if (not stop)
						(if (= minLevel 1)
							(methods1:add method)
							(methods0:add method)
						)
					)
				)
			)
		)
		#f
	)
)

(define unknownType #!null)

(define-simple-class Compiler ()
	((isCompare s)
		(or (s:equals "!") (s:equals "&&") (s:equals "||") (compare1Ops:containsKey s) (compare2Ops:containsKey s))
	)
	((compile_types classes ::Classes newClasses ::java.util.ArrayList tok ::Token)
		(if (and (tok:what:equals "(") (> (length tok:ops) 0))
			(begin
				(define first ::Token (as Token (tok:ops:get 0)))
				(if (first:val:equals "define-class")
					(begin
						(define name (as Token (tok:ops:get 1)):val)
						(define c ::ClassType (ClassType name))
						(define supers (as Token (tok:ops:get 2)):ops)
						(*:setSuper c "java.lang.Object")
						(do ((i 0 (+ i 1)))
							((= i (length supers)))
							(define related ::ClassType (classes:get (as Token (supers:get i))))
							(if (*:isInterface related)
								(*:addInterface c related)
								(*:setSuper c related)
							)
						)
						(newClasses:add c)
						(classes:locals:put name c)
						(do ((i 3 (+ i 1)))
							((= i (length tok:ops)))
							(compile_method_mods (tok:ops:get i) c)
						)
						(set! tok:val c)
						#!null
					)
				(if (first:val:equals "import")
					(begin
						(define import ::String (as Token (tok:ops:get 1)):val)
						(if (import:contains "*")
							(classes:starImports:add (import:replace "*" ""))
							(classes:imports:put (import:substring (+ (import:lastIndexOf ".") 1)) (Type:getType import))
						)
					)
				)
				)
			)
		)
	)
	((compile_method_mods tok ::Token c ::ClassType)
		(if (tok:what:equals "'")
			(begin
				(define nmod (accessModifiers:get (as Token (tok:ops:get 0)):val))
				(*:setModifiers c nmod)
			)
		)
	)
	((compile_method_defs classes ::Classes tok ::Token)
		(if (and (tok:what:equals "(") (> (length tok:ops) 0))
			(begin
				(define first ::Token (as Token (tok:ops:get 0)))
				(if (first:val:equals "define-class")
					(begin
						(do ((i 3 (+ i 1)))
							((= i (length tok:ops)))
							(compile_method_def classes (tok:ops:get i) (as ClassType tok:val))
						)
						#!null
					)
				)
			)
		)
	)
	((compile_method_def classes ::Classes tok ::Token c ::ClassType)
		(if (and (tok:what:equals "(") (> (length tok:ops) 0))
			(begin
				(define first ::Token (as Token (tok:ops:get 0)))
				(if (first:what:equals "(") ;method definition
					(begin
						(define scope ::java.util.HashMap (java.util.HashMap))
						(define mods ::int 0)
						(define end #f)
						(define i 2)
						(do ()
							((or end (= i (tok:ops:size))))
							(define mod ::Token (tok:ops:get i))
							(if (mod:what:equals "'")
								(begin
									(set! mods (logior mods (accessModifiers:get (as Token (mod:ops:get 0)):val)))
									(set! i (+ i 1))
								)
								(set! end #t)
							)
						)
						(define n 0)
						(if (= (logand mods Access:STATIC) 0)
							(begin
								(scope:put "this" (Arg 0 c))
								(set! n 1)
							)
						)
						(define l (length first:ops))
						(define types ::Type[] (Type[] length: (/ (- l 1) 2)))
						(do ((i 0 (+ i 1)))
							((= i (length types)))
							(define type ::Type (classes:get (as Token (first:ops:get (+ (* i 2) 2)))))
							(set! (types i) type)
							(scope:put (as Token (first:ops:get (+ (* i 2) 1))):val (Arg (+ n i) type))
						)
						(define m ::Method (*:addMethod c (as Token (first:ops:get 0)):val types (classes:get (as Token (tok:ops:get 1))) mods))
						(tok:ops:set 0 (Token 0 "(" #!null -1 (java.util.ArrayList (tok:ops:subList i (tok:ops:size)))))
						(shiftDown tok:ops 1 (- (tok:ops:size) 1))
						(set! tok:val (MethodInfo m scope))
					)
					(begin ;field definition
						(define mods ::int 0)
						(define end #f)
						(do ((i 2 (+ i 1)))
							((or (= i (length tok:ops)) end))
							(define mod ::Token (tok:ops:get i))
							(if (mod:what:equals "'")
								(begin
									(define nmod (accessModifiers:get (as Token (mod:ops:get 0)):val))
									(set! mods (logior mods nmod))
								)
								(set! end #t)
							)
						)
						(*:addField c first:val (classes:get (as Token (tok:ops:get 1))) mods)
					)
				)
			)
		)
	)
	((compile_al classes ::Classes toks ::java.util.ArrayList i e c ::ClassType mi ::MethodInfo code ::CodeAttr needed) ::Type[]
		(define l (toks:size))
		(define types (Type[] length: (- e i)))
		(do ((j i (+ j 1)))
			((>= j e))
			(set! (types (- j i)) (compile_ classes (toks:get j) c mi code (if (eq? needed #!null) #!null (if (instance? needed Type[]) (needed (- j i)) needed))))
		)
		types
	)
	((compile_root classes ::Classes tok ::Token)
		(if (and (tok:what:equals "(") (> (length tok:ops) 0))
			(begin
				(define first ::Token (tok:ops:get 0))
				(if (first:val:equals "define-class")
					(compile_class classes tok)
				)
			)
		)
	)
	((invertComp inv n)
		(if inv
			(compareOpposites:get n)
			n
		)
	)
	((compile_class classes ::Classes tok ::Token)
		(do ((i 3 (+ i 1)))
			((= i (length tok:ops)))
			(compile_method classes (tok:ops:get i) tok:val)
		)
	)
	((compile_method classes ::Classes tok ::Token c ::ClassType)
		(if (instance? tok:val MethodInfo)
			(begin ;method definition
				(define mi ::MethodInfo (as MethodInfo tok:val))
				(if (not (mi:method:isAbstract))
					(compile_method_body mi classes (tok:ops:get 0) c)
				)
			)
		)
	)
	((compile_method_body mi ::MethodInfo classes ::Classes tok ::Token c ::ClassType)
		(compile_labels tok 0)
		(mi:pushScope #!null tok:val)
		(compile_al classes tok:ops 0 (- (length tok:ops) 1) c mi #!null Type:voidType)
		(compile_ classes (tok:ops:get (- (length tok:ops) 1)) c mi #!null (mi:method:getReturnType))
		(mi:popScope #!null)
		(define code ::CodeAttr (mi:method:startCode))
		(mi:pushScope code tok:val)
		(compile_al classes tok:ops 0 (- (length tok:ops) 1) c mi code Type:voidType)
		(compile_ classes (tok:ops:get (- (length tok:ops) 1)) c mi code (mi:method:getReturnType))
		(mi:popScope code)
		(code:emitReturn)
	)
	((compile_labels block ::Token i)
		(define hm ::java.util.HashMap (java.util.HashMap))
		(set! block:val hm)
		(do ((i i (+ i 1)))
			((= i (block:ops:size)))
			(define tok ::Token (block:ops:get i))
			(if (tok:what:equals "(")
				(if (and (> (tok:ops:size) 0) ((as Token (tok:ops:get 0)):val:equals "label"))
					(hm:put (as Token (tok:ops:get 1)):val (Label))
					(compile_labels tok 0)
				)
			)
		)
	)
	;tok = condition
	((emitIf_ classes ::Classes inv tok ::Token i compare true ::Emitter false ::Emitter c ::ClassType mi ::MethodInfo code ::CodeAttr needed ::Type) ::Type
		(define output (not (eq? code #!null)))
		(if (compare:equals "!")
			(begin
				(emitIf classes (not inv) tok i true false c mi code needed)
			)
		(if (or (and (not inv) (compare:equals "&&")) (and inv (compare:equals "||")))
			(begin
				(define skipL ::Label (Label))
				(define falseL ::Label (Label))
				(define falseTok ::Emitter (Goto falseL))
				(do ((i 1 (+ i 1)))
					((= i (- (tok:ops:size) 1)))
					(emitIf classes (not inv) tok i falseTok #!null c mi code needed)
				)
				(emitIf classes (not inv) tok (- (tok:ops:size) 1) falseTok #!null c mi code needed)
				(define type (true:emit (this) classes c mi code needed))
				(if output (code:emitGoto skipL))
				(if output (falseL:define code))
				(if (not (eq? false #!null))
					(begin
						(false:emit (this) classes c mi code needed)
					)
				)
				(if output (skipL:define code))
				type
			)
		(if (or (and (not inv) (compare:equals "||")) (and inv (compare:equals "&&")))
			(begin
				(define skipL ::Label (Label))
				(define trueL ::Label (Label))
				(define trueTok ::Emitter (Goto trueL))
				(do ((i 1 (+ i 1)))
					((= i (- (tok:ops:size) 1)))
					(emitIf classes inv tok i trueTok #!null c mi code needed)
				)
				(emitIf classes inv tok (- (tok:ops:size) 1) trueTok #!null c mi code needed)
				(if (not (eq? false #!null))
					(begin
						(false:emit (this) classes c mi code needed)
					)
				)
				(if output (code:emitGoto skipL))
				(if output (trueL:define code))
				(define type ::Type (true:emit (this) classes c mi code needed))
				(if output (skipL:define code))
				type
			)
			(begin
				(define skip ::Label (Label))
				(if (compare1Ops:containsKey compare)
					(begin
						(compile_ classes (tok:ops:get i) c mi code unknownType)
						(if output (code:emitGotoIfCompare1 skip (invertComp inv (compare1Ops:get compare))))
					)
					(begin
						(compile_ classes (tok:ops:get i) c mi code unknownType)
						(compile_ classes (tok:ops:get (+ i 1)) c mi code unknownType)
						(if output (code:emitGotoIfCompare2 skip (invertComp inv (compare2Ops:get compare))))
					)
				)
				;(code:emitIf)
				(define type ::Type (true:emit (this) classes c mi code needed))
				(define end ::Label (Label))
				(if (not (eq? false #!null))
					(if output (code:emitGoto end))
				)
				(if output (skip:define code))
				(if (not (eq? false #!null))
					(begin
						;(code:emitElse)
						(false:emit (this) classes c mi code needed)
						(if output (end:define code))
					)
				)
				;(code:emitFi)
				type
			)
		)
		)
		)
	)
	((emitIf classes ::Classes inv tok ::Token i true ::Emitter false ::Emitter c ::ClassType mi ::MethodInfo code ::CodeAttr needed ::Type) ::Type
		(define cond ::Token (tok:ops:get i))
		(if (and (cond:what:equals "(") (isCompare (as Token (cond:ops:get 0)):val))
			(emitIf_ classes inv cond 1 (as Token (cond:ops:get 0)):val true false c mi code needed)
			(emitIf_ classes inv tok i "!=0" true false c mi code needed)
		)
	)
	((emitInvoke name type ::Type classes ::Classes tok ::Token c ::ClassType mi ::MethodInfo code ::CodeAttr needed ::Type) ::Type
		(define output (not (eq? code #!null)))
		(define types (compile_al classes tok:ops 1 (length tok:ops) c mi #!null unknownType))
		;(println tok:line type name types output)
		(if (name:equals "<super>") (begin (if output (code:emitPushThis)) (set! name "<init>")))
		(define filter ::MFilter (MFilter name types type))
		(*:getMethods (as ObjectType (type:getRawType)) filter 2 #!null)
		(define method ::Method
			(if (> (length filter:methods0) 0)
				(filter:methods0:get 0)
				(filter:methods1:get 0)
			)
		)
		(define params ::Type[] (java.util.Arrays:copyOf (method:getParameterTypes) (length (method:getParameterTypes))))
		(do ((i 0 (+ i 1)))
			((= i (length params)))
			(set! (params i) (resolveParam type (params i)))
		)
		(compile_al classes tok:ops 1 (length tok:ops) c mi code params)
		(if output (code:emitInvoke method))
		(define out ::Type (resolveParam type (method:getReturnType)))
		(if (not (Type:isSame out ((method:getReturnType):getRawType)))
			(if output (code:emitCheckcast (out:getRawType)))
		)
		out
	)
	((compile_ classes ::Classes tok ::Token c ::ClassType mi ::MethodInfo code ::CodeAttr needed ::Type) ::Type
		(define output (not (eq? code #!null)))
		(if output (code:putLineNumber "abc.java" tok:line))
		;(println tok:line);code output tok needed)
		(define result ::Type
			(if (tok:what:equals "S")
				(begin
					(if output (code:emitPushString tok:val))
					Type:javalangStringType
				)
			(if (tok:what:equals "C")
				(begin
					(if (not (instance? needed PrimType))
						(begin
							(if output (code:emitPushInt ((as gnu.text.Char tok:val):intValue)))
							Type:charType
						)
						(begin
							(if output (code:emitPushConstant tok:val needed))
							needed
						)
					)
				)
			(if (tok:what:equals "N")
				(begin
					(if ((as String tok:val):contains ".")
						(begin
							(if output (code:emitPushDouble (java.lang.Double:parseDouble tok:val)))
							Type:doubleType
						)
						(begin
							(if (not (instance? needed PrimType))
								(begin
									(if output (code:emitPushInt (java.lang.Integer:parseInt tok:val)))
									Type:intType
								)
								(begin
									(if output (code:emitPushConstant (java.lang.Integer:parseInt tok:val) needed))
									needed
								)
							)
						)
					)
				)
			(if (tok:what:equals ":")
				(begin
					(define first ::Token (tok:ops:get 0))
					(define class ::ClassType (compile_ classes first c mi code unknownType))
					(define field ::Field (*:getField class (as Token (tok:ops:get 1)):val -1))
					(if (field:getStaticFlag)
						(if output (code:emitGetStatic field))
						(if output (code:emitGetField field))
					)
					(field:getType)
				)
			(if (tok:what:equals "V")
				(if (tok:val:equals "false")
					(begin
						(if output (code:emitPushInt 0))
						Type:booleanType
					)
				(if (tok:val:equals "true")
					(begin
						(if output (code:emitPushInt 1))
						Type:booleanType
					)
				(if (tok:val:equals "null")
					;(if (eq? needed unknownType)
						(begin
							(if output (code:emitPushNull))
							Type:nullType
						)
					;	(begin
					;		(println needed)
					;		(if output (code:emitPushNull needed))
					;		needed
					;	)
					;)
					(begin
						(define class ::ClassType (classes:get tok))
						(if (eq? class #!null)
							(begin
								(define found ::AVar (mi:getVar tok:val))
								(if output (found:load code))
								found:type
							)
							class
						)
					)
				)
				)
				)
			(if (and (tok:what:equals "(") (> (length tok:ops) 0))
				(begin
					(define first ::Token (as Token (tok:ops:get 0)))
					(if (first:val:equals "begin")
						(begin
							(mi:pushScope code tok:val)
							(compile_al classes tok:ops 1 (- (length tok:ops) 1) c mi code Type:voidType)
							(define type ::Type (compile_ classes (tok:ops:get (- (length tok:ops) 1)) c mi code needed))
							(mi:popScope code)
							type
						)
					(if (first:val:equals "label")
						(begin
							(define label ::Label (mi:getLabel (as Token (tok:ops:get 1)):val))
							(if output (label:define code))
							Type:voidType
						)
					(if (first:val:equals "goto")
						(begin
							(define label ::Label (mi:getLabel (as Token (tok:ops:get 1)):val))
							(if output (code:emitGoto label))
							Type:voidType
						)
					(if (first:val:equals "define")
						(begin
							(define type ::Type
								(if (= (length tok:ops) 4)
									(begin
										(define type ::Type (classes:get (as Token (tok:ops:get 2))))
										(compile_ classes (tok:ops:get 3) c mi code type)
										type
									)
									(compile_ classes (tok:ops:get 2) c mi code unknownType)
								)
							)
							(define name (as Token (tok:ops:get 1)):val)
							(define var ::Variable (if output (code:addLocal type name) #!null))
							(if output (code:emitStore var))
							((as java.util.HashMap (mi:scopes:getFirst)):put name (Var var type))
							Type:voidType
						)
					(if (first:val:equals "try")
						(begin
							(if output (code:emitTryStart #f #!null))
							(define type ::Type (compile_ classes (tok:ops:get 1) c mi code needed))
							(if output (code:emitCatchStart Type:javalangThrowableType))
							(if output (code:emitPop 1))
							(compile_ classes (tok:ops:get 2) c mi code needed)
							(if output (code:emitCatchEnd))
							(if output (code:emitTryCatchEnd))
							type
						)
					(if (first:val:equals "instance?")
						(begin
							(compile_ classes (tok:ops:get 1) c mi code unknownType)
							(if output (code:emitInstanceof (classes:get (as Token (tok:ops:get 2)))))
							Type:booleanType
						)
					(if (first:val:equals "set")
						(begin
							(define out ::Token (as Token (tok:ops:get 1)))
							(if (out:what:equals ":")
								(begin
									(define first ::Token (out:ops:get 0))
									(define class ::ClassType (compile_ classes first c mi code unknownType))
									(define field ::Field (*:getField class (as Token (out:ops:get 1)):val -1))
									(compile_ classes (tok:ops:get 2) c mi code (field:getType))
									(if (field:getStaticFlag)
										(if output (code:emitPutStatic field))
										(if output (code:emitPutField field))
									)
								)
								(begin
									(define var ::AVar (mi:getVar out:val))
									(compile_ classes (tok:ops:get 2) c mi code var:type)
									(if output (var:store code))
								)
							)
							Type:voidType
						)
					(if (first:val:equals "aset")
						(begin
							(define type ::ArrayType (compile_ classes (tok:ops:get 1) c mi code unknownType))
							(compile_ classes (tok:ops:get 2) c mi code unknownType)
							(compile_ classes (tok:ops:get 3) c mi code type:elements)
							(if output (code:emitArrayStore))
							Type:voidType
						)
					(if (first:val:equals "aget")
						(begin
							(define type ::ArrayType (compile_ classes (tok:ops:get 1) c mi code unknownType))
							(compile_ classes (tok:ops:get 2) c mi code Type:intType)
							(if output (code:emitArrayLoad))
							type:elements
						)
					(if (first:val:equals "alen")
						(begin
							(compile_ classes (tok:ops:get 1) c mi code unknownType)
							(if output (code:emitArrayLength))
							Type:intType
						)
					(if (first:val:equals "as")
						(begin
							(define cast ::Type (classes:get (as Token (tok:ops:get 1))))
							(define out ::Type (compile_ classes (tok:ops:get 2) c mi code (cast:getRawType)))
							(if (instance? cast ParameterizedType)
								cast
								out
							)
						)
					(if (first:val:equals "if")
						(begin
							(emitIf classes #f tok 1 (TokenEmitter (tok:ops:get 2)) (if (= (tok:ops:size) 4) (TokenEmitter (tok:ops:get 3)) #!null) c mi code needed)
						)
					(if (first:val:equals "while")
						(begin
							(define start ::Label (Label))
							(mi:pushScope code tok:val)
							(if output (start:define code))
							(define t (emitIf classes #f tok 1 (Emitters (Emitter[] (TokensEmitter tok:ops 2 (length tok:ops)) (Goto start))) #!null c mi code needed))
							(mi:popScope code)
							t
						)
					(if (isCompare first:val)
						(begin
							(emitIf_ classes #f tok 1 first:val (TokenEmitter (Token tok:line "V" "true")) (TokenEmitter (Token tok:line "V" "false")) c mi code Type:booleanType)
						)
					(if (binOps:containsKey first:val)
						(begin
							(define types ::java.util.List (java.util.Arrays:asList (compile_al classes tok:ops 1 (tok:ops:size) c mi #!null unknownType)))
							(define otype ::Type Type:voidType)
							(if (types:contains Type:doubleType)
								(set! otype Type:doubleType)
							(if (types:contains Type:longType)
								(set! otype Type:longType)
								(set! otype Type:intType)
							)
							)
							(compile_ classes (tok:ops:get 1) c mi code otype)
							(do ((i 2 (+ i 1)))
								((= i (tok:ops:size)))
								(compile_ classes (tok:ops:get i) c mi code otype)
								(if output (code:emitBinop (binOps:get first:val) otype))
							)
							otype
						)
						(begin
							(define first ::Token (tok:ops:get 0))
							(if (first:what:equals ":")
								(begin ;method call
									(define name (as Token (first:ops:get 1)):val)
									(emitInvoke name (compile_ classes (first:ops:get 0) c mi code unknownType) classes tok c mi code unknownType)
								)
								(begin ;constructor
									(define type ::Type (classes:get first))
									(if (instance? type ArrayType)
										(begin
											(define array ::ArrayType type)
											(define len ::Token (if (> (tok:ops:size) 1) (tok:ops:get 1) #!null))
											(define i0
												(if (and (not (eq? len #!null)) (len:what:equals ":") ((as Token (len:ops:get 0)):val:equals "len"))
													(begin (compile_ classes (len:ops:get 1) c mi code unknownType) 2)
													(begin (if output (code:emitPushInt (- (tok:ops:size) 1))) 1)
												)
											)
											(if output (code:emitNewArray array:elements))
											(do ((i i0 (+ i 1)))
												((= i (tok:ops:size)))
												(if output (code:emitDup))
												(if output (code:emitPushInt (- i i0)))
												(compile_ classes (tok:ops:get i) c mi code array:elements)
												(if output (code:emitArrayStore))
											)
											type
										)
										(begin
											(define class ::ClassType (type:getRawType))
											(if output (code:emitNew class))
											(if output (code:emitDup))
											(emitInvoke "<init>" type classes tok c mi code unknownType)
											type
										)
									)
								)
							)
						)
					)
					)
					)
					)
					)
					)
					)
					)
					)
					)
					)
					)
					)
					)
					)
				)
				Type:voidType
			)
			)
			)
			)
			)
			)
		)
		(if (eq? needed unknownType)
			result
		(if (eq? needed Type:voidType)
			(begin
				(if (not (eq? result Type:voidType))
					(if output (code:emitPop 1))
				)
				Type:voidType
			)
		(if (not (Type:isSame needed result))
			(begin
				(if (instance? result PrimType)
					(begin
						(if (instance? needed ClassType)
							(if output (code:emitInvoke (*:getMethod ((as PrimType result):boxedType) "valueOf" (Type[] result))))
							(if output (code:emitConvert result needed))
						)
					)
				(if (instance? needed PrimType)
					(begin
						(define unbox ::Method (unboxMethods:get result))
						(if output (code:emitInvoke unbox))
						(if output (code:emitConvert (as PrimType (unbox:getReturnType)) (as PrimType needed)))

					)
					(if output (code:emitCheckcast needed))
				)
				)
				needed
			)
			result
		)
		)
		)
	)
	((compile toks ::java.util.ArrayList locals ::java.util.HashMap)
		(define classes ::Classes (Classes locals))
		(define newClasses ::java.util.ArrayList (java.util.ArrayList))
		(for-each
			(lambda (tok ::Token)
				((this):compile_types classes newClasses tok)
			)
			toks
		)

		(for-each
			(lambda (tok ::Token)
				((this):compile_method_defs classes tok)
			)
			toks
		)

		(for-each
			(lambda (tok ::Token)
				((this):compile_root classes tok)
			)
			toks
		)

		(define cl ::ArrayClassLoader (ArrayClassLoader))

		(define argTypes ::Class[] (Class[] String[]:class))
		(define main ::java.lang.reflect.Method #!null)

		((java.io.File "out"):mkdir)

		(for-each
			(lambda (class ::ClassType)
				(define classFile :: byte[] (*:writeToArray class))
				(cl:addClass (*:getSimpleName class) classFile)
				(java.nio.file.Files:write (java.nio.file.Paths:get (string-append "out/" (*:getSimpleName class) ".class")) classFile)
			)
			newClasses
		)

		;(for-each
		;	(lambda (class ::ClassType)
		;		(println (*:getSimpleName class))
		;		;(ClassTypeWriter:print class System:out 0)
		;		(try-catch
		;			(set! main (*:getMethod (cl:loadClass (*:getSimpleName class) #t) "main" argTypes))
		;			(e java.lang.Exception ())
		;		)
		;	)
		;	newClasses
		;)

		;(if (not (eq? main #!null))
		;	(*:invoke
		;		main
		;		#!null
		;		(Object[] (String[]))
		;	)
		;)
	)
)

(define (gen_ tok ::Token c sb ::java.lang.StringBuilder)
	(sb:append (string-append (number->string c) " [label=\"" (org.apache.commons.lang3.StringEscapeUtils:escapeJava (org.apache.commons.lang3.StringEscapeUtils:escapeJava (tok:repr))) "\"]\n"))
	(if (not (eq? tok:ops #!null))
		(begin
			(define oc c)
			(for-each
				(lambda (o)
					(sb:append (string-append (number->string oc) " -> " (number->string (+ c 1)) "\n"))
					(set! c (gen_ o (+ c 1) sb))
				)
				tok:ops
			)
		)
	)
	c
)

(define (gen toks) ::String
	(define sb ::java.lang.StringBuilder (java.lang.StringBuilder))
	(sb:append "digraph name {\n")
	(define c 0)
	(for-each
		(lambda (tok)
			(set! c (+ (gen_ tok c sb) 1))
		)
		toks
	)
	(sb:append "}")
	(sb:toString)
)

(define toks ::java.util.ArrayList ((Lexer (String (java.nio.file.Files:readAllBytes (java.nio.file.Paths:get (as java.lang.String (command-line-arguments 0)))))):lex))
((Parser toks):parse 0 (length toks) MP 0)
;(java.nio.file.Files:write (java.nio.file.Paths:get "test.dot") ((gen toks):getBytes))
;((java.lang.Runtime:getRuntime):exec "dot -Tsvg test.dot -otest.svg")
((Compiler):compile toks (java.util.HashMap))
