(package examples.tictactoe)

(import java.util.*)
(import javafx.application.*)
(import javafx.stage.*)
(import javafx.scene.*)
(import javafx.scene.canvas.*)
(import javafx.scene.input.*)
(import javafx.scene.text.*)
(import javafx.scene.paint.*)
(import javafx.animation.*)
(import javafx.event.*)

(define-class Main () public
	((main args String[]) void public static
		(set App:userPlayer 1)
		(Application:launch (class App))
	)
)

(define-class App (Application) public
	(gc GraphicsContext static)
	(mouseX int static)
	(mouseY int static)
	(board int[][] static)
	(wh int static)
	(cell int static)
	(turn int static)
	(userPlayer int static)
	(win bool static)
	(turns int static)
	((<init>) void public
		(super:<init>)
	)
	((start stage Stage) void
		(App:reset)
		(set App:wh 512)
		(set App:cell (/ App:wh 3))
		(stage:setTitle "Tic Tac Toe")
		(stage:setResizable false)
		(define root (Group))
		(define canvas (Canvas App:wh App:wh))
		((root:getChildren):add canvas)
		(set App:gc (canvas:getGraphicsContext2D))
		(define scene (Scene root))
		(stage:setScene scene)
		(stage:sizeToScene)
		(
			(object (AnimationTimer)
				((handle currentTime long) void
					(App:gc:clearRect 0 0 App:wh App:wh)
					(App:gc:setStroke Color:BLACK)

					(App:gc:setLineWidth 1)
					(App:gc:strokeLine App:cell 0 App:cell App:wh)
					(App:gc:strokeLine (* 2 App:cell) 0 (* 2 App:cell) App:wh)
					(App:gc:strokeLine 0 App:cell App:wh App:cell)
					(App:gc:strokeLine 0 (* 2 App:cell) App:wh (* 2 App:cell))

					(for ((x 0)) (< x 3) (inc x)
						(for ((y 0)) (< y 3) (inc y)
							(App:draw x y (aget App:board x y))
						)
					)

					(App:gc:setStroke Color:GREENYELLOW)
					(if (&& (! App:win) (< App:mouseX 3) (< App:mouseY 3) (= (aget App:board App:mouseX App:mouseY) 0))
						(App:draw App:mouseX App:mouseY App:turn)
					)
				)
			):start
		)
		(scene:setOnKeyPressed
			(lambda EventHandler{KeyEvent} (event)
				(if (= (event:getCode) KeyCode:ESCAPE)
					(stage:close)
				)
			)
		)
		(scene:setOnMouseMoved
			(lambda EventHandler{MouseEvent} (event)
				(set App:mouseX (/ (event:getX) App:cell))
				(set App:mouseY (/ (event:getY) App:cell))
			)
		)
		(scene:setOnMouseClicked
			(lambda EventHandler{MouseEvent} (event)
				(if App:win
					(App:reset)
					(if (= (aget App:board App:mouseX App:mouseY) 0)
						(begin
							(App:play App:mouseX App:mouseY)
							(App:bestMove)
							(define n (App:check))
							(if (!= n 0)
								(begin
									(println (if (= n 1) "X" "O") " won! Click to start a new game.")
									(set App:win true)
								)
							)
							(if (= App:turns 9)
								(begin
									(println "Tie! Click to start a new game.")
									(set App:win true)
								)
							)
						)
					)
				)
			)
		)
		(stage:show)
	)
	((draw cx int cy int w int) void static
		(App:gc:setLineWidth 10)
		(define hcell (/ App:cell 2))
		(define ox (+ (* cx App:cell) hcell))
		(define oy (+ (* cy App:cell) hcell))
		(define off (- hcell 30))
		(if (= w 1)
			(begin
				(App:gc:strokeLine (- ox off) (- oy off) (+ ox off) (+ oy off))
				(App:gc:strokeLine (+ ox off) (- oy off) (- ox off) (+ oy off))
			)
		)
		(if (= w 2)
			(App:gc:strokeOval (- ox off) (- oy off) (* off 2) (* off 2))
		)
	)
	((good a int b int c int) bool static
		(&& (!= a 0) (= a b c))
	)
	((check) int static
		(cond
			((App:good (aget App:board 0 0) (aget App:board 0 1) (aget App:board 0 2))
				(aget App:board 0 0)
			)
			((App:good (aget App:board 1 0) (aget App:board 1 1) (aget App:board 1 2))
				(aget App:board 1 0)
			)
			((App:good (aget App:board 2 0) (aget App:board 2 1) (aget App:board 2 2))
				(aget App:board 2 0)
			)
			((App:good (aget App:board 0 0) (aget App:board 1 0) (aget App:board 2 0))
				(aget App:board 0 0)
			)
			((App:good (aget App:board 0 1) (aget App:board 1 1) (aget App:board 2 1))
				(aget App:board 0 1)
			)
			((App:good (aget App:board 0 2) (aget App:board 1 2) (aget App:board 2 2))
				(aget App:board 0 2)
			)
			((App:good (aget App:board 0 0) (aget App:board 1 1) (aget App:board 2 2))
				(aget App:board 0 0)
			)
			((App:good (aget App:board 2 0) (aget App:board 1 1) (aget App:board 0 2))
				(aget App:board 2 0)
			)
			(true 0)
		)
	)
	((minimax player int depth int a int b int) int static
		(define n (App:check))
		(define max (= player App:turn))
		(cond
			((= n App:turn)
				depth
			)
			((!= n 0)
				(- depth)
			)
			(max
				(define best -9999)
				(for ((x 0)) (< x 3) (inc x)
					(for ((y 0)) (< y 3) (inc y)
						(if (= (aget App:board x y) 0)
							(begin
								(aset App:board x y player)
								(set best (Math:max best (App:minimax (if (= player 1) 2 1) (- depth 1) a b)))
								(aset App:board x y 0)
								(set a (Math:max a best))
								(if (<= b a) (goto ret))
							)
						)
					)
				)
				(label ret)
				(if (= best -9999) 0 best)
			)
			(true
				(define best 9999)
				(for ((x 0)) (< x 3) (inc x)
					(for ((y 0)) (< y 3) (inc y)
						(if (= (aget App:board x y) 0)
							(begin
								(aset App:board x y player)
								(set best (Math:min best (App:minimax (if (= player 1) 2 1) (- depth 1) a b)))
								(aset App:board x y 0)
								(set b (Math:min b best))
								(if (<= b a) (goto ret))
							)
						)
					)
				)
				(label ret)
				(if (= best 9999) 0 best)
			)
		)
	)
	((bestMove) void static
		(define best -9999)
		(define bx 0)
		(define by 0)
		(for ((x 0)) (< x 3) (inc x)
			(for ((y 0)) (< y 3) (inc y)
				(if (= (aget App:board x y) 0)
					(begin
						(aset App:board x y App:turn)
						(define n (App:minimax (if (= App:turn 1) 2 1) 10 -9999 9999))
						(if (> n best)
							(begin
								(set best n)
								(set bx x)
								(set by y)
							)
						)
						(aset App:board x y 0)
					)
				)
			)
		)
		(if (!= App:turns 9)
			(App:play bx by)
		)
	)
	((reset) void static
		(set App:win false)
		(set App:board (int[][] (int[] 0 0 0) (int[] 0 0 0) (int[] 0 0 0)))
		(set App:turn 1)
		(set App:turns 0)
		(if (= App:userPlayer 2)
			(App:bestMove)
		)
	)
	((play x int y int) void static
		(aset App:board x y App:turn)
		(set App:turn (if (= App:turn 1) 2 1))
		(inc App:turns)
	)
)
