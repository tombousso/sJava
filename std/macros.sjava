(import gnu.bytecode.*)
(import java.util.*)
(import %tokens%)

;(define-macro (while cond @block)
;	`(begin
;		(label start)
;		(if ,cond (begin ,block (goto start)))
;	)
;)
(define-macro (inc v n)
	`(set ,v (+ ,v ,n))
)
(define-macro (inc v)
	`(inc ,v 1)
)
(define-macro (dec v n)
	`(set ,v (- ,v ,n))
)
(define-macro (dec v)
	`(dec ,v 1)
)
(define-macro (forEachI item iterable index @block)
	(if (instance? (type iterable) ArrayType)
		`(begin
			(define array ,iterable)
			(define ,index 0)
			(while (!= ,index (alen array))
				(define ,item (aget array ,index))
				,block
				(inc ,index)
			)
		)
		`(begin
			(define iterable ,iterable)
			(define it (iterable:iterator))
			(define ,index 0)
			(while (it:hasNext)
				(define ,item (it:next))
				,block
				(inc ,index)
			)
		)
	)
)
(define-macro (forEach item iterable @block)
	`(forEachI ,item ,iterable notused ,block)
)
(define-macro (print @objects)
	`(System:out:print (concat ,objects))
)
(define-macro (println @objects)
	`(System:out:println (concat ,objects))
)
(define-macro (mapAI item collection i @block)
	(define t (type collection))
	(define itemT
		(if (instance? t ArrayType)
			((as ArrayType t):getComponentType)
			(type
				`(begin
					(define collection ,collection)
					((collection:iterator):next)
				)
			)
		)
	)
	(define len
		(if (instance? t ArrayType)
			`(alen collection)
			`(collection:size)
		)
	)
	(define o (type `(begin (define ,item ,(itemT:getName)) (define ,i int) ,block)))
	`(begin
		(define collection ,collection)
		(define out (,((o:getName):concat "[]") len:,len))
		(forEachI ,item collection ,i (aset out ,i ,block))
		out
	)
)
(define-macro (mapA item iterable @block)
	`(mapAI ,item ,iterable i ,block)
)
(define-macro (concat @objects)
	(define appends
		(mapA o objects
			(if (instance? (type o) ArrayType)
				`(sb:append (java.util.Arrays:toString ,o))
				`(sb:append ,o)
			)
		)
	)
	`(begin
		(define sb (StringBuilder))
		,appends
		(sb:toString)
	)
)
(define-macro (let inits @block)
	(define defines
		(mapA init inits:toks
			`(define ,init:toks)
		)
	)
	`(begin
		,defines
		,block
	)
)
(define-macro (lambdaWrap name @types)
	(define n (alen types))
	(define decl (Token[] len:(* n 2)))
	(define args (Token[] len:n))
	(define i 0)
	(while (!= i n)
		(define v `,(Character:toString (as char (+ 97 i))))
		(define t (aget types i))
		(aset decl (* i 2) v)
		(aset decl (+ (* i 2) 1) t)
		(aset args i v)
		(inc i)
	)
	`(lambda (,decl) (,name ,args))
)
(define-macro (for init test step @block)
	`(begin
		,init
		(while ,test
			,block
			,step
		)
	)
)
(define-macro (repeat n @block)
	`(for (define i ,n) (> i 0) (dec i) ,block)
)
(define-macro (cond @cases)
	(define out (aget cases (- (alen cases) 1)))
	(define n
		(if ((out:toks:get 0):what:equals "true")
			(begin
				(set out `(begin ,(out:toks:subList 1 (out:toks:size))))
				2
			)
			(begin
				(set out `())
				1
			)
		)	
	)
	(for (define i (- (alen cases) n)) (>= i 0) (dec i)
		(define case (aget cases i))
		(set out
			`(if ,(case:toks:get 0)
				(begin
					,(case:toks:subList 1 (case:toks:size))
				)
				,out
			)
		)
	)
	out
)
(define-macro (doubleDispatch call arg)
	(define j 1)
	(define special 0)
	(while (&& (!= j (call:toks:size)) (= special 0))
		(define arg VToken (call:toks:get j))
		(if (arg:val:equals "_")
			(set special j)
		)
		(inc j)
	)
	(define conds (ArrayList{Token}))
	(define mname (as VToken ((call:toks:get 0):toks:get 1)):val)
	(define nargs (alen (mi:method:getParameterTypes)))
	(forEach omi mi:ci:methods
		(if (&&
				((omi:method:getName):equals mname) (!= mi omi)
				(= nargs (alen (omi:method:getParameterTypes)))
			)
			(begin
				(define t (aget (omi:method:getParameterTypes) (- special 1)))
				(define ncall ~(,call:toks))
				(ncall:toks:set special ~(as ,(t:getName) ,arg))
				(conds:add
					~((instance? ,arg ,(t:getName))
						,ncall
					)
				)
			)
		)
	)
	(define out
		`(cond
			,conds
			(true (throw (Exception "Double dispatch")))
		)
	)
	out
)