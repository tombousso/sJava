(import gnu.bytecode.*)
(import java.util.*)
(import %tokens%)

;(define-macro (while cond @block)
;	`(begin
;		(label start)
;		(if ,cond (begin ,block (goto start)))
;	)
;)
(define-macro (inc v n)
	`(set ,v (+ ,v ,n))
)
(define-macro (inc v)
	`(inc ,v 1)
)
(define-macro (dec v n)
	`(set ,v (- ,v ,n))
)
(define-macro (dec v)
	`(dec ,v 1)
)
(define-macro (forEachI item iterable index @block)
	(if (instance? (type iterable) ArrayType)
		`(begin
			(define array ,iterable)
			(define ,index 0)
			(while (!= ,index (alen array))
				(define ,item (aget array ,index))
				,block
				(inc ,index)
			)
		)
		`(begin
			(define iterable ,iterable)
			(define it (iterable:iterator))
			(define ,index 0)
			(while (it:hasNext)
				(define ,item (it:next))
				,block
				(inc ,index)
			)
		)
	)
)
(define-macro (forEach item iterable @block)
	`(forEachI ,item ,iterable notused ,block)
)
(define-macro (print @objects)
	`(System:out:print (concat ,objects))
)
(define-macro (println @objects)
	`(System:out:println (concat ,objects))
)
(define-macro (mapAI item collection i @block)
	(define t (type collection))
	(define itemT
		(if (instance? t ArrayType)
			((as ArrayType t):getComponentType)
			(type
				`(begin
					(define collection ,collection)
					((collection:iterator):next)
				)
			)
		)
	)
	(define len
		(if (instance? t ArrayType)
			`(alen collection)
			`(collection:size)
		)
	)
	(define o (type `(begin (define ,item ,(itemT:getName)) (define ,i int) ,block)))
	`(begin
		(define collection ,collection)
		(define out (,((o:getName):concat "[]") len:,len))
		(forEachI ,item collection ,i (aset out ,i (begin ,block)))
		out
	)
)
(define-macro (mapA item iterable @block)
	`(mapAI ,item ,iterable i ,block)
)
(define-macro (concat @objects)
	(define appends
		(mapA o objects
			(if (instance? (type o) ArrayType)
				`(sb:append (java.util.Arrays:toString ,o))
				`(sb:append ,o)
			)
		)
	)
	`(begin
		(define sb (StringBuilder))
		,appends
		(sb:toString)
	)
)
(define-macro (let inits @block)
	(define defines
		(mapA init inits:toks
			`(define ,init:toks)
		)
	)
	`(begin
		,defines
		,block
	)
)
(define-macro (lambdaWrap name @types)
	(define n (alen types))
	(define decl (Token[] len:(* n 2)))
	(define args (Token[] len:n))
	(define i 0)
	(while (!= i n)
		(define v `,(Character:toString (as char (+ 97 i))))
		(define t (aget types i))
		(aset decl (* i 2) v)
		(aset decl (+ (* i 2) 1) t)
		(aset args i v)
		(inc i)
	)
	`(lambda (,decl) (,name ,args))
)
(define-macro (for init test step @block)
	`(begin
		,init
		(while ,test
			(begin
				,block
			)
			,step
		)
	)
)
(define-macro (repeat n @block)
	`(for (define i ,n) (> i 0) (dec i) ,block)
)
(define-macro (cond @cases)
	(define out (aget cases (- (alen cases) 1)))
	(define n
		(if ((out:toks:get 0):what:equals "true")
			(begin
				(set out `(begin ,(out:toks:subList 1 (out:toks:size))))
				2
			)
			(begin
				(set out `())
				1
			)
		)
	)
	(for (define i (- (alen cases) n)) (>= i 0) (dec i)
		(define case (aget cases i))
		(set out
			`(if ,(case:toks:get 0)
				(begin
					,(case:toks:subList 1 (case:toks:size))
				)
				,out
			)
		)
	)
	out
)
(define-macro (doubleDispatch call arg)
	(define j 1)
	(define special 0)
	(while (&& (!= j (call:toks:size)) (= special 0))
		(define arg VToken (call:toks:get j))
		(if (arg:val:equals "_")
			(set special j)
		)
		(inc j)
	)
	(define conds (ArrayList{Token}))
	(define mname (as VToken ((call:toks:get 0):toks:get 1)):val)
	(define nargs (alen (mi:method:getParameterTypes)))
	(forEach omi mi:ci:methods
		(if
			(&&
				((omi:method:getName):equals mname) (!= mi omi)
				(= nargs (alen (omi:method:getParameterTypes)))
			)
			(begin
				(define t (aget (omi:method:getParameterTypes) (- special 1)))
				(define ncall ~(,call:toks))
				(ncall:toks:set special ~(as ,(t:getName) ,arg))
				(conds:add
					~((instance? ,arg ,(t:getName))
						,ncall
					)
				)
			)
		)
	)
	(define out
		`(cond
			,conds
			(true (throw (RuntimeException (concat "Double dispatch with " ,arg))))
		)
	)
	out
)
(define-macro (xml @tags)
	(define appends
		(mapA tag tags
			(if
				(&&
					(instance? tag BlockToken)
					(instance? (tag:toks:get 0) VToken)
					((as VToken (tag:toks:get 0)):val:equals "@")
				)
				(begin
					(define tagName (tag:toks:get 1))
					(define attrAppends (ArrayList{Token}))
					(define i 2)
					(while
						(&&
							(< i (tag:toks:size))
							(instance? (tag:toks:get i) VToken)
							((as VToken (tag:toks:get i)):val:equals "%")
						)
						(define attr (tag:toks:get (+ i 1)))
						(attrAppends:add
							(if (= (attr:toks:size) 1)
								`(begin
									(define val ,(attr:toks:get 0))
									(sb:append " ")
									(sb:append val)
								)
								`(begin
									(define val ,(attr:toks:get 1))
									(if (!= val null)
										(begin
											(sb:append " ")
											(sb:append ,(attr:toks:get 0))
											(sb:append "=\"")
											(sb:append val)
											(sb:append "\"")
										)
									)
								)
							)
						)
						(inc i 2)
					)
					(define hasClose (!= i (tag:toks:size)))
					(define closeAppends
						(if hasClose
							(Token[]
								`(sb:append "</")
								`(sb:append tagName)
								`(sb:append ">")
							)
							(Token[])
						)
					)
					`(begin
						(define tagName ,tagName)
						(sb:append "<")
						(sb:append tagName)
						,attrAppends
						(sb:append ">")
						(sb:append (xml ,(tag:toks:subList i (tag:toks:size))))
						,closeAppends
					)
				)
				(begin
					(if (&& (instance? tag BlockToken) ((as VToken (tag:toks:get 0)):val:equals "xif"))
						(begin
							(if (= (tag:toks:size) 3)
								`(if ,(tag:toks:get 1)
									(sb:append (xml ,(tag:toks:get 2)))
								)
								`(if ,(tag:toks:get 1)
									(sb:append (xml ,(tag:toks:get 2)))
									(sb:append (xml ,(tag:toks:get 3)))
								)
							)
						)
						`(sb:append ,tag)
					)
				)
			)
		)
	)
	`(begin
		(define sb (StringBuffer))
		,appends
		sb
	)
)
