(package sjava.compiler)

(import sjava.compiler.mfilters.*)
(import sjava.compiler.emitters.*)
(import sjava.compiler.handlers.*)
(import sjava.compiler.tokens.*)
(import sjava.compiler.commands.*)

(import java.util.*)
(import java.io.*)
(import java.nio.file.*)
(import gnu.bytecode.*)
(import org.apache.commons.cli.*)

(define-class Main () 'public
	(ML int 'static) ;max length of a special token
	(MP int 'static) ;max precedence
	(precs String[][] 'static) ;precedence to special token array
	(s2prec HashMap{String Integer} 'static) ;special token to precedence
	(specialChars HashMap{String Character} 'static 'public)
	(unboxMethods HashMap{Type Method} 'static 'public)
	(constTypes HashMap{String Type} 'static)
	(accessModifiers HashMap{String Short} 'static)
	(binOps HashMap{String Integer} 'static 'public)
	(compare2Ops HashMap{String Integer} 'static)
	(compare1Ops HashMap{String Integer} 'static)
	(oppositeOps HashMap{String String} 'static)
	(unknownType Type 'static 'public)
	(returnType Type 'static 'public)
	(throwType Type 'static 'public)
	(commands Map{String Command} 'static)
	((<clinit>) void 'static
		(set Main:unknownType (Type:getType "unknownType"))
		(set Main:returnType (Type:getType "returnType"))
		(set Main:throwType (Type:getType "throwType"))

		(set Main:unboxMethods (HashMap{Type Method}))
		(Main:unboxMethods:put (Type:shortType:boxedType) (Type:javalangNumberType:getDeclaredMethod "shortValue" 0))
		(Main:unboxMethods:put (Type:intType:boxedType) (Type:javalangNumberType:getDeclaredMethod "intValue" 0))
		(Main:unboxMethods:put (Type:longType:boxedType) (Type:javalangNumberType:getDeclaredMethod "longValue" 0))
		(Main:unboxMethods:put (Type:floatType:boxedType) (Type:javalangNumberType:getDeclaredMethod "floatValue" 0))
		(Main:unboxMethods:put (Type:doubleType:boxedType) (Type:javalangNumberType:getDeclaredMethod "doubleValue" 0))
		(Main:unboxMethods:put (Type:booleanType:boxedType) (Type:javalangBooleanType:getDeclaredMethod "booleanValue" 0))
		(Main:unboxMethods:put (Type:charType:boxedType) (Type:javalangCharacterType:getDeclaredMethod "charValue" 0))

		(set Main:constTypes (HashMap{String Type}))
		(Main:constTypes:put "bool" Type:booleanType)
		(Main:constTypes:put "byte" Type:byteType)
		(Main:constTypes:put "char" Type:charType)
		(Main:constTypes:put "double" Type:doubleType)
		(Main:constTypes:put "float" Type:floatType)
		(Main:constTypes:put "int" Type:intType)
		(Main:constTypes:put "long" Type:longType)
		(Main:constTypes:put "short" Type:shortType)
		(Main:constTypes:put "void" Type:voidType)

		(set Main:accessModifiers (HashMap{String Short}))
		(Main:accessModifiers:put "static" Access:STATIC)
		(Main:accessModifiers:put "public" Access:PUBLIC)
		(Main:accessModifiers:put "abstract" Access:ABSTRACT)
		(Main:accessModifiers:put "final" Access:FINAL)
		(Main:accessModifiers:put "private" Access:PRIVATE)
		(Main:accessModifiers:put "protected" Access:PROTECTED)
		(Main:accessModifiers:put "synchronized" Access:SYNCHRONIZED)
		(Main:accessModifiers:put "transient" Access:TRANSIENT)
		(Main:accessModifiers:put "volatile" Access:VOLATILE)
		(Main:accessModifiers:put "native" Access:NATIVE)
		(Main:accessModifiers:put "interface" Access:INTERFACE)
		(Main:accessModifiers:put "super" Access:SUPER)

		(set Main:binOps (HashMap{String Integer}))
		(Main:binOps:put "+" 96)
		(Main:binOps:put "-" 100)
		(Main:binOps:put "*" 104)
		(Main:binOps:put "/" 108)
		(Main:binOps:put "%" 112)
		(Main:binOps:put "&" 126)
		(Main:binOps:put "|" 128)
		(Main:binOps:put "^" 130)

		(set Main:compare2Ops (HashMap{String Integer}))
		;opposites
		(Main:compare2Ops:put "!=" 153)
		(Main:compare2Ops:put "=" 154)
		(Main:compare2Ops:put ">=" 155)
		(Main:compare2Ops:put "<" 156)
		(Main:compare2Ops:put "<=" 157)
		(Main:compare2Ops:put ">" 158)

		(set Main:compare1Ops (HashMap{String Integer}))
		;opposites
		(Main:compare1Ops:put "!=0" 153)
		(Main:compare1Ops:put "==0" 154)
		(Main:compare1Ops:put ">=0" 155)
		(Main:compare1Ops:put "<0" 156)
		(Main:compare1Ops:put "<=0" 157)
		(Main:compare1Ops:put ">0" 158)
		(Main:compare1Ops:put "!=null" 198)
		(Main:compare1Ops:put "==null" 199)

		(set Main:oppositeOps (HashMap{String String}))
		(Main:oppositeOps:put "!=" "=")
		(Main:oppositeOps:put "=" "!=")
		(Main:oppositeOps:put ">=" "<")
		(Main:oppositeOps:put "<" ">=")
		(Main:oppositeOps:put "<=" ">")
		(Main:oppositeOps:put ">" "<=")
		(Main:oppositeOps:put "!=0" "==0")
		(Main:oppositeOps:put "==0" "!=0")

		(set Main:precs
			(String[][]
				(String[] "\"\"\"" "\"" ")" "}" "]" ";")
				(String[] "'" "," ",$" "`")
				(String[] ":" "(" "{" "[")
			)
		)

		(set Main:specialChars (HashMap{String Character}))
		(Main:specialChars:put "space" #\space)
		(Main:specialChars:put "newline" #\newline)
		(Main:specialChars:put "lparen" #\lparen)
		(Main:specialChars:put "rparen" #\rparen)

		(set Main:MP (- (alen Main:precs) 1))

		(set Main:ML 3)

		(set Main:s2prec (HashMap{String Integer}))

		(forEachI a Main:precs i
			(forEach b a
				(Main:s2prec:put b i)
			)
		)
	)
	((addCommandToMap c Command) void 'static
		(Main:commands:put (c:name) c)
	)
	((main args String[]) void 'public 'static
		(set Main:commands (LinkedHashMap))
		(Main:addCommandToMap (BuildCommand))
		(Main:addCommandToMap (RunCommand))
		(Main:addCommandToMap (FormatCommand))
		(if (= (alen args) 0)
			(begin
				(Main:printHelp)
				(return)
			)
		)
		(define arg (aget args 0))
		(set args (Arrays:copyOfRange args 1 (alen args)))
		(if (Main:commands:containsKey arg)
			(try
				(begin
					(define cmd (Main:commands:get arg))
					(define commandLine (cmd:parser:parse cmd:options args))
					(if (commandLine:hasOption "h")
						(cmd:printHelp)
						(cmd:run commandLine (commandLine:getArgList))
					)
				)
				(e ParseException (e:printStackTrace))
			)
			(Main:printHelp)
		)
	)
	((printHelp) void 'static
		(println "usage: sjava [command] [arguments]")
		(println)
		(println "Commands:")
		(println)
		(forEach command (Main:commands:keySet)
			(println "\t" command)
		)
		(println)
	)
	((parse code String lexer Lexer parser Parser) List{LexedParsedToken} 'public 'static
		(parser:parseAll (lexer:lex code))
	)
	((formatCode code String) String 'public 'static
		(concat (Main:formatToks (Main:parse code (Lexer) (Parser false))) #\newline)
	)
	((compile fNames List{String}) Map{String FileScope} 'public 'static
		(define fileNames (ArrayList{String}))
		(define path (((((class Main):getProtectionDomain):getCodeSource):getLocation):getPath))
		(define pre
			(if (!= (System:getProperty "sjava.home") null)
				(System:getProperty "sjava.home")
				(if (path:endsWith ".jar")
					((File path):getParent)
					"."
				)
			)
		)
		(fileNames:add (concat pre "/std/macros.sjava"))
		(fileNames:addAll fNames)
		(define files (LinkedHashMap{String List{LexedParsedToken}}))

		(forEach name fileNames
			(define code String null)
			(try (set code (org.apache.commons.io.FileUtils:readFileToString (File name))) (e IOException (throw (RuntimeException e))))
			(define line (Main:checkFormatted code))
			(if (!= line -1)
				(println "Warning: " name " isn't formatted (line " line ")")
			)
			(files:put name (Main:parse code (Lexer) (Parser)))
		)
		(Main:compile files)
	)
	((checkFormatted code String) int 'public 'static
		(define formatted (Main:formatCode code))
		(define line 1)
		(define len (Math:min (code:length) (formatted:length)))
		(for ((i 0)) (< i len) (inc i)
			(if (!= (code:charAt i) (formatted:charAt i))
				(return line)
			)
			(if (= (code:charAt i) #\newline) (inc line))
		)
		(if (!= (code:length) (formatted:length))
			line
			-1
		)
	)
	((compile files HashMap{String ArrayList{LexedParsedToken}}) Map{String FileScope} 'public 'static
		(define locals (HashMap))
		(define fileScopes (LinkedHashMap{String FileScope}))
		(define macroNames (HashMap{String ClassInfo}))
		(define methodMacroNames (HashMap{String ClassInfo}))

		(forEach entry (files:entrySet)
			(define toks (entry:getValue))
			(define fs (FileScope (entry:getKey) toks locals))
			(set fs:macroNames macroNames)
			(set fs:methodMacroNames methodMacroNames)
			(fileScopes:put (entry:getKey) fs)
			(fs:compileRoot)
		)

		(forEach entry (fileScopes:entrySet)
			(define fs (entry:getValue))
			(fs:compileDefs)
		)

		(forEach entry (fileScopes:entrySet)
			(define fs (entry:getValue))
			(fs:runMethodMacros)
		)

		(forEach entry (fileScopes:entrySet)
			(define fs (entry:getValue))
			(fs:compileMethods GenHandler:inst)
		)

		fileScopes
	)
	((resolveType map Map{TypeVariable Type} pt Type t Type) Type 'static 'public
		(cond
			((instance? t TypeVariable)
				(if (instance? pt ParameterizedType)
					(begin
						(define tvs ((as ClassType ((as ParameterizedType pt):getRawType)):getTypeParameters))
						(define s String ((as TypeVariable t):getName))
						(forEachI tv tvs i
							(if ((tv:getName):equals s)
								(return ((as ParameterizedType pt):getTypeArgumentType i))
							)
						)
						(t:getRawType)
					)
					(if (&& (!= map null) (map:containsKey (as TypeVariable t)))
						(map:get (as TypeVariable t))
						(t:getRawType)
					)
				)
			)
			((instance? t ArrayType)
				(ArrayType (Main:resolveType map pt (as ArrayType t):elements))
			)
			((instance? t ParameterizedType)
				(begin
					(define types ((as ParameterizedType t):getTypeArgumentTypes))
					(define parameterized (Type[] len:(alen types)))
					(forEachI type types i
						(aset parameterized i (Main:resolveType map pt type))
					)
					(ParameterizedType (as ClassType (t:getRawType)) parameterized)
				)
			)
			(true
				t
			)
		)
	)
	((resolveType pt Type t Type) Type 'static 'public
		(Main:resolveType null pt t)
	)
	((unresolveTv tv TypeVariable generic Type real Type) Type 'static
		(cond
			((instance? generic TypeVariable)
				(if (tv:equals generic)
					(Main:tryBox real)
					null
				)
			)
			(
				(&&
					(instance? generic ParameterizedType)
					(instance? real ParameterizedType)
					((generic:getRawType):equals (real:getRawType))
				)
				(begin
					(define gtypes ((as ParameterizedType generic):getTypeArgumentTypes))
					(define rtypes ((as ParameterizedType real):getTypeArgumentTypes))
					(define i 0)
					(while (< i (alen gtypes))
						(define ret (Main:unresolveTv tv (aget gtypes i) (aget rtypes i)))
						(if (!= ret null)
							(return ret)
						)
						(set i (+ i 1))
					)
					null
				)
			)
			((&& (instance? generic ArrayType) (instance? real ArrayType))
				(Main:unresolveTv tv (as ArrayType generic):elements (as ArrayType real):elements)
			)
			(true
				null
			)
		)
	)
	((unresolveTvs tvs TypeVariable[] generics Type[] reals Type[]) Map{TypeVariable Type} 'static 'public
		(if (|| (= tvs null) (!= (alen generics) (alen reals)))
			null
			(begin
				(define out (HashMap{TypeVariable Type}))
				(forEach tv tvs
					(define j 0)
					(define t Type null)
					(while (&& (= t null) (!= j (alen generics)))
						(set t (Main:unresolveTv tv (aget generics j) (aget reals j)))
						(set j (+ j 1))
					)
					(out:put tv t)
				)
				out
			)
		)
	)
	((arrayDim t Type) int 'static 'public
		(define out 0)
		(while (instance? t ArrayType)
			(set t (as ArrayType t):elements)
			(set out (+ out 1))
		)
		out
	)
	((compileClassMod tok LexedParsedToken c ClassType) bool 'static
		(if (instance? tok SingleQuoteToken)
			(begin
				(define nmod int (Main:accessModifiers:get (as VToken (tok:toks:get 0)):val))
				(c:addModifiers nmod)
				true
			)
			false
		)
	)
	((getParams ci ClassInfo tok LexedParsedToken scope LinkedHashMap i int o int) List{Type} 'static 'public
		(define n (/ (- (tok:toks:size) i) 2))
		(define types (ArrayList{Type} n))
		(for ((j 0)) (!= j n) (inc j)
			(define type (ci:getType (tok:toks:get (+ (* j 2) i 1))))
			(types:add type)
			(scope:put (as VToken (tok:toks:get (+ (* j 2) i))):val (Arg (+ o j) type))
		)
		types
	)
	((transformBlockTok block BlockToken2 mi AMethodInfo transform bool i int) Token 'public 'static
		(define tok LexedParsedToken (block:toks:get i))
		(define ntok (Main:transformBlock tok mi transform))
		(block:toks:set i ntok)
		(if (&& transform (instance? tok BlockToken) (> (tok:toks:size) 0) (instance? (tok:toks:get 0) VToken))
			(begin
				(define val (as VToken (tok:toks:get 0)):val)
				(if (val:equals "label")
					(block:labels:put (as VToken (tok:toks:get 1)):val (Label))
				)
			)
		)
		ntok
	)
	((transformBlockToks block BlockToken2 mi AMethodInfo transform bool i int) BlockToken2 'public 'static
		(while (!= i (block:toks:size))
			(Main:transformBlockTok block mi transform i)
			(set i (+ i 1))
		)
		block
	)
	((transformBlockToks block BlockToken2 mi AMethodInfo transform bool) BlockToken2 'public 'static
		(Main:transformBlockToks block mi transform 0)
	)
	((transformBlockToks block BlockToken2 mi AMethodInfo) BlockToken2 'public 'static
		(Main:transformBlockToks block mi true)
	)
	((transformToks l List{LexedParsedToken} mi AMethodInfo transform bool) List{Token} 'public 'static
		(define out (ArrayList{Token}))
		(forEach t l
			(out:add
				(Main:transformBlock t mi
					(||
						transform
						(instance? t UnquoteToken)
					)
				)
			)
		)
		out
	)
	((transformToks l List{LexedParsedToken} mi AMethodInfo) List{Token} 'public 'static
		(Main:transformToks l mi true)
	)
	((transformForm block LexedParsedToken mi AMethodInfo transform bool) Token 'public 'static
		(define val (as VToken (block:toks:get 0)):val)
		(define rest (block:toks:subList 1 (block:toks:size)))
		(cond
			((val:equals "unquote")
				(return (Main:transformBlock (UnquoteToken block:line (ArrayList rest) false) mi))
			)
			((val:equals "varunquote")
				(return (Main:transformBlock (UnquoteToken block:line (ArrayList rest) true) mi))
			)
			((val:equals "include")
				(return (IncludeToken block:line (ArrayList rest)))
			)
		)
		(if transform
			(cond
				((val:equals "quote")
					(return (Main:transformBlock (QuoteToken block:line (ArrayList rest)) mi))
				)
				((val:equals "object")
					(return (ObjectToken block:line (ArrayList block:toks)))
				)
				((val:equals "lambda")
					(return (LambdaToken block:line (ArrayList block:toks)))
				)
				((mi:ci:fs:macroNames:containsKey val)
					(return (MacroCallToken block:line val (ArrayList rest)))
				)
				((val:equals "begin")
					;(if (= (block:toks:size) 2)
					;	(return (Main:transformBlock (block:toks:get 1) mi))
					(return (Main:transformBlockToks (BeginToken block:line (ArrayList rest)) mi))
					;)
				)
				((val:equals "label")
					(return (LabelToken block:line (as VToken (block:toks:get 1)):val))
				)
				((val:equals "goto")
					(return (GotoToken block:line (as VToken (block:toks:get 1)):val))
				)
				((val:equals "define")
					(define type (mi:getType (rest:get 1)))
					(define tok Token
						(cond
							((&& (= type null) (= (rest:size) 2))
								(Main:transformBlock (rest:get 1) mi)
							)
							((&& (!= type null) (= (rest:size) 3))
								(Main:transformBlock (rest:get 2) mi)
							)
							((&& (!= type null) (= (rest:size) 2))
								null
							)
							(true
								(throw (RuntimeException (block:toString)))
							)
						)
					)
					(define name (as VToken (rest:get 0)))
					(if (= type null) (set type Main:unknownType))
					(return (DefineToken block:line name type tok))
				)
				((val:equals "try")
					(return (TryToken block:line (Main:transformToks block:toks mi)))
				)
				((val:equals "instance?")
					(return (InstanceToken block:line (Main:transformBlock (block:toks:get 1) mi) (mi:getType (block:toks:get 2))))
				)
				((val:equals "set")
					(return (SetToken block:line (Main:transformToks block:toks mi)))
				)
				((val:equals "aset")
					(return (ASetToken block:line (Main:transformToks block:toks mi)))
				)
				((val:equals "aget")
					(return (AGetToken block:line (Main:transformToks block:toks mi)))
				)
				((val:equals "alen")
					(return (ALenToken block:line (Main:transformBlock (block:toks:get 1) mi)))
				)
				((val:equals "as")
					(return (AsToken block:line (mi:getType (block:toks:get 1)) (Main:transformBlock (block:toks:get 2) mi)))
				)
				((Main:binOps:containsKey val)
					(return (NumOpToken block:line val (Main:transformToks rest mi)))
				)
				((|| (val:equals ">>") (val:equals "<<"))
					(return (ShiftToken block:line (Main:transformBlock (rest:get 0) mi) (Main:transformBlock (rest:get 1) mi) (val:equals ">>")))
				)
				((val:equals "if")
					(return (IfToken block:line (Main:transformToks block:toks mi)))
				)
				((val:equals "while")
					(return (Main:transformBlockToks (WhileToken block:line (ArrayList block:toks)) mi))
				)
				((Main:isCompare val)
					(return (CompareToken block:line val (Main:transformToks rest mi)))
				)
				((val:equals "throw")
					(return (ThrowToken block:line (Main:transformBlock (block:toks:get 1) mi)))
				)
				((val:equals "class")
					(return (ClassToken block:line (mi:getType (block:toks:get 1))))
				)
				((val:equals "synchronized")
					(return (Main:transformBlockToks (SynchronizedToken block:line (ArrayList block:toks)) mi))
				)
				((val:equals "type")
					(return (TypeToken block:line (Main:transformBlock (block:toks:get 1) mi)))
				)
				((val:equals "return")
					(define tok (if (= (block:toks:size) 1) null (Main:transformBlock (block:toks:get 1) mi)))
					(return (ReturnToken block:line tok))
				)
			)
		)
		null
	)
	((transformBlock_ block LexedParsedToken mi AMethodInfo transform bool) Token 'static
		(instanceCond block
			(BlockToken
				(cond
					((= (block:toks:size) 0)
						(if transform
							(return (EmptyToken block:line))
							(return (BlockToken block:line Collections:EMPTY_LIST))
						)
					)
					(true
						(define rest (block:toks:subList 1 (block:toks:size)))
						(define type (if transform (mi:getType (block:toks:get 0)) null))
						(if (&& transform (!= type null))
							(if (instance? type ArrayType)
								(begin
									(define len Token null)
									(if
										(&&
											(!= (rest:size) 0)
											(instance? (rest:get 0) ColonToken)
											(instance? ((as ColonToken (rest:get 0)):toks:get 0) VToken)
											((as VToken ((as ColonToken (rest:get 0)):toks:get 0)):val:equals "len")
										)
										(begin
											(set len (Main:transformBlock ((as ColonToken (rest:get 0)):toks:get 1) mi))
											(set rest (rest:subList 1 (rest:size)))
										)
									)
									(if
										(&&
											(!= (rest:size) 0)
											(instance? (rest:get 0) SingleQuoteToken)
										)
										(begin
											(set len (Main:transformBlock ((as SingleQuoteToken (rest:get 0)):toks:get 0) mi))
											(set rest (rest:subList 1 (rest:size)))
										)
									)
									(return (ArrayConstructorToken block:line type len (Main:transformToks rest mi)))
								)
								(return (ConstructorToken block:line type (Main:transformToks rest mi)))
							)
						)
						(cond
							((instance? (block:toks:get 0) VToken)
								(define o (Main:transformForm block mi transform))
								(if (!= o null) (return o))
							)
							((&& transform (instance? (block:toks:get 0) ColonToken))
								(define first ColonToken (block:toks:get 0))
								(define out
									(CallToken
										block:line
										(Main:transformBlock (first:toks:get 0) mi true)
										(as VToken (first:toks:get 1)):val
										(Main:transformToks (block:toks:subList 1 (block:toks:size)) mi)
									)
								)
								(return out)
							)
						)
						(if transform
							(return (DefaultToken block:line (Main:transformToks block:toks mi)))
							(return (BlockToken block:line (Main:toLexedParsed (Main:transformToks block:toks mi false))))
						)
					)
				)
			)
			(ColonToken
				(if transform
					(return
						(FieldToken block:line
							(Main:transformBlock (block:toks:get 0) mi)
							(as VToken (block:toks:get 1)):val
						)
					)
					(return (ColonToken block:line (Main:toLexedParsed (Main:transformToks block:toks mi transform))))
				)
			)
			(QuoteToken
				(if transform
					(return
						(QuoteToken2 block:line
							(Main:transformBlock
								(block:toks:get 0)
								mi
								(instance? (block:toks:get 0) UnquoteToken)
							)
						)
					)
					(return (QuoteToken block:line (Main:toLexedParsed (Main:transformToks block:toks mi false))))
				)
			)
			(UnquoteToken
				(return (UnquoteToken block:line (ArrayList block:toks) block:var))
			)
			(GenericToken
				(if transform
					(throw (RuntimeException))
					(return (GenericToken block:line (Main:toLexedParsed (Main:transformToks block:toks mi transform))))
				)
			)
			(ArrayToken
				(if transform
					(throw (RuntimeException))
					(return (ArrayToken block:line (Main:toLexedParsed (Main:transformToks block:toks mi transform))))
				)
			)
		)
		block
	)
	((transformBlock block LexedParsedToken mi AMethodInfo transform bool) Token 'static 'public
		(if (!= block:transformed null)
			block:transformed
			(begin
				(define out (Main:transformBlock_ block mi transform))
				(set block:transformed out)
				out
			)
		)
	)
	((transformBlock block LexedParsedToken mi AMethodInfo) Token 'static 'public
		(Main:transformBlock block mi true)
	)
	((numericOpType types Type[]) Type 'static 'public
		(define l (Arrays:asList types))
		(cond
			((|| (l:contains Type:doubleType) (l:contains (ClassType:make "java.lang.Double")))
				Type:doubleType
			)
			((|| (l:contains Type:floatType) (l:contains (ClassType:make "java.lang.Float")))
				Type:floatType
			)
			((|| (l:contains Type:longType) (l:contains (ClassType:make "java.lang.Long")))
				Type:longType
			)
			(true Type:intType)
		)
	)
	((allNumeric types Type[]) bool 'static 'public
		(define i 0)
		(while (!= i (alen types))
			(define t (Main:tryUnbox (aget types i)))
			(if (! (instance? t PrimType))
				(return false)
			)
			(set i (+ i 1))
		)
		true
	)
	((tryBox t Type) Type 'static 'public
		(if (instance? t PrimType)
			((as PrimType t):boxedType)
			t
		)
	)
	((tryUnbox t Type) Type 'static 'public
		(define o (PrimType:unboxedType t))
		(if (= o null)
			t
			o
		)
	)
	((isCompare s String) bool 'static 'public
		(|| (s:equals "!") (s:equals "&&") (s:equals "||") (Main:compare2Ops:containsKey s))
	)
	((invertComp inv bool comp String) String 'static
		(if inv
			(Main:oppositeOps:get comp)
			comp
		)
	)
	((emitInvoke h GenHandler name String type Type emitters List{Emitter} mi AMethodInfo code CodeAttr needed Type special bool) Type 'static 'public
		(define output (!= code null))
		(define types (Emitter:emitAll emitters h mi null Main:unknownType))
		;(System:out:println name)
		;(System:out:println type)
		;(System:out:println (Arrays:toString types))
		(define filter (MFilter name types type))
		(if special
			(filter:searchDeclared)
			(filter:searchAll)
		)
		(define mc (filter:getMethodCall))
		(define method mc:m)
		;(System:out:println method)
		(define typeParameters (method:getTypeParameters))
		(define params (method:getGenericParameterTypes))
		(define varargs (!= (& (method:getModifiers) Access:TRANSIENT) 0))
		(begin
			(define j 0)
			(define n
				(if
					(&&
						varargs
						(||
							(< (alen types) (alen params))
							(!= (Main:arrayDim (aget params (- (alen params) 1))) (Main:arrayDim (aget types (- (alen params) 1))))
						)
					)
					1
					0
				)
			)
			(while (!= j (- (alen params) n))
				((emitters:get j):emit h mi code (Main:resolveType mc:tvs mc:t (aget params j)))
				(set j (+ j 1))
			)
			(if (= n 1)
				(begin
					(define at ArrayType (aget params (- (alen params) 1)))
					(define et (Main:resolveType mc:tvs mc:t at:elements))
					(if output (code:emitPushInt (+ 1 (- (alen types) (alen params)))))
					(if output (code:emitNewArray (at:elements:getRawType)))
					(define oj j)
					(while (!= j (alen types))
						(if output (code:emitDup))
						(if output (code:emitPushInt (- j oj)))
						((emitters:get j):emit h mi code et)
						(if output (code:emitArrayStore))
						(set j (+ j 1))
					)
				)
			)
		)
		(if special
			(if output (code:emitInvokeSpecial method))
			(if output (code:emitInvoke method))
		)
		(define out (Main:resolveType mc:tvs mc:t (method:getReturnType)))
		(if (&& (!= out Type:voidType) (!= needed Type:voidType))
			(if output (code:emitCheckcast (out:getRawType)))
		)
		(h:castMaybe out needed)
	)
	((emitInvoke h GenHandler name String type Type emitters List{Emitter} mi AMethodInfo code CodeAttr needed Type) Type 'static 'public
		(Main:emitInvoke h name type emitters mi code needed false)
	)
	((compareType types Type[]) Type 'static
		(if (Main:allNumeric types)
			(Main:numericOpType types)
			Type:objectType
		)
	)
	;tok = condition
	((emitIf_ h GenHandler inv bool toks List{Token} i int e int compare String trueE Emitter falseE Emitter mi AMethodInfo code CodeAttr needed Type) Type 'static 'public
		(define output (!= code null))
		(if (compare:equals "!")
			(Main:emitIf h (! inv) toks i trueE falseE mi code needed)
			(if (|| (&& (! inv) (compare:equals "&&")) (&& inv (compare:equals "||")))
				(begin
					(define skipL (Label))
					(define falseL (Label))
					(define falseG (Goto falseL))
					(define i i)
					(while (!= i (- e 1))
						(Main:emitIf h inv toks i Nothing:inst falseG mi code needed)
						(set i (+ i 1))
					)
					(Main:emitIf h inv toks (- e 1) (Emitters (Emitter[] trueE (Goto skipL))) Nothing:inst mi code needed)
					(if output (falseL:define code))
					(falseE:emit h mi code needed)
					(if output (skipL:define code))
					(trueE:emit h mi null needed)
				)
				(if (|| (&& (! inv) (compare:equals "||")) (&& inv (compare:equals "&&")))
					(begin
						(define skipL (Label))
						(define trueL (Label))
						(define trueG (Goto trueL))
						(define i i)
						(while (!= i (- e 1))
							(Main:emitIf h (! inv) toks i Nothing:inst trueG mi code needed)
							(set i (+ i 1))
						)
						(Main:emitIf h (! inv) toks (- e 1) (Emitters (Emitter[] falseE (Goto skipL))) Nothing:inst mi code needed)
						(if output (trueL:define code))
						(define type (trueE:emit h mi code needed))
						(if output (skipL:define code))
						type
					)
					(begin
						(define falseLabel (instance? falseE Goto))
						(define skip (Label))
						(define label
							(if falseLabel
								(as Goto falseE):label
								skip
							)
						)
						(define invCompare (Main:invertComp inv compare))
						(if (Main:compare1Ops:containsKey invCompare)
							(begin
								(define j i)
								(while (!= j e)
									(define types (h:compileAll toks j (+ j 1) mi null Main:unknownType))
									(define otype (Main:compareType types))
									(h:compileAll toks j (+ j 1) mi code otype)
									(if output (code:emitGotoIfCompare1 label (Main:compare1Ops:get invCompare)))
									(set j (+ j 1))
								)
							)
							(begin
								(define j i)
								(while (!= (+ j 1) e)
									(define types (h:compileAll toks j (+ j 2) mi null Main:unknownType))
									(define otype (Main:compareType types))
									(h:compileAll toks j (+ j 2) mi code otype)
									(if (|| (= otype Type:doubleType) (= otype Type:floatType))
										(begin
											(define lt (|| (compare:equals "<") (compare:equals "<=")))
											(define op (if (= otype Type:doubleType) (if lt 151 152) (if lt 149 150)))
											(if output (code:emitPrimop op 2 Type:intType))
											(cond
												((invCompare:equals ">") (if output (code:emitGotoIfIntLeZero label)))
												((invCompare:equals ">=") (if output (code:emitGotoIfIntLtZero label)))
												((invCompare:equals "<") (if output (code:emitGotoIfIntGeZero label)))
												((invCompare:equals "<=") (if output (code:emitGotoIfIntGtZero label)))
												((invCompare:equals "=") (if output (code:emitGotoIfIntNeZero label)))
												((invCompare:equals "!=") (if output (code:emitGotoIfIntEqZero label)))
											)
										)
										(if output (code:emitGotoIfCompare2 label (Main:compare2Ops:get invCompare)))
									)
									(set j (+ j 1))
								)
							)
						)
						(define type (trueE:emit h mi code needed))
						(if (! falseLabel)
							(begin
								(define end (Label))
								(if (! (instance? falseE Nothing))
									(if (&& output (code:reachableHere)) (code:emitGoto end))
								)
								(if output (skip:define code))
								(falseE:emit h mi code needed)
								(if output (end:define code))
							)
						)
						type
					)
				)
			)
		)
	)
	((emitIf h GenHandler inv bool toks List{Token} i int trueE Emitter falseE Emitter mi AMethodInfo code CodeAttr needed Type) Type 'static 'public
		(define cond (toks:get i))
		(instanceCond cond
			(CompareToken (Main:emitIf_ h inv cond:toks 0 (cond:toks:size) cond:compare trueE falseE mi code needed))
			(true (Main:emitIf_ h inv toks i (+ i 1) "!=0" trueE falseE mi code needed))
		)
	)
	((generateBridgeMethod target Method params Type[] ret Type) void 'static 'public
		(define c (target:getDeclaringClass))
		(define rparams (Type[] len:(alen params)))
		(define i 0)
		(while (!= i (alen params))
			(aset rparams i ((aget params i):getRawType))
			(set i (+ i 1))
		)
		(define found (c:getDeclaredMethod (target:getName) rparams))
		(if (|| (= found null) (! (Type:isSame (found:getReturnType) ret)))
			(begin
				(define m (c:addMethod (target:getName) rparams (ret:getRawType) (| Access:PUBLIC Access:BRIDGE Access:SYNTHETIC)))
				(define code (m:startCode))
				(define i 0)
				(code:emitPushThis)
				(while (!= i (alen rparams))
					(code:emitLoad (code:getArg (+ i 1)))
					(GenHandler:castMaybe code (aget rparams i) (aget (target:getGenericParameterTypes) i))
					(set i (+ i 1))
				)
				(code:emitInvoke target)
				(GenHandler:castMaybe code (target:getReturnType) (ret:getRawType))
				(code:emitReturn)
			)
		)
	)
	((getCompilerType name String) ClassType 'static 'public
		(ClassType:make (concat "sjava.compiler." name))
	)
	((formatTok tok LexedParsedToken line int toLine int tabs int sb StringBuffer) int 'static
		(repeat (- toLine line) (sb:append "\n"))
		(if (!= toLine line) (repeat tabs (sb:append "\t")))
		(set line tok:line)
		(instanceCond tok
			(BlockToken
				(set line (Main:formatToks tok tabs "(" ")" sb))
			)
			(GenericToken
				(set line (Main:formatTok (tok:toks:get 0) line line tabs sb))
				(set line (Main:formatToks tok tabs "{" "}" sb (tok:toks:subList 1 (tok:toks:size))))
			)
			(ArrayToken
				(set line (Main:formatTok (tok:toks:get 0) line line tabs sb))
				(set line (Main:formatToks tok tabs "[" "]" sb (tok:toks:subList 1 (tok:toks:size))))
			)
			(ColonToken
				(set line (Main:formatTok (tok:toks:get 0) line line tabs sb))
				(sb:append ":")
				(set line (Main:formatTok (tok:toks:get 1) line line tabs sb))
			)
			(SingleQuoteToken
				(sb:append "'")
				(set line (Main:formatTok (tok:toks:get 0) line line tabs sb))
			)
			(QuoteToken
				(sb:append "`")
				(set line (Main:formatTok (tok:toks:get 0) line line tabs sb))
			)
			(UnquoteToken
				(sb:append (if tok:var ",$" ","))
				(set line (Main:formatTok (tok:toks:get 0) line line tabs sb))
			)
			(CommentToken
				(sb:append ";")
				(sb:append tok:val)
			)
			(true
				(if (!= tok:toks null) (throw (RuntimeException)))
				(sb:append (tok:toString))
			)
		)
		tok:endLine
	)
	((formatToks block LexedParsedToken tabs int before String after String sb StringBuffer toks List{LexedParsedToken}) int 'static
		(sb:append before)
		(define line 0)
		(define cont true)
		(forEachI tok toks i
			(define indent false)
			(define toLine tok:line)
			(define multiline (!= (tok:firstLine) (tok:lastLine)))
			(if (= i 0)
				(if multiline
					(begin
						(set toLine (+ line 1))
						(set indent true)
					)
					(set toLine line)
				)
				(if (&& (= tok:line line) multiline)
					(begin
						(set toLine (+ tok:line 1))
						(set indent true)
					)
					(begin
						(if (= tok:line line) (sb:append " "))
						(set indent (!= tok:line block:line))
					)
				)
			)
			(set line (Main:formatTok tok line toLine (+ tabs (if indent 1 0)) sb))
		)
		(if (!= (block:firstLine) (block:lastLine))
			(begin
				(sb:append "\n")
				(repeat tabs (sb:append "\t"))
			)
		)
		(sb:append after)
		(set line block:endLine)
		line
	)
	((formatToks block LexedParsedToken tabs int before String after String sb StringBuffer) int 'static
		(Main:formatToks block tabs before after sb block:toks)
	)
	((formatToks toks List{LexedParsedToken}) String 'static
		(define sb (StringBuffer))
		(define line (if (!= (toks:size) 0) (toks:get 0):line 1))
		(forEachI tok toks i
			(define off (if (&& (= tok:line line) (!= i 0)) 1 0))
			(set line (Main:formatTok tok line (+ tok:line off) 0 sb))
		)
		(sb:toString)
	)
	((toEmitters l List) List{Emitter} 'public 'static
		l
	)
	((toLexedParsed l List) List{LexedParsedToken} 'public 'static
		l
	)
	((typeToTok t Type) LexedParsedToken 'public 'static
		(instanceCond t
			(ArrayType
				(ArrayToken -1 (ArrayList (Arrays:asList (Main:typeToTok (t:getComponentType)))))
			)
			(ParameterizedType
				(define toks (ArrayList{LexedParsedToken}))
				(toks:add (Main:typeToTok (t:getRawType)))
				(forEach ta (t:getTypeArgumentTypes)
					(toks:add (Main:typeToTok ta))
				)
				(GenericToken -1 toks)
			)
			(true
				(VToken -1 (t:getName))
			)
		)
	)
)

(define-class Tester () 'public
	((main args String[]) void 'public 'static
		(try
			(begin
				(define dir (File "examples/"))
				(define fileFilter Object (org.apache.commons.io.filefilter.WildcardFileFilter "*.expected.txt"))
				(define files (dir:listFiles (as FileFilter fileFilter)))
				(System:setProperty "line.separator" "\n")
				(forEach file files
					(define fname (file:getName))
					(define name (fname:substring 0 (fname:indexOf ".")))
					(define c (Class:forName (concat "examples." name ".Main")))
					(define baos (ByteArrayOutputStream))
					(define ps (PrintStream baos))
					(define old System:out)
					(System:setOut ps)
					((c:getMethod "main" (class String[])):invoke null null)
					(ps:flush)
					(System:setOut old)
					(define expected (org.apache.commons.io.FileUtils:readFileToString file))
					(define out (baos:toString))
					(define passed (out:equals expected))
					(println name ": " (if passed "PASSED" "FAILED"))
					(if (! passed) (return))
				)
			)
			(e Throwable (e:printStackTrace))
		)
	)
)

(define-class Lexer () 'public
	(code String)
	(i int)
	(len int)
	(s String)
	(line int)
	((<init>) void 'public
		(super:<init>)
	)
	((getprec) int
		;check if code at i is a special token
		(define p -1)
		(define l Main:ML)
		(while (&& (= p -1) (!= l 0))
			(if (<= (+ this:i l) this:len)
				(begin
					(set this:s (this:peek 0 l))
					(if (Main:s2prec:containsKey this:s)
						(set p (Main:s2prec:get this:s))
					)
				)
			)
			(set l (- l 1))
		)
		p
	)
	((peek n int l int) String
		(this:code:substring (+ this:i n) (+ this:i n l))
	)
	((peek n int) char
		(this:code:charAt (+ this:i n))
	)
	((peek) char
		(this:peek 0)
	)
	((skip n int) void
		(for ((i 0)) (< i n) (inc i)
			(if (= (this:peek) #\newline)
				(inc this:line)
			)
			(inc this:i)
		)
	)
	((skip) void
		(this:skip 1)
	)
	((nextTok) void
		(while (&& (!= this:i this:len) (= (this:getprec) -1) (! (Character:isWhitespace (this:peek))))
			(this:skip 1)
		)
	)
	((token) LexedToken
		(while (&& (!= this:i this:len) (= (this:getprec) -1) (Character:isWhitespace (this:peek)))
			(this:skip 1)
		)
		(define p (this:getprec))
		(define oline this:line)
		(define out LexedToken
			(if (= p -1)
				(begin
					(define c (if (= this:i this:len) (as char 0) (this:peek)))
					(define oi this:i)
					(if (= c #\#)
						(begin
							(while (&& (!= (this:peek) #\space) (!= (this:peek) #\rparen))
								(this:skip 1)
							)
							(define schar (this:code:substring (+ oi 2) this:i))
							(CToken this:line
								(if (= (schar:length) 1)
									(schar:charAt 0)
									(Main:specialChars:get schar)
								)
							)
						)
						(if (|| (Character:isDigit c) (&& (= c #\-) (Character:isDigit (this:peek 1))))
							(begin
								(this:nextTok)
								(NToken this:line (this:code:substring oi this:i))
							)
							(begin
								(this:nextTok)
								(define s (this:code:substring oi this:i))
								(if (s:equals "")
									null
									(if (|| (s:equals "null") (s:equals "true") (s:equals "false"))
										(ConstToken this:line s)
										(VToken this:line s)
									)
								)
							)
						)
					)
				)
				(begin
					(this:skip (this:s:length))
					(define oi this:i)
					(if (this:s:equals "\"\"\"")
						(begin
							(while (! ((this:peek 0 3):equals "\"\"\""))
								(if ((this:peek 0 7):equals "\\\"\"\"\"\"\"")
									(this:skip 4)
									(if (|| ((this:peek 0 5):equals "\\\\\"\"\"") ((this:peek 0 5):equals "\\\"\"\"\""))
										(this:skip 2)
										(if ((this:peek 0 4):equals "\\\"\"\"")
											(this:skip 4)
											(this:skip)
										)
									)
								)
							)
							(define str ((this:code:substring oi this:i):replace "\\\"\"\"" "\"\"\""))
							(if (str:endsWith "\\\\")
								(set str (concat (str:substring 0 (- (str:length) 2)) "\\"))
								(if (str:endsWith "\\\"")
									(set str (concat (str:substring 0 (- (str:length) 2)) "\""))
								)
							)
							(this:skip 3)
							(SToken oline str true)
						)
						(if (this:s:equals "\"")
							(begin
								(while (!= (this:peek) #\")
									(if (= (this:peek) #\\)
										(this:skip 2)
										(this:skip)
									)
								)
								(this:skip)
								(SToken this:line (org.apache.commons.lang3.StringEscapeUtils:unescapeJava (this:code:substring oi (- this:i 1))) false)
							)
							(if (this:s:equals ";")
								(begin
									(while (&& (!= this:i this:len) (!= (this:peek) #\newline))
										(this:skip)
									)
									(CommentToken this:line (this:code:substring oi this:i))
								)
								(LexedToken this:line p this:s)
							)
						)
					)
				)
			)
		)
		(if (!= out null)
			(set out:endLine this:line)
		)
		out
	)
	((lex code String) List{LexedToken}
		(set this:code code)
		(set this:i 0)
		(set this:len (code:length))
		(set this:line 1)
		(define out (ArrayList{LexedToken}))
		(while
			(!= this:i this:len)
			(define tok (this:token))
			(if (!= tok null) (out:add tok))
		)
		out
	)
)

(define-class Parser () 'public
	(toks List{LexedToken})
	(i int)
	(ignoreComments bool)
	((<init> ignoreComments bool) void 'public
		(super:<init>)
		(set this:ignoreComments ignoreComments)
	)
	((<init>) void 'public
		(this:<init> true)
	)
	((next) LexedToken
		(define ret (this:toks:get this:i))
		(inc this:i)
		ret
	)
	((peek n int) LexedToken
		(this:toks:get (+ this:i n))
	)
	((subToks end String) ArrayList{LexedParsedToken}
		(define toks (ArrayList{LexedParsedToken}))
		(while (! ((this:peek 0):what:equals end))
			(define t (this:parse 0))
			(if (!= t null) (toks:add t))
		)
		(this:next)
		toks
	)
	((parse prec int) LexedParsedToken
		(define t (this:next))
		(define w t:what)
		(define left LexedParsedToken
			(cond
				((w:equals "(")
					(define toks (this:subToks ")"))
					(BlockToken t:line toks)
				)
				((|| (w:equals "'") (w:equals "`") (w:equals ",$") (w:equals ","))
					(define al (Arrays:asList (this:parse 2)))
					(if (|| (w:equals ",") (w:equals ",$"))
						(UnquoteToken t:line al (w:equals ",$"))
						(if (w:equals "'")
							(SingleQuoteToken t:line al)
							(QuoteToken t:line al)
						)
					)
				)
				((&& this:ignoreComments (instance? t CommentToken))
					(return null)
				)
				(true
					t
				)
			)
		)
		(if (= left:endLine 0) (set left:endLine (this:peek -1):line))
		(define cont true)
		(while (&& cont (!= this:i (this:toks:size)) (> (this:prec) prec))
			(define w (this:peek 0):what)
			(cond
				((w:equals ":")
					(this:next)
					(define right (this:parse 2))
					(set left (ColonToken t:line (ArrayList (Arrays:asList left right))))
				)
				((w:equals "{")
					(this:next)
					(define toks (this:subToks "}"))
					(toks:add 0 left)
					(set left (GenericToken t:line toks))
				)
				((w:equals "[")
					(this:next)
					(define toks (this:subToks "]"))
					(toks:add 0 left)
					(set left (ArrayToken t:line toks))
				)
				(true
					(set cont false)
				)
			)
			(if cont (set left:endLine (this:peek -1):line))
		)
		left
	)
	((prec) int
		(this:peek 0):prec
	)
	((parseAll toks List{LexedToken}) List{LexedParsedToken}
		(set this:i 0)
		(set this:toks toks)
		(define out (ArrayList{LexedParsedToken}))
		(while (!= this:i (this:toks:size))
			(define t (this:parse 0))
			(if (!= t null) (out:add t))
		)
		out
	)
)

(define-class AVar () 'public
	(type Type 'public)
	((<init> type Type) void (super:<init>) (set this:type type))
	((load code CodeAttr) Type 'public this:type)
	((store code CodeAttr) void 'public ())
)

(define-class Var (AVar)
	(var Variable)
	((<init> var Variable type Type) void (super:<init> type) (set this:var var))
	((load code CodeAttr) Type 'public
		(define output (!= code null))
		(if output (code:emitLoad this:var))
		this:type
	)
	((store code CodeAttr) void 'public
		(define output (!= code null))
		(if output (code:emitStore this:var))
	)
)

(define-class Arg (AVar) 'public
	(n int)
	((<init> n int type Type) void 'public (super:<init> type) (set this:n n))
	((load code CodeAttr) Type 'public
		(define output (!= code null))
		(if output (code:emitLoad (code:getArg this:n)))
		(if output (code:emitCheckcast (this:type:getRawType)))
		this:type
	)
	((store code CodeAttr) void 'public
		(define output (!= code null))
		(if output (code:emitStore (code:getArg this:n)))
	)
)

(define-class VCaptured (AVar) 'public
	(field Field 'public)
	(avar AVar 'public)
	((<init> avar AVar field Field) void 'public
		(super:<init> avar:type)
		(set this:avar avar)
		(set this:field field)
	)
	((load code CodeAttr) Type 'public
		(define output (!= code null))
		(if output (code:emitPushThis))
		(if output (code:emitGetField this:field))
		this:type
	)
	((store code CodeAttr) void 'public
		(throw (RuntimeException))
	)
)

(define-class FileScope () 'public
	(name String 'public)
	(toks List{LexedParsedToken})
	(locals HashMap{String ClassType})
	(imports HashMap{String String})
	(starImports ArrayList{String})
	(found HashMap{String Boolean})
	(includes ClassInfo 'public)
	(newClasses List{ClassInfo} 'public)
	(package_ String)
	(macros ArrayList{ClassInfo})
	(macroNames HashMap{String List{ClassInfo}} 'public)
	(methodMacros ArrayList{ClassInfo})
	(methodMacroNames HashMap{String List{ClassInfo}} 'public)
	((<init> name String toks List{LexedParsedToken} locals HashMap) void
		(super:<init>)
		(set this:name name)
		(set this:toks toks)
		(set this:locals locals)
		(set this:imports (HashMap))
		(set this:starImports (ArrayList))
		(this:starImports:add "java.lang.")
		(this:starImports:add "sjava.std.")
		(set this:found (HashMap{String Boolean}))
		(set this:newClasses (ArrayList{ClassInfo}))
		(set this:macros (ArrayList))
		(set this:package_
			(if
				(&&
					(> (toks:size) 0)
					(instance? (toks:get 0) BlockToken)
					(instance? ((toks:get 0):toks:get 0) VToken)
					((as VToken ((toks:get 0):toks:get 0)):val:equals "package")
				)
				((as VToken ((toks:get 0):toks:get 1)):val:concat ".")
				""
			)
		)
		(define includes (MacroInfo "Includes" this))
		(set this:includes includes)
		(includes:c:setModifiers Access:PUBLIC)
		(set this:methodMacros (ArrayList))
	)
	((classExists name String) bool
		(if (this:found:containsKey name)
			(this:found:get name)
			(begin
				(define b
					(try
						(begin
							(Class:forName name)
							true
						)
						(e Throwable false)
					)
				)
				(this:found:put name b)
				b
			)
		)
	)
	((getNewType tok Token) ClassType
		(instanceCond tok
			(GenericToken
				(define c (ClassType (this:package_:concat (as VToken (tok:toks:get 0)):val)))
				(define params (tok:toks:subList 1 (tok:toks:size)))
				(define tparams (Type[] len:(params:size)))
				(define i 0)
				(while (!= i (params:size))
					(define name (as VToken (params:get i)):val)
					(define tv (TypeVariable name))
					(aset tparams i tv)
					(set i (+ i 1))
				)
				(c:setTypeParameters tparams)
				c
			)
			(VToken
				(ClassType (this:package_:concat tok:val))
			)
			(true null)
		)
	)
	((compileRoot) void
		(define i 0)
		(while (!= i (this:toks:size))
			(this:compileRoot (this:toks:get i))
			(set i (+ i 1))
		)
	)
	((getMacroParams out List{Type} params BlockToken scope Map) bool
		(define varargs false)
		(define o (out:size))
		(forEachI tok (params:toks:subList 1 (params:toks:size)) i
			(define t Object (Main:getCompilerType "tokens.LexedParsedToken"))
			(define name (as VToken tok):val)
			(if (name:contains "@")
				(begin
					(set name (name:replace "@" ""))
					(set t (ArrayType (as Type t)))
					(set varargs true)
				)
			)
			(out:add (as Type t))
			(scope:put name (Arg (+ o i) (as Type t)))
		)
		varargs
	)
	((compileRoot tok LexedParsedToken) void
		(if (instance? (tok:toks:get 0) VToken)
			(begin
				(define first VToken (tok:toks:get 0))
				(cond
					((first:val:equals "define-class")
						(define c (this:getNewType (tok:toks:get 1)))
						(define name (c:getName))
						(define ci (ClassInfo c this))
						(set ci:toks tok:toks)
						(this:newClasses:add ci)
						(this:locals:put name ci:c)
						(define run true)
						(define i 3)
						(while (&& run (!= i (tok:toks:size)))
							(set run (Main:compileClassMod (tok:toks:get i) ci:c))
							(if run (set i (+ i 1)))
						)
					)
					((first:val:equals "import")
						(define import (as VToken (tok:toks:get 1)):val)
						(if (import:equals "%tokens%")
							(this:starImports:add "sjava.compiler.tokens.")
							(if (import:contains "*")
								(this:starImports:add (import:replace "*" ""))
								(this:imports:put (import:substring (+ (import:lastIndexOf ".") 1)) import)
							)
						)
					)
					((first:val:equals "define-macro")
						(define scope (LinkedHashMap))
						(define params BlockToken (tok:toks:get 1))
						(define name (as VToken (params:toks:get 0)):val)
						(define types (ArrayList{Type} (Arrays:asList (Type[] (Main:getCompilerType "AMethodInfo") (Type:getType "gnu.bytecode.Type") Type:intType (Main:getCompilerType "handlers.GenHandler")))))
						(define mods (| Access:PUBLIC Access:STATIC))
						(scope:put "mi" (Arg 0 (Main:getCompilerType "AMethodInfo")))
						(define varargs (this:getMacroParams types params scope))
						(if varargs (set mods (| mods Access:TRANSIENT)))
						(define cname ((("Macros$":concat (this:name:replace "/" "-")):concat "$"):concat (Integer:toString (this:macros:size))))
						(define macros (MacroInfo cname this))
						(macros:c:setModifiers Access:PUBLIC)
						(define macro (macros:addMethod name types (Main:getCompilerType "tokens.LexedParsedToken") mods (tok:toks:subList 2 (tok:toks:size)) scope))
						(if (this:macroNames:containsKey name)
							((this:macroNames:get name):add macros)
							(begin
								(define al (ArrayList{ClassInfo}))
								(al:add macros)
								(this:macroNames:put name al)
							)
						)
						(this:macros:add macros)
					)
					((first:val:equals "define-method-macro")
						(define scope (LinkedHashMap))
						(define params BlockToken (tok:toks:get 1))
						(define name (as VToken (params:toks:get 0)):val)
						(define types (ArrayList{Type} (Arrays:asList (Type[] (Main:getCompilerType "ClassInfo")))))
						(define mods (| Access:PUBLIC Access:STATIC))
						(scope:put "ci" (Arg 0 (Main:getCompilerType "ClassInfo")))
						(define varargs (this:getMacroParams types params scope))
						(if varargs (set mods (| mods Access:TRANSIENT)))
						(define cname (concat "Macros$" (this:name:replace "/" "-") "$" (this:methodMacros:size)))
						(define macros (MethodMacroInfo cname this))
						(macros:c:setModifiers Access:PUBLIC)
						(define macro (macros:addMethod name types Type:voidType mods (tok:toks:subList 2 (tok:toks:size)) scope))
						(if (this:methodMacroNames:containsKey name)
							((this:methodMacroNames:get name):add macros)
							(begin
								(define al (ArrayList{ClassInfo}))
								(al:add macros)
								(this:methodMacroNames:put name al)
							)
						)
						(this:methodMacros:add macros)
						(macros:methods:add macro)
					)
					((! (first:val:equals "package")) (throw (RuntimeException first:val)))
				)
			)
		)
	)
	((compileDefs) void
		(forEach ci this:newClasses
			(ci:compileDefs)
		)
	)
	((runMethodMacros) void
		(forEach ci this:newClasses
			(ci:runMethodMacros)
		)
	)
	;(Files:write (Paths:get (("macros/":concat (macro:c:getName)):concat ".class") (String[])) (macro:getClassfile) (OpenOption[]))
	((compileMethods h GenHandler) void 'public
		(define i 0)
		(while (!= i (this:newClasses:size))
			((this:newClasses:get i):compileMethods h)
			(set i (+ i 1))
		)
	)
	((compileInclude tok IncludeToken) void 'public
		(define name ("$":concat (Integer:toString (this:includes:c:getMethodCount))))
		(define scope (LinkedHashMap))
		(scope:put "mi" (Arg 0 (Main:getCompilerType "AMethodInfo")))
		(define params (Type[] (Main:getCompilerType "AMethodInfo") (Type:getType "gnu.bytecode.Type") Type:intType (Main:getCompilerType "handlers.GenHandler")))
		(define mi (this:includes:addMethod name (Arrays:asList params) (Main:getCompilerType "tokens.LexedParsedToken") (| Access:PUBLIC Access:STATIC) tok:toks scope))
		(mi:compileMethodBody)
		(set tok:mi mi)
	)
)

(define-class ClassInfo () 'public
	(c ClassType 'public)
	(fs FileScope 'public)
	(toks List{LexedParsedToken})
	(methods List{AMethodInfo} 'public)
	(anonClasses List{ClassInfo} 'public)
	(rc Class)
	(tvs HashMap{String TypeVariable})
	(classfile byte[])
	((<init> c ClassType fs FileScope) void 'public
		(super:<init>)
		(set this:fs fs)
		(set this:c c)
		(set this:methods (ArrayList{AMethodInfo}))
		(set this:anonClasses (ArrayList{ClassInfo}))
		(if (!= c null)
			(begin
				(this:c:setClassfileVersion ClassType:JDK_1_8_VERSION)
				(this:c:setSuper Type:javalangObjectType)
				(define args (c:getTypeParameters))
				(if (!= args null)
					(begin
						(set this:tvs (HashMap{String TypeVariable}))
						(define i 0)
						(while (!= i (alen args))
							(define tv Type (aget args i))
							(if (instance? tv TypeVariable)
								(this:tvs:put (tv:getName) (as TypeVariable tv))
							)
							(set i (+ i 1))
						)
					)
				)
			)
		)
	)
	((<init> name String fs FileScope) void 'public
		(this:<init> (ClassType name) fs)
	)
	((getClassfile) byte[]
		(if (= this:classfile null)
			(set this:classfile (this:c:writeToArray))
		)
		this:classfile
	)
	((addToClassLoader cl ArrayClassLoader) void 'public
		(cl:addClass (this:c:getName) (this:getClassfile))
		(forEach anon this:anonClasses
			(anon:addToClassLoader cl)
		)
	)
	((getClazz cl ArrayClassLoader) Class 'public
		(define c Class null)
		(try (set c (cl:loadClass (this:c:getName))) (e ClassNotFoundException (throw (RuntimeException e))))
		c
	)
	((getClazz) Class 'public
		(if (= this:rc null)
			(begin
				(define cl (ArrayClassLoader))
				(this:addToClassLoader cl)
				(set this:rc (this:getClazz cl))
			)
		)
		this:rc
	)
	((writeFiles dir String) void 'public
		(define pre (concat dir "/" (this:fs:package_:replace "." "/")))
		((File pre):mkdirs)
		(try
			(org.apache.commons.io.FileUtils:writeByteArrayToFile (File (concat pre (this:c:getSimpleName) ".class")) (this:getClassfile))
			(e IOException (throw (RuntimeException e)))
		)
		(forEach anon this:anonClasses
			(anon:writeFiles dir)
		)
	)
	((getType name String) Type
		(define abs (name:contains "."))
		(cond
			((&& (!= this:tvs null) (this:tvs:containsKey name))
				(this:tvs:get name)
			)
			((Main:constTypes:containsKey name)
				(Main:constTypes:get name)
			)
			((this:fs:locals:containsKey name)
				(this:fs:locals:get name)
			)
			((&& (! abs) (this:fs:locals:containsKey (this:fs:package_:concat name)))
				(this:fs:locals:get (this:fs:package_:concat name))
			)
			((this:fs:imports:containsKey name)
				(define fullName (this:fs:imports:get name))
				(if (this:fs:locals:containsKey fullName)
					(this:fs:locals:get fullName)
					(if (this:fs:classExists fullName)
						(Type:getType fullName)
						(throw (RuntimeException))
					)
				)
			)
			(true
				(define type Type null)
				(define i 0)
				(while (&& (! abs) (= type null) (!= i (this:fs:starImports:size)))
					(define fullName ((this:fs:starImports:get i):concat name))
					(if (this:fs:locals:containsKey fullName)
						(set type (this:fs:locals:get fullName))
						(if (this:fs:classExists fullName)
							(set type (Type:getType fullName))
						)
					)
					(set i (+ i 1))
				)
				(if (&& (= type null) (this:fs:classExists name))
					(Type:getType name)
					type
				)
			)
		)
	)
	((getType tok Token) Type
		(instanceCond tok
			(GenericToken
				(define c ClassType ((this:getType (as VToken (tok:toks:get 0)):val):getRawType))
				(define params (tok:toks:subList 1 (tok:toks:size)))
				(define tparams (Type[] len:(params:size)))
				(define i 0)
				(while (!= i (params:size))
					(aset tparams i (this:getType (params:get i)))
					(set i (+ i 1))
				)
				(ParameterizedType c tparams)
			)
			(ArrayToken
				(ArrayType (this:getType (tok:toks:get 0)))
			)
			(VToken
				(this:getType tok:val)
			)
			(true null)
		)
	)
	((compileDef tok LexedParsedToken) void 'public
		(if (instance? tok BlockToken)
			(begin
				(define first (tok:toks:get 0))
				(if (instance? first BlockToken) ;method definition
					(begin
						(define scope (LinkedHashMap))
						(define mods 0)
						(define end false)
						(define i 2)
						(while (! (|| end (= i (tok:toks:size))))
							(define mod (tok:toks:get i))
							(if (instance? mod SingleQuoteToken)
								(begin
									(set mods (| mods (Main:accessModifiers:get (as VToken (mod:toks:get 0)):val)))
									(set i (+ i 1))
								)
								(set end true)
							)
						)
						(define n
							(if (= (& mods Access:STATIC) 0)
								1
								0
							)
						)
						(define types (Main:getParams this first scope 1 n))
						(this:addMethod (as VToken (first:toks:get 0)):val types (this:getType (tok:toks:get 1)) mods (tok:toks:subList i (tok:toks:size)) scope)
					)
					(begin
						(define name (as VToken first):val)
						(if (! (name:endsWith "!"))
							(begin ;field definition
								(define mods 0)
								(define end false)
								(define i 2)
								(while (! (|| (= i (tok:toks:size)) end))
									(define mod (tok:toks:get i))
									(if (instance? mod SingleQuoteToken)
										(begin
											(define nmod (Main:accessModifiers:get (as VToken (mod:toks:get 0)):val))
											(set mods (| mods nmod))
										)
										(set end true)
									)
									(set i (+ i 1))
								)
								(define t (this:getType (tok:toks:get 1)))
								(this:c:addField name t mods)
							)
						)
					)
				)
			)
		)
	)
	((compileDefs) void
		(define c this:c)
		(define supers (this:toks:get 2):toks)
		(forEach super supers
			(define related Type (this:getType super))
			(if (related:isInterface)
				(c:addInterface related)
				(c:setSuper related)
			)
		)
		(define i 3)
		(while (!= i (this:toks:size))
			(this:compileDef (this:toks:get i))
			(inc i)
		)
	)
	((compileMethods h GenHandler) void 'public
		(define i 0)
		(while (!= i (this:methods:size))
			(define mi (this:methods:get i))
			(mi:compileMethodBody h)
			(set i (+ i 1))
		)
	)
	((runMethodMacros) void
		(define i 3)
		(while (!= i (this:toks:size))
			(define tok (this:toks:get i))
			(if
				(&&
					(instance? tok BlockToken)
					(instance? (tok:toks:get 0) VToken)
					((as VToken (tok:toks:get 0)):val:endsWith "!")
				)
				(this:runMethodMacro (as BlockToken tok))
			)
			(inc i)
		)
	)
	((runMethodMacro tok BlockToken) void
		(define name (as VToken (tok:toks:get 0)):val)
		(set name (name:substring 0 (- (name:length) 1)))
		(define o 1)
		(define l (- (tok:toks:size) 1))
		(define types (Type[] len:(+ o l) (Main:getCompilerType "ClassInfo")))
		(define j 0)
		(while (!= j l)
			(aset types (+ o j) (Main:getCompilerType "tokens.LexedParsedToken"))
			(set j (+ j 1))
		)
		(define method Method null)
		(define ci ClassInfo null)
		(define i 0)
		(while (= method null)
			(set ci ((this:fs:methodMacroNames:get name):get i))
			(define filter (MFilter name types ci:c))
			(filter:searchDeclared)
			(set method (filter:getMethod))
			(set i (+ i 1))
		)
		(ci:compileMethods GenHandler:inst)
		(define params (method:getGenericParameterTypes))
		(define classes (Class[] len:(alen params)))
		(set j 0)
		(while (!= j (alen params))
			(aset classes j ((aget params j):getReflectClass))
			(set j (+ j 1))
		)
		(define args (ArrayList (Arrays:asList (Object[] this))))
		(args:addAll
			(if (&& (> (alen params) 0) (instance? (aget params (- (alen params) 1)) ArrayType))
				(begin
					(define var (- (alen params) o))
					(define al (ArrayList (tok:toks:subList 1 var)))
					(define out (LexedParsedToken[] len:(- (tok:toks:size) var)))
					((tok:toks:subList var (tok:toks:size)):toArray out)
					(al:add out)
					al
				)
				(tok:toks:subList 1 (tok:toks:size))
			)
		)
		(try
			(((ci:getClazz):getMethod name classes):invoke null (args:toArray))
			(e NoSuchMethodException (throw (RuntimeException e)))
			(e IllegalAccessException (throw (RuntimeException e)))
			(e java.lang.reflect.InvocationTargetException (throw (RuntimeException e)))
		)
	)
	((addMethod name String params List{Type} ret Type mods int toks List{LexedParsedToken} scope LinkedHashMap) AMethodInfo 'public
		(define atypes (Type[] len:(params:size)))
		(params:toArray atypes)
		(define method (this:c:addMethod name atypes ret mods))
		(define out (MethodInfo this toks method scope))
		(this:methods:add out)
		out
	)
	((addMethod name String ret Type mods int toks List{LexedParsedToken} scope LinkedHashMap{String Arg}) AMethodInfo 'public
		(define params (ArrayList{Type}))
		(forEach arg (scope:values)
			(params:add arg:type)
		)
		(this:addMethod name params ret mods toks scope)
	)
)

(define-class MacroInfo (ClassInfo) 'public
	((<init> name String fs FileScope) void
		(super:<init> name fs)
	)
	((getType name String) Type
		(if (name:startsWith "sjava.compiler.")
			(Type:getType name)
			(super:getType name)
		)
	)
)

(define-class MethodMacroInfo (MacroInfo) 'public
	((<init> name String fs FileScope) void
		(super:<init> name fs)
	)
)

(define-class AMethodInfo () 'public
	(ci ClassInfo 'public)
	(block BeginToken 'public)
	(method Method 'public)
	(scopes ArrayList{ArrayDeque{Map{String AVar}}} 'public)
	(firstScope Map{String AVar})
	(labels ArrayDeque{Map})
	(compiled bool)
	((<init> ci ClassInfo toks List{LexedParsedToken} method Method firstScope LinkedHashMap{String AVar}) void
		(super:<init>)
		(set this:ci ci)
		(if (!= (toks:size) 0)
			(set this:block (Main:transformBlockToks (BeginToken (toks:get 0):line (ArrayList{Token} toks)) this))
		)
		(set this:method method)
		(set this:scopes (ArrayList))
		(define h (ArrayDeque))
		(this:scopes:add h)
		(set this:firstScope firstScope)
		(set this:labels (ArrayDeque))
		(set this:compiled false)
	)
	((pushScope code CodeAttr label Map) void 'public
		(define output (!= code null))
		(define i 0)
		(while (!= i (this:scopes:size))
			((this:scopes:get i):push (HashMap))
			(set i (+ i 1))
		)
		(this:labels:push label)
		;(if output (code:pushScope))
	)
	((popScope code CodeAttr) void 'public
		(define output (!= code null))
		(define i 0)
		(while (!= i (this:scopes:size))
			((this:scopes:get i):pop)
			(set i (+ i 1))
		)
		(this:labels:pop)
		;(if output (code:popScope))
	)
	((pushLevel) void 'public
		(this:scopes:add (ArrayDeque))
	)
	((popLevel) void 'public
		(this:scopes:remove (- (this:scopes:size) 1))
	)
	((getVar tok VToken) AVar 'public
		(define scopes (this:scopes:get tok:macro))
		(define found AVar null)
		(define it (scopes:iterator))
		(while (&& (it:hasNext) (= found null))
			(define vars (it:next))
			(if (vars:containsKey tok:val)
				(set found (vars:get tok:val))
			)
		)
		(if (= found null) (this:firstScope:get tok:val) found)
	)
	((getLabel name String) Label 'public
		(define found Label null)
		(define it Iterator (this:labels:iterator))
		(while (&& (it:hasNext) (= found null))
			(define vars HashMap (it:next))
			(if (vars:containsKey name)
				(set found (vars:get name))
			)
		)
		found
	)
	((newVar code CodeAttr tok VToken type Type) Variable 'public
		(define output (!= code null))
		(define name tok:val)
		(define var Variable (if output (code:addLocal (type:getRawType) name) null))
		((as HashMap ((this:scopes:get tok:macro):getFirst)):put name (Var var type))
		var
	)
	((getType tok Token) Type 'public
		(this:ci:getType tok)
	)
	((compileMethodBody h GenHandler) void 'public
		(if (&& (! this:compiled) (! (this:method:isAbstract)))
			(begin
				(h:compile this:block this null (this:method:getReturnType))

				(define filter (BridgeFilter this:method))
				(filter:searchAll)

				(define code (this:method:startCode))
				(define paramNames (this:firstScope:keySet))
				(define o (if (= (& (this:method:getModifiers) Access:STATIC) 0) 1 0))
				(forEachI paramName paramNames i
					((code:getArg (+ o i)):setName paramName)
				)
				(define ret (h:compile this:block this code (this:method:getReturnType)))
				(code:popScope)

				(if (code:reachableHere)
					(code:emitReturn)
				)
				(set this:compiled true)
			)
		)
	)
	((compileMethodBody) void
		(this:compileMethodBody GenHandler:inst)
	)
	((toString) String 'public
		(concat (super:toString) ":" this:method)
	)
)

(define-class MethodInfo (AMethodInfo) 'public
	((<init> ci ClassInfo toks List{LexedParsedToken} method Method scope LinkedHashMap) void 'public
		(super:<init> ci toks method scope)
	)
)
