(package sjava.compiler)

(import sjava.compiler.mfilters.*)
(import sjava.compiler.emitters.*)
(import sjava.compiler.handlers.*)
(import sjava.compiler.tokens.*)
(import sjava.compiler.commands.*)

(import java.util.*)
(import java.io.*)
(import java.nio.file.*)
(import gnu.bytecode.*)
(import org.apache.commons.cli.*)

(define-class Main () 'public
	(ML int 'static) ;max length of a special token
	(MP int 'static) ;max precedence
	(precs String[][] 'static) ;precedence to special token array
	(s2prec HashMap{String Integer} 'static) ;special token to precedence
	(specialChars HashMap{String Character} 'static 'public)
	(unboxMethods HashMap{Type Method} 'static 'public)
	(constTypes HashMap{String Type} 'static)
	(accessModifiers HashMap{String Short} 'static)
	(binOps HashMap{String Integer} 'static 'public)
	(compare2Ops HashMap{String Integer} 'static)
	(compare1Ops HashMap{String Integer} 'static)
	(unknownType Type 'static 'public)
	(returnType Type 'static 'public)
	(throwType Type 'static 'public)
	(commands Map{String Command} 'static)
	((<clinit>) void 'static
		(set Main:unknownType (Type:getType "unknownType"))
		(set Main:returnType (Type:getType "returnType"))
		(set Main:throwType (Type:getType "throwType"))

		(set Main:unboxMethods (HashMap{Type Method}))
		(Main:unboxMethods:put (Type:shortType:boxedType) (Type:javalangNumberType:getDeclaredMethod "shortValue" 0))
		(Main:unboxMethods:put (Type:intType:boxedType) (Type:javalangNumberType:getDeclaredMethod "intValue" 0))
		(Main:unboxMethods:put (Type:longType:boxedType) (Type:javalangNumberType:getDeclaredMethod "longValue" 0))
		(Main:unboxMethods:put (Type:doubleType:boxedType) (Type:javalangNumberType:getDeclaredMethod "doubleValue" 0))
		(Main:unboxMethods:put (Type:booleanType:boxedType) (Type:javalangBooleanType:getDeclaredMethod "booleanValue" 0))
		(Main:unboxMethods:put (Type:charType:boxedType) (Type:javalangCharacterType:getDeclaredMethod "charValue" 0))

		(set Main:constTypes (HashMap{String Type}))
		(Main:constTypes:put "bool" Type:booleanType)
		(Main:constTypes:put "byte" Type:byteType)
		(Main:constTypes:put "char" Type:charType)
		(Main:constTypes:put "double" Type:doubleType)
		(Main:constTypes:put "float" Type:floatType)
		(Main:constTypes:put "int" Type:intType)
		(Main:constTypes:put "long" Type:longType)
		(Main:constTypes:put "short" Type:shortType)
		(Main:constTypes:put "void" Type:voidType)

		(set Main:accessModifiers (HashMap{String Short}))
		(Main:accessModifiers:put "static" Access:STATIC)
		(Main:accessModifiers:put "public" Access:PUBLIC)
		(Main:accessModifiers:put "abstract" Access:ABSTRACT)
		(Main:accessModifiers:put "final" Access:FINAL)
		(Main:accessModifiers:put "private" Access:PRIVATE)
		(Main:accessModifiers:put "protected" Access:PROTECTED)
		(Main:accessModifiers:put "synchronized" Access:SYNCHRONIZED)
		(Main:accessModifiers:put "transient" Access:TRANSIENT)
		(Main:accessModifiers:put "volatile" Access:VOLATILE)
		(Main:accessModifiers:put "native" Access:NATIVE)
		(Main:accessModifiers:put "interface" Access:INTERFACE)
		(Main:accessModifiers:put "super" Access:SUPER)

		(set Main:binOps (HashMap{String Integer}))
		(Main:binOps:put "+" 96)
		(Main:binOps:put "-" 100)
		(Main:binOps:put "*" 104)
		(Main:binOps:put "/" 108)
		(Main:binOps:put "%" 112)
		(Main:binOps:put "&" 126)
		(Main:binOps:put "|" 128)
		(Main:binOps:put "^" 130)

		(set Main:compare2Ops (HashMap{String Integer}))
		;opposites
		(Main:compare2Ops:put "!=" 153)
		(Main:compare2Ops:put "=" 154)
		(Main:compare2Ops:put ">=" 155)
		(Main:compare2Ops:put "<" 156)
		(Main:compare2Ops:put "<=" 157)
		(Main:compare2Ops:put ">" 158)

		(set Main:compare1Ops (HashMap{String Integer}))
		;opposites
		(Main:compare1Ops:put "!=0" 153)
		(Main:compare1Ops:put "==0" 154)
		(Main:compare1Ops:put ">=0" 155)
		(Main:compare1Ops:put "<0" 156)
		(Main:compare1Ops:put "<=0" 157)
		(Main:compare1Ops:put ">0" 158)
		(Main:compare1Ops:put "!=null" 198)
		(Main:compare1Ops:put "==null" 199)

		(set Main:precs
			(String[][]
				(String[] "\"\"\"" "\"" ")" "}" ";")
				(String[] ":" "{")
				(String[] "(" "'" "," ",$" "`")
			)
		)

		(set Main:specialChars (HashMap{String Character}))
		(Main:specialChars:put "space" #\space)
		(Main:specialChars:put "singlequote" #\singlequote)
		(Main:specialChars:put "newline" #\newline)
		(Main:specialChars:put "lparen" #\lparen)
		(Main:specialChars:put "rparen" #\rparen)

		(set Main:MP (- (alen Main:precs) 1))

		(set Main:ML 3)

		(set Main:s2prec (HashMap{String Integer}))

		(forEachI a Main:precs i
			(forEach b a
				(Main:s2prec:put b i)
			)
		)
	)
	((addCommandToMap c Command) void 'static
		(Main:commands:put (c:name) c)
	)
	((main args String[]) void 'public 'static
		(set Main:commands (LinkedHashMap))
		(Main:addCommandToMap (BuildCommand))
		(Main:addCommandToMap (RunCommand))
		(Main:addCommandToMap (FormatCommand))
		(if (= (alen args) 0)
			(begin
				(Main:printHelp)
				(return)
			)
		)
		(define arg (aget args 0))
		(set args (Arrays:copyOfRange args 1 (alen args)))
		(if (Main:commands:containsKey arg)
			(try
				(begin
					(define cmd (Main:commands:get arg))
					(define commandLine (cmd:parser:parse cmd:options args))
					(if (commandLine:hasOption "h")
						(cmd:printHelp)
						(cmd:run commandLine (commandLine:getArgList))
					)
				)
				(e Throwable (e:printStackTrace))
			)
			(Main:printHelp)
		)
	)
	((printHelp) void 'static
		(println "usage: sjava [command] [arguments]")
		(println)
		(println "Commands:")
		(println)
		(forEach command (Main:commands:keySet)
			(println "\t" command)
		)
		(println)
	)
	((parse code String lexer Lexer parser Parser) List{Token} 'public 'static
		(parser:parseAll (lexer:lex code))
	)
	((formatCode code String) String 'public 'static
		(concat (Main:formatToks (Main:parse code (Lexer) (Parser false))) #\newline)
	)
	((compile fNames List{String}) Map{String FileScope} 'public 'static
		(define fileNames (ArrayList{String}))
		(define path (((((class Main):getProtectionDomain):getCodeSource):getLocation):getPath))
		(define pre
			(if (!= (System:getProperty "sjava.home") null)
				(System:getProperty "sjava.home")
				(if (path:endsWith ".jar")
					((File path):getParent)
					"."
				)
			)
		)
		(fileNames:add (concat pre "/std/macros.sjava"))
		(fileNames:addAll fNames)
		(define files (LinkedHashMap{String List{Token}}))

		(forEach name fileNames
			(define code String null)
			(try (set code (org.apache.commons.io.FileUtils:readFileToString (File name))) (e Throwable (throw (RuntimeException e))))
			(define formatted (Main:formatCode code))
			(if (! (code:equals formatted)) (println "Warning: " name " isn't formatted"))
			(files:put name (Main:parse code (Lexer) (Parser)))
		)
		(Main:compile files)
	)
	((compile files HashMap{String ArrayList{Token}}) Map{String FileScope} 'public 'static
		(define locals (HashMap))
		(define fileScopes (LinkedHashMap{String FileScope}))
		(define macroNames (HashMap{String ClassInfo}))

		(forEach entry (files:entrySet)
			(define toks (entry:getValue))
			(define fs (FileScope (entry:getKey) toks locals))
			(set fs:macroNames macroNames)
			(fileScopes:put (entry:getKey) fs)
			(fs:compileRoot)
		)

		(forEach entry (fileScopes:entrySet)
			(define fs (entry:getValue))
			(fs:compileDefs)
		)

		(forEach entry (fileScopes:entrySet)
			(define fs (entry:getValue))
			(fs:compileMacros)
		)

		(forEach entry (fileScopes:entrySet)
			(define fs (entry:getValue))
			(fs:compileIncludes)
		)

		(forEach entry (fileScopes:entrySet)
			(define fs (entry:getValue))
			(fs:compileMethods GenHandler:inst)
			;(forEach ci fs:newClasses
			;	(define h (JavaHandler))
			;	(set h:buf (StringBuffer))
			;	(if (! (fs:package_:equals ""))
			;		(begin
			;			(h:buf:append "package ")
			;			(h:buf:append (fs:package_:substring 0 (- (fs:package_:length) 1)))
			;			(h:buf:append ";\n")
			;		)
			;	)
			;	(h:buf:append (Access:toString (ci:c:getModifiers)))
			;	(h:buf:append #\space)
			;	(h:buf:append "class ")
			;	(h:buf:append (ci:c:getSimpleName))
			;	(h:buf:append " {\n")
			;	(define field (ci:c:getFields))
			;	(while (!= field null)
			;		(h:buf:append ((field:getType):getName))
			;		(h:buf:append #\space)
			;		(h:buf:append (field:getName))
			;		(h:buf:append ";\n")
			;		(set field (field:getNext))
			;	)
			;	(forEach mi ci:methods
			;		(h:newMethod)
			;		(define m mi:method)
			;		(h:buf:append (Access:toString (m:getModifiers)))
			;		(h:buf:append #\space)
			;		(if ((m:getName):equals "<init>")
			;			(begin
			;				(h:buf:append (ci:c:getSimpleName))
			;			)
			;			(begin
			;				(h:buf:append ((m:getReturnType):getName))
			;				(h:buf:append #\space)
			;				(h:buf:append (m:getName))
			;			)
			;		)
			;		(h:buf:append "(")
			;		(define i 0)
			;		(define paramNames ((((mi:scopes:get 0):getFirst):keySet):toArray))
			;		(define off (if (= (& (m:getModifiers) Access:STATIC) 0) 1 0))
			;		(forEach param (m:getGenericParameterTypes)
			;			(h:buf:append (param:getName))
			;			(h:buf:append " ")
			;			(h:buf:append (aget paramNames (+ off i)))
			;			(inc i)
			;			(if (!= i (alen (m:getGenericParameterTypes)))
			;				(h:buf:append ", ")
			;			)
			;		)
			;		(h:buf:append ")")
			;		(h:buf:append " {\n")
			;		(mi:compileMethodBody h)
			;		(if (!= (m:getReturnType) Type:voidType)
			;			(h:buf:append "return $0;\n")
			;		)
			;		(h:buf:append "}\n")
			;	)
			;	(h:buf:append "}")
			;	(define javaFolder (concat (fs:name:substring 0 (fs:name:lastIndexOf "/")) "/java/"))
			;	((File javaFolder):mkdirs)
			;	(Files:write (Paths:get (concat javaFolder (ci:c:getSimpleName) ".java")) ((h:buf:toString):getBytes))
			;)
		)

		fileScopes
	)
	((resolveType map Map{TypeVariable Type} pt Type t Type) Type 'static 'public
		(cond
			((instance? t TypeVariable)
				(if (instance? pt ParameterizedType)
					(begin
						(define tvs ((as ClassType ((as ParameterizedType pt):getRawType)):getTypeParameters))
						(define s String ((as TypeVariable t):getName))
						(forEachI tv tvs i
							(if ((tv:getName):equals s)
								(return ((as ParameterizedType pt):getTypeArgumentType i))
							)
						)
						(t:getRawType)
					)
					(if (&& (!= map null) (map:containsKey (as TypeVariable t)))
						(map:get (as TypeVariable t))
						(t:getRawType)
					)
				)
			)
			((instance? t ArrayType)
				(ArrayType (Main:resolveType map pt (as ArrayType t):elements))
			)
			((instance? t ParameterizedType)
				(begin
					(define types ((as ParameterizedType t):getTypeArgumentTypes))
					(define parameterized (Type[] len:(alen types)))
					(forEachI type types i
						(aset parameterized i (Main:resolveType map pt type))
					)
					(ParameterizedType (as ClassType (t:getRawType)) parameterized)
				)
			)
			(true
				t
			)
		)
	)
	((resolveType pt Type t Type) Type 'static 'public
		(Main:resolveType null pt t)
	)
	((unresolveTv tv TypeVariable generic Type real Type) Type 'static
		(cond
			((instance? generic TypeVariable)
				(if (tv:equals generic)
					(Main:tryBox real)
					null
				)
			)
			(
				(&&
					(instance? generic ParameterizedType)
					(instance? real ParameterizedType)
					((generic:getRawType):equals (real:getRawType))
				)
				(begin
					(define gtypes ((as ParameterizedType generic):getTypeArgumentTypes))
					(define rtypes ((as ParameterizedType real):getTypeArgumentTypes))
					(define i 0)
					(while (< i (alen gtypes))
						(define ret (Main:unresolveTv tv (aget gtypes i) (aget rtypes i)))
						(if (!= ret null)
							(return ret)
						)
						(set i (+ i 1))
					)
					null
				)
			)
			((&& (instance? generic ArrayType) (instance? real ArrayType))
				(Main:unresolveTv tv (as ArrayType generic):elements (as ArrayType real):elements)
			)
			(true
				null
			)
		)
	)
	((unresolveTvs tvs TypeVariable[] generics Type[] reals Type[]) Map{TypeVariable Type} 'static 'public
		(if (|| (= tvs null) (!= (alen generics) (alen reals)))
			null
			(begin
				(define out (HashMap{TypeVariable Type}))
				(forEach tv tvs
					(define j 0)
					(define t Type null)
					(while (&& (= t null) (!= j (alen generics)))
						(set t (Main:unresolveTv tv (aget generics j) (aget reals j)))
						(set j (+ j 1))
					)
					(out:put tv t)
				)
				out
			)
		)
	)
	((arrayDim t Type) int 'static 'public
		(define out 0)
		(while (instance? t ArrayType)
			(set t (as ArrayType t):elements)
			(set out (+ out 1))
		)
		out
	)
	((compileClassMod tok Token c ClassType) bool 'static
		(if (instance? tok SingleQuoteToken)
			(begin
				(define nmod int (Main:accessModifiers:get (as VToken (tok:toks:get 0)):val))
				(c:addModifiers nmod)
				true
			)
			false
		)
	)
	((getParams ci ClassInfo tok Token scope LinkedHashMap i int n int) Type[] 'static 'public
		(define types (Type[] len:(/ (- (tok:toks:size) i) 2)))
		(define j 0)
		(while (!= j (alen types))
			(define type (ci:getType (tok:toks:get (+ (* j 2) i 1))))
			(aset types j type)
			(scope:put (as VToken (tok:toks:get (+ (* j 2) i))):val (Arg (+ n j) type))
			(set j (+ j 1))
		)
		types
	)
	((transformBlockTok block Token mi AMethodInfo transform bool i int) Token 'public 'static
		(define tok (block:toks:get i))
		(define ntok
			(Main:transformBlock tok mi
				(||
					(&&
						transform
						(! block:neverTransform)
					)
					block:alwaysTransform
				)
			)
		)
		(if transform (set ntok:transformed true))
		(block:toks:set i ntok)
		(if (&& transform (instance? tok BlockToken) (> (tok:toks:size) 0) (instance? (tok:toks:get 0) VToken))
			(begin
				(define val (as VToken (tok:toks:get 0)):val)
				(if (val:equals "label")
					((as BlockToken block):labels:put (as VToken (tok:toks:get 1)):val (Label))
				)
			)
		)
		ntok
	)
	((transformBlockToks block Token mi AMethodInfo transform bool i int) Token 'public 'static
		(if (&& transform (instance? block BlockToken))
			(set (as BlockToken block):labels (HashMap))
		)
		(while (!= i (block:toks:size))
			(Main:transformBlockTok block mi transform i)
			(set i (+ i 1))
		)
		block
	)
	((transformBlockToks block Token mi AMethodInfo transform bool) Token 'public 'static
		(Main:transformBlockToks block mi transform 0)
	)
	((transformBlockToks block Token mi AMethodInfo) Token 'public 'static
		(Main:transformBlockToks block mi (! block:neverTransform))
	)
	((transformBlock block Token mi AMethodInfo transform bool) Token 'static
		(if (&& (!= block:toks null) (&& (! block:transformed) (! (instance? block Transformed))))
			(begin
				(cond
					;((instance? block ColonToken)
					;	(mi:getType (block:toks:get 0))
					;	(println block)
					;)
					((instance? block BlockToken)
						(cond
							((= (block:toks:size) 0)
								(if transform (return (EmptyToken block:line block:toks)))
							)
							(true
								(cond
									((instance? (block:toks:get 0) VToken)
										(define val (as VToken (block:toks:get 0)):val)
										(cond
											((val:equals "quote")
												(return (QuoteToken block:line (block:toks:subList 1 (block:toks:size))))
											)
											((val:equals "unquote")
												(return (UnquoteToken block:line (block:toks:subList 1 (block:toks:size)) false))
											)
											((val:equals "varunquote")
												(return (UnquoteToken block:line (block:toks:subList 1 (block:toks:size)) true))
											)
										)
										(if transform
											(cond
												((val:equals "object")
													(return (ObjectToken block:line block:toks))
												)
												((val:equals "lambda")
													(return (LambdaToken block:line block:toks))
												)
												((mi:ci:fs:macroNames:containsKey val)
													(return (MacroCallToken block:line block:toks))
												)
												((val:equals "begin")
													(if (= (block:toks:size) 2)
														(return (Main:transformBlock (block:toks:get 1) mi))
														(return (Main:transformBlockToks (BeginToken block:line block:toks) mi))
													)
												)
												((val:equals "label")
													(return (LabelToken block:line block:toks))
												)
												((val:equals "goto")
													(return (GotoToken block:line block:toks))
												)
												((val:equals "define")
													(return (Main:transformBlockToks (DefineToken block:line block:toks) mi))
												)
												((val:equals "try")
													(return (Main:transformBlockToks (TryToken block:line block:toks) mi))
												)
												((val:equals "instance?")
													(return (Main:transformBlockToks (InstanceToken block:line block:toks) mi))
												)
												((val:equals "set")
													(return (Main:transformBlockToks (SetToken block:line block:toks) mi))
												)
												((val:equals "aset")
													(return (Main:transformBlockToks (ASetToken block:line block:toks) mi))
												)
												((val:equals "aget")
													(return (Main:transformBlockToks (AGetToken block:line block:toks) mi))
												)
												((val:equals "alen")
													(return (Main:transformBlockToks (ALenToken block:line block:toks) mi))
												)
												((val:equals "as")
													(return (Main:transformBlockToks (AsToken block:line block:toks) mi))
												)
												((Main:binOps:containsKey val)
													(return (Main:transformBlockToks (BinOpToken block:line block:toks) mi))
												)
												((val:equals "if")
													(return (Main:transformBlockToks (IfToken block:line block:toks) mi))
												)
												((val:equals "while")
													(return (Main:transformBlockToks (WhileToken block:line block:toks) mi))
												)
												((Main:isCompare val)
													(return (Main:transformBlockToks (CompareToken block:line block:toks) mi))
												)
												((val:equals "throw")
													(return (Main:transformBlockToks (ThrowToken block:line block:toks) mi))
												)
												((val:equals "class")
													(return (Main:transformBlockToks (ClassToken block:line block:toks) mi))
												)
												((val:equals "synchronized")
													(return (Main:transformBlockToks (SynchronizedToken block:line block:toks) mi))
												)
												((val:equals "type")
													(return (Main:transformBlockToks (TypeToken block:line block:toks) mi))
												)
												((val:equals "return")
													(return (Main:transformBlockToks (ReturnToken block:line block:toks) mi))
												)
											)
										)
									)
									((&& transform (instance? (block:toks:get 0) ColonToken))
										(begin
											(define out (CallToken block:line block:toks))
											(Main:transformBlockTok (out:toks:get 0) mi true 0)
											(Main:transformBlockToks out mi true 1)
											(return out)
										)
									)
								)
								(if transform (return (Main:transformBlockToks (DefaultToken block:line block:toks) mi)))
							)
						)
					)
				)
				(Main:transformBlockToks block mi transform)
			)
		)
		block
	)
	((transformBlock block Token mi AMethodInfo) Token 'static 'public
		(Main:transformBlock block mi (! block:neverTransform))
	)
	((numericOpType types Type[]) Type 'static 'public
		(define l (Arrays:asList types))
		(cond
			((|| (l:contains Type:doubleType) (l:contains (ClassType:make "java.lang.Double")))
				Type:doubleType
			)
			((|| (l:contains Type:longType) (l:contains (ClassType:make "java.lang.Long")))
				Type:longType
			)
			(true Type:intType)
		)
	)
	((allNumeric types Type[]) bool 'static 'public
		(define i 0)
		(while (!= i (alen types))
			(define t (Main:tryUnbox (aget types i)))
			(if (! (instance? t PrimType))
				(return false)
			)
			(set i (+ i 1))
		)
		true
	)
	((tryBox t Type) Type 'static 'public
		(if (instance? t PrimType)
			((as PrimType t):boxedType)
			t
		)
	)
	((tryUnbox t Type) Type 'static 'public
		(define o (PrimType:unboxedType t))
		(if (= o null)
			t
			o
		)
	)
	((isCompare s String) bool 'static 'public
		(|| (s:equals "!") (s:equals "&&") (s:equals "||") (Main:compare1Ops:containsKey s) (Main:compare2Ops:containsKey s))
	)
	((invertComp inv bool n int) int 'static
		(if inv
			(if (& n 1) (+ n 1) (- n 1))
			n
		)
	)
	((emitInvoke h GenHandler name String type Type emitter Emitters mi AMethodInfo code CodeAttr needed Type special bool) Type 'static 'public
		(define output (!= code null))
		(define types (emitter:emitAll h mi null Main:unknownType))
		;(System:out:println name)
		;(System:out:println type)
		;(System:out:println (Arrays:toString types))
		(define filter (MFilter name types type))
		(if special
			(filter:searchDeclared)
			(filter:searchAll)
		)
		(define mc (filter:getMethodCall))
		(define method mc:m)
		;(System:out:println method)
		(define typeParameters (method:getTypeParameters))
		(define params (method:getGenericParameterTypes))
		(define varargs (!= (& (method:getModifiers) Access:TRANSIENT) 0))
		(begin
			(define j 0)
			(define n
				(if
					(&&
						varargs
						(||
							(< (alen types) (alen params))
							(!= (Main:arrayDim (aget params (- (alen params) 1))) (Main:arrayDim (aget types (- (alen params) 1))))
						)
					)
					1
					0
				)
			)
			(while (!= j (- (alen params) n))
				((emitter:emitters:get j):emit h mi code (Main:resolveType mc:tvs mc:t (aget params j)))
				(set j (+ j 1))
			)
			(if (= n 1)
				(begin
					(define at ArrayType (aget params (- (alen params) 1)))
					(define et (Main:resolveType mc:tvs mc:t at:elements))
					(if output (code:emitPushInt (+ 1 (- (alen types) (alen params)))))
					(if output (code:emitNewArray (at:elements:getRawType)))
					(define oj j)
					(while (!= j (alen types))
						(if output (code:emitDup))
						(if output (code:emitPushInt (- j oj)))
						((emitter:emitters:get j):emit h mi code et)
						(if output (code:emitArrayStore))
						(set j (+ j 1))
					)
				)
			)
		)
		(if special
			(if output (code:emitInvokeSpecial method))
			(if output (code:emitInvoke method))
		)
		(define out (Main:resolveType mc:tvs mc:t (method:getReturnType)))
		(if (&& (!= out Type:voidType) (!= needed Type:voidType))
			(if output (code:emitCheckcast (out:getRawType)))
		)
		(h:castMaybe out needed)
	)
	((emitInvoke h GenHandler name String type Type emitter Emitters mi AMethodInfo code CodeAttr needed Type) Type 'static 'public
		(Main:emitInvoke h name type emitter mi code needed false)
	)
	((compareType types Type[]) Type 'static
		(if (Main:allNumeric types)
			(Main:numericOpType types)
			Type:objectType
		)
	)
	;tok = condition
	((emitIf_ h GenHandler inv bool tok Token i int e int compare String trueE Emitter falseE Emitter mi AMethodInfo code CodeAttr needed Type) Type 'static 'public
		(define output (!= code null))
		(if (compare:equals "!")
			(begin
				(Main:emitIf h (! inv) tok i trueE falseE mi code needed)
			)
			(if (|| (&& (! inv) (compare:equals "&&")) (&& inv (compare:equals "||")))
				(begin
					(define skipL (Label))
					(define falseL (Label))
					(define falseG (Goto falseL))
					(define i 1)
					(while (!= i (- e 1))
						(Main:emitIf h inv tok i Nothing:inst falseG mi code needed)
						(set i (+ i 1))
					)
					(Main:emitIf h inv tok (- e 1) (Emitters (Emitter[] trueE (Goto skipL))) null mi code needed)
					(if output (falseL:define code))
					(if (!= falseE null)
						(begin
							(falseE:emit h mi code needed)
						)
					)
					(if output (skipL:define code))
					(trueE:emit h mi null needed)
				)
				(if (|| (&& (! inv) (compare:equals "||")) (&& inv (compare:equals "&&")))
					(begin
						(define skipL (Label))
						(define trueL (Label))
						(define trueG (Goto trueL))
						(define i 1)
						(while (!= i (- e 1))
							(Main:emitIf h (! inv) tok i Nothing:inst trueG mi code needed)
							(set i (+ i 1))
						)
						(Main:emitIf h (! inv) tok (- e 1) (Emitters (Emitter[] falseE (Goto skipL))) null mi code needed)
						(if output (trueL:define code))
						(define type (trueE:emit h mi code needed))
						(if output (skipL:define code))
						type
					)
					(begin
						(define falseLabel (instance? falseE Goto))
						(define skip (Label))
						(define label
							(if falseLabel
								(as Goto falseE):label
								skip
							)
						)
						(if (Main:compare1Ops:containsKey compare)
							(begin
								(define j i)
								(while (!= j e)
									(define types (h:compileAll tok:toks j (+ j 1) mi null Main:unknownType))
									(define otype (Main:compareType types))
									(h:compileAll tok:toks j (+ j 1) mi code otype)
									(if output (code:emitGotoIfCompare1 label (Main:invertComp inv (Main:compare1Ops:get compare))))
									(set j (+ j 1))
								)
							)
							(begin
								(define j i)
								(while (!= (+ j 1) e)
									(define types (h:compileAll tok:toks j (+ j 2) mi null Main:unknownType))
									(define otype (Main:compareType types))
									(h:compileAll tok:toks j (+ j 2) mi code otype)
									(if output (code:emitGotoIfCompare2 label (Main:invertComp inv (Main:compare2Ops:get compare))))
									(set j (+ j 1))
								)
							)
						)
						(define type (trueE:emit h mi code needed))
						(if (! falseLabel)
							(begin
								(define end (Label))
								(if (&& (! (instance? trueE Nothing)) (!= falseE null))
									(if (&& output (code:reachableHere)) (code:emitGoto end))
								)
								(if output (skip:define code))
								(if (! (= falseE null))
									(begin
										(falseE:emit h mi code needed)
										(if output (end:define code))
									)
								)
							)
						)
						type
					)
				)
			)
		)
	)
	((emitIf h GenHandler inv bool tok Token i int trueE Emitter falseE Emitter mi AMethodInfo code CodeAttr needed Type) Type 'static 'public
		(define cond (tok:toks:get i))
		(if (instance? cond CompareToken)
			(Main:emitIf_ h inv cond 1 (cond:toks:size) (as VToken (cond:toks:get 0)):val trueE falseE mi code needed)
			(Main:emitIf_ h inv tok i (+ i 1) "!=0" trueE falseE mi code needed)
		)
	)
	((generateBridgeMethod target Method params Type[] ret Type) void 'static 'public
		(define c (target:getDeclaringClass))
		(define rparams (Type[] len:(alen params)))
		(define i 0)
		(while (!= i (alen params))
			(aset rparams i ((aget params i):getRawType))
			(set i (+ i 1))
		)
		(define found (c:getDeclaredMethod (target:getName) rparams))
		(if (|| (= found null) (! (Type:isSame (found:getReturnType) ret)))
			(begin
				(define m (c:addMethod (target:getName) rparams (ret:getRawType) (| Access:PUBLIC Access:BRIDGE Access:SYNTHETIC)))
				(define code (m:startCode))
				(define i 0)
				(code:emitPushThis)
				(while (!= i (alen rparams))
					(code:emitLoad (code:getArg (+ i 1)))
					(GenHandler:castMaybe code (aget rparams i) (aget (target:getGenericParameterTypes) i))
					(set i (+ i 1))
				)
				(code:emitInvoke target)
				(GenHandler:castMaybe code (target:getReturnType) (ret:getRawType))
				(code:emitReturn)
			)
		)
	)
	((getCompilerType name String) ClassType 'static 'public
		(ClassType:make (concat "sjava.compiler." name))
	)
	((formatTok tok Token line int toLine int tabs int sb StringBuffer) int 'static
		(repeat (- toLine line) (sb:append "\n"))
		(if (!= toLine line) (repeat tabs (sb:append "\t")))
		(set line tok:line)
		(instanceCond tok
			(BlockToken
				(set line (Main:formatToks tok tabs "(" ")" sb))
			)
			(GenericToken
				(set line (Main:formatTok tok:tok line line tabs sb))
				(set line (Main:formatToks tok tabs "{" "}" sb))
			)
			(ColonToken
				(set line (Main:formatTok (tok:toks:get 0) line line tabs sb))
				(sb:append ":")
				(set line (Main:formatTok (tok:toks:get 1) line line tabs sb))
			)
			(SingleQuoteToken
				(sb:append "'")
				(set line (Main:formatTok (tok:toks:get 0) line line tabs sb))
			)
			(QuoteToken
				(sb:append "`")
				(set line (Main:formatTok (tok:toks:get 0) line line tabs sb))
			)
			(UnquoteToken
				(sb:append (if tok:var ",$" ","))
				(set line (Main:formatTok (tok:toks:get 0) line line tabs sb))
			)
			(CommentToken
				(sb:append ";")
				(sb:append tok:val)
			)
			(true
				(sb:append (tok:toString))
			)
		)
		tok:endLine
	)
	((formatToks block Token tabs int before String after String sb StringBuffer) int 'static
		(sb:append before)
		(define line 0)
		(define cont true)
		(forEachI tok block:toks i
			(define indent false)
			(define toLine tok:line)
			(define multiline (!= (tok:firstLine) (tok:lastLine)))
			(if (= i 0)
				(if multiline
					(begin
						(set toLine (+ line 1))
						(set indent true)
					)
					(set toLine line)
				)
				(if (&& (= tok:line line) multiline)
					(begin
						(set toLine (+ tok:line 1))
						(set indent true)
					)
					(begin
						(if (= tok:line line) (sb:append " "))
						(set indent (!= tok:line block:line))
					)
				)
			)
			(set line (Main:formatTok tok line toLine (+ tabs (if indent 1 0)) sb))
		)
		(if (!= (block:firstLine) (block:lastLine))
			(begin
				(sb:append "\n")
				(repeat tabs (sb:append "\t"))
			)
		)
		(sb:append after)
		(set line block:endLine)
		line
	)
	((formatToks toks List{Token}) String 'static
		(define sb (StringBuffer))
		(define line (if (!= (toks:size) 0) (toks:get 0):line 1))
		(forEachI tok toks i
			(define off (if (&& (= tok:line line) (!= i 0)) 1 0))
			(set line (Main:formatTok tok line (+ tok:line off) 0 sb))
		)
		(sb:toString)
	)
)

(define-class Tester () 'public
	((main args String[]) void 'public 'static
		(try
			(begin
				(define dir (File "examples/"))
				(define fileFilter Object (org.apache.commons.io.filefilter.WildcardFileFilter "*.expected.txt"))
				(define files (dir:listFiles (as FileFilter fileFilter)))
				(System:setProperty "line.separator" "\n")
				(forEach file files
					(define fname (file:getName))
					(define name (fname:substring 0 (fname:indexOf ".")))
					(define c (Class:forName (concat "examples." name ".Main")))
					(define baos (ByteArrayOutputStream))
					(define ps (PrintStream baos))
					(define old System:out)
					(System:setOut ps)
					((c:getMethod "main" (class String[])):invoke null null)
					(ps:flush)
					(System:setOut old)
					(define expected (org.apache.commons.io.FileUtils:readFileToString file))
					(define out (baos:toString))
					(define passed (out:equals expected))
					(println name ": " (if passed "PASSED" "FAILED"))
					(if (! passed) (return))
				)
			)
			(e Throwable (e:printStackTrace))
		)
	)
)

(define-class Lexer () 'public
	(code String)
	(i int)
	(ml int)
	(s String)
	(line int)
	((<init>) void 'public
		(super:<init>)
	)
	((getprec) int
		;check if code at i is a special token
		(define p -1)
		(define l Main:ML)
		(while (&& (= p -1) (!= l 0))
			(if (<= (+ this:i l) this:ml)
				(begin
					(set this:s (this:peek 0 l))
					(if (Main:s2prec:containsKey this:s)
						(set p (Main:s2prec:get this:s))
					)
				)
			)
			(set l (- l 1))
		)
		p
	)
	((peek n int l int) String
		(this:code:substring (+ this:i n) (+ this:i n l))
	)
	((peek n int) char
		(this:code:charAt (+ this:i n))
	)
	((peek) char
		(this:peek 0)
	)
	((skip n int) void
		(for (define i 0) (< i n) (inc i)
			(if (= (this:peek) #\newline)
				(inc this:line)
			)
			(inc this:i)
		)
	)
	((skip) void
		(this:skip 1)
	)
	((nextTok) void
		(while (&& (!= this:i this:ml) (= (this:getprec) -1) (! (Character:isWhitespace (this:peek))))
			(this:skip 1)
		)
	)
	((token) Token
		(while (&& (!= this:i this:ml) (= (this:getprec) -1) (Character:isWhitespace (this:peek)))
			(this:skip 1)
		)
		(define p (this:getprec))
		(define oline this:line)
		(define out Token
			(if (= p -1)
				(begin
					(define c (if (= this:i this:ml) (as char 0) (this:peek)))
					(define oi this:i)
					(if (= c #\#)
						(begin
							(while (&& (!= (this:peek) #\space) (!= (this:peek) #\rparen))
								(this:skip 1)
							)
							(define schar (this:code:substring (+ oi 2) this:i))
							(CToken this:line
								(if (= (schar:length) 1)
									(schar:charAt 0)
									(Main:specialChars:get schar)
								)
							)
						)
						(if (|| (Character:isDigit c) (&& (= c #\-) (Character:isDigit (this:peek 1))))
							(begin
								(this:nextTok)
								(NToken this:line (this:code:substring oi this:i))
							)
							(begin
								(this:nextTok)
								(define s (this:code:substring oi this:i))
								(if (s:equals "")
									null
									(if (|| (s:equals "null") (s:equals "true") (s:equals "false"))
										(ConstToken this:line s)
										(VToken this:line s)
									)
								)
							)
						)
					)
				)
				(begin
					(this:skip (this:s:length))
					(define oi this:i)
					(if (this:s:equals "\"\"\"")
						(begin
							(while (! ((this:peek 0 3):equals "\"\"\""))
								(if ((this:peek 0 7):equals "\\\"\"\"\"\"\"")
									(this:skip 4)
									(if (|| ((this:peek 0 5):equals "\\\\\"\"\"") ((this:peek 0 5):equals "\\\"\"\"\""))
										(this:skip 2)
										(if ((this:peek 0 4):equals "\\\"\"\"")
											(this:skip 4)
											(this:skip)
										)
									)
								)
							)
							(define str ((this:code:substring oi this:i):replace "\\\"\"\"" "\"\"\""))
							(if (str:endsWith "\\\\")
								(set str (concat (str:substring 0 (- (str:length) 2)) "\\"))
								(if (str:endsWith "\\\"")
									(set str (concat (str:substring 0 (- (str:length) 2)) "\""))
								)
							)
							(this:skip 3)
							(SToken oline str true)
						)
						(if (this:s:equals "\"")
							(begin
								(while (!= (this:peek) #\")
									(if (= (this:peek) #\\)
										(this:skip 2)
										(this:skip)
									)
								)
								(this:skip)
								(SToken this:line (org.apache.commons.lang3.StringEscapeUtils:unescapeJava (this:code:substring oi (- this:i 1))) false)
							)
							(if (this:s:equals ";")
								(begin
									(while (&& (!= this:i this:ml) (!= (this:peek) #\newline))
										(this:skip)
									)
									(CommentToken this:line (this:code:substring oi this:i))
								)
								(Token this:line p this:s)
							)
						)
					)
				)
			)
		)
		(if (!= out null)
			(set out:endLine this:line)
		)
		out
	)
	((lex code String) List{Token}
		(set this:code code)
		(set this:i 0)
		(set this:ml (code:length))
		(set this:line 1)
		(define out (ArrayList{Token}))
		(while
			(!= this:i this:ml)
			(define tok (this:token))
			(if (!= tok null) (out:add tok))
		)
		out
	)
)

(define-class Parser () 'public
	(toks List{Token})
	(i int)
	(ignoreComments bool)
	((<init> ignoreComments bool) void 'public
		(super:<init>)
		(set this:ignoreComments ignoreComments)
	)
	((<init>) void 'public
		(this:<init> true)
	)
	((next) Token
		(define ret (this:toks:get this:i))
		(inc this:i)
		ret
	)
	((peek n int) Token
		(this:toks:get (+ this:i n))
	)
	((subToks end String) List{Token}
		(define toks (ArrayList{Token}))
		(while (! ((this:peek 0):what:equals end))
			(define t (this:parse 0))
			(if (!= t null) (toks:add t))
		)
		(this:next)
		toks
	)
	((parse prec int) Token
		(define t (this:next))
		(define w t:what)
		(define left Token
			(cond
				((w:equals "(")
					(BlockToken t:line (this:subToks ")"))
				)
				((|| (w:equals "'") (w:equals "`") (w:equals ",$") (w:equals ","))
					(define al (ArrayList (Arrays:asList (Object[] (this:parse 0)))))
					(if (|| (w:equals ",") (w:equals ",$"))
						(UnquoteToken t:line al (w:equals ",$"))
						(if (w:equals "'")
							(SingleQuoteToken t:line al)
							(QuoteToken t:line al)
						)
					)
				)
				((&& this:ignoreComments (instance? t CommentToken))
					(return null)
				)
				(true
					t
				)
			)
		)
		(if (= left:endLine 0) (set left:endLine (this:peek -1):line))
		(define cont true)
		(while (&& cont (!= this:i (this:toks:size)) (> (this:prec) prec))
			(define w (this:peek 0):what)
			(cond
				((w:equals ":")
					(this:next)
					(define right (this:parse 1))
					(set left (ColonToken t:line (ArrayList (Arrays:asList (Object[] left right)))))
				)
				((w:equals "{")
					(this:next)
					(set left (GenericToken t:line left (this:subToks "}")))
				)
				(true
					(set cont false)
				)
			)
			(if cont (set left:endLine (this:peek -1):line))
		)
		left
	)
	((prec) int
		(this:peek 0):prec
	)
	((parseAll toks List{Token}) List{Token}
		(set this:i 0)
		(set this:toks toks)
		(define out (ArrayList{Token}))
		(while (!= this:i (this:toks:size))
			(define t (this:parse 0))
			(if (!= t null) (out:add t))
		)
		out
	)
)

(define-class AVar () 'public
	(type Type 'public)
	((<init> type Type) void (super:<init>) (set this:type type))
	((load code CodeAttr) Type 'public this:type)
	((store code CodeAttr) void 'public ())
)

(define-class Var (AVar)
	(var Variable)
	((<init> var Variable type Type) void (super:<init> type) (set this:var var))
	((load code CodeAttr) Type 'public
		(define output (!= code null))
		(if output (code:emitLoad this:var))
		this:type
	)
	((store code CodeAttr) void 'public
		(define output (!= code null))
		(if output (code:emitStore this:var))
	)
)

(define-class Arg (AVar) 'public
	(n int)
	((<init> n int type Type) void 'public (super:<init> type) (set this:n n))
	((load code CodeAttr) Type 'public
		(define output (!= code null))
		(if output (code:emitLoad (code:getArg this:n)))
		(if output (code:emitCheckcast (this:type:getRawType)))
		this:type
	)
	((store code CodeAttr) void 'public
		(define output (!= code null))
		(if output (code:emitStore (code:getArg this:n)))
	)
)

(define-class VCaptured (AVar) 'public
	(field Field 'public)
	(avar AVar 'public)
	((<init> avar AVar field Field) void 'public
		(super:<init> avar:type)
		(set this:avar avar)
		(set this:field field)
	)
	((load code CodeAttr) Type 'public
		(define output (!= code null))
		(if output (code:emitPushThis))
		(if output (code:emitGetField this:field))
		this:type
	)
	((store code CodeAttr) void 'public
		(throw (RuntimeException))
	)
)

(define-class FileScope () 'public
	(name String 'public)
	(toks List{Token})
	(locals HashMap)
	(imports HashMap{String String})
	(starImports ArrayList{String})
	(found HashMap{String Boolean})
	(includes ClassInfo 'public)
	(newClasses List{ClassInfo} 'public)
	(package_ String)
	(macros ArrayList{ClassInfo})
	(macroNames HashMap{String List{ClassInfo}} 'public)
	((<init> name String toks List{Token} locals HashMap) void
		(super:<init>)
		(set this:name name)
		(set this:toks toks)
		(set this:locals locals)
		(set this:imports (HashMap))
		(set this:starImports (ArrayList))
		(this:starImports:add "java.lang.")
		(this:starImports:add "sjava.std.")
		(set this:found (HashMap{String Boolean}))
		(set this:newClasses (ArrayList{ClassInfo}))
		(set this:macros (ArrayList))
		(set this:package_
			(if
				(&&
					(> (toks:size) 0)
					(instance? (toks:get 0) BlockToken)
					(instance? ((toks:get 0):toks:get 0) VToken)
					((as VToken ((toks:get 0):toks:get 0)):val:equals "package")
				)
				((as VToken ((toks:get 0):toks:get 1)):val:concat ".")
				""
			)
		)
	)
	((classExists name String) bool
		(if (this:found:containsKey name)
			(this:found:get name)
			(begin
				(define b
					(try
						(begin
							(Class:forName name)
							true
						)
						(e Throwable false)
					)
				)
				(this:found:put name b)
				b
			)
		)
	)
	((getNewType tok Token) ClassType
		(if (instance? tok GenericToken)
			(begin
				(define tok GenericToken tok)
				(define c (ClassType (this:package_:concat (as VToken tok:tok):val)))
				(define params tok:toks)
				(define tparams (Type[] len:(params:size)))
				(define i 0)
				(while (!= i (params:size))
					(define name (as VToken (params:get i)):val)
					(define tv (TypeVariable name))
					(aset tparams i tv)
					(set i (+ i 1))
				)
				(c:setTypeParameters tparams)
				c
			)
			(if (instance? tok VToken)
				(ClassType (this:package_:concat (as VToken tok):val))
				null
			)
		)
	)
	((compileRoot) void
		(define i 0)
		(while (!= i (this:toks:size))
			(this:compileRoot (this:toks:get i))
			(set i (+ i 1))
		)
	)
	((compileRoot tok Token) void
		(if (instance? (tok:toks:get 0) VToken)
			(begin
				(define first VToken (tok:toks:get 0))
				(cond
					((first:val:equals "define-class")
						(define c (this:getNewType (tok:toks:get 1)))
						(define name (c:getName))
						(define ci (ClassInfo c this))
						(set ci:toks tok:toks)
						(this:newClasses:add ci)
						(this:locals:put name ci:c)
						(define run true)
						(define i 3)
						(while (&& run (!= i (ci:toks:size)))
							(set run (Main:compileClassMod (ci:toks:get i) ci:c))
							(if run (set i (+ i 1)))
						)
					)
					((first:val:equals "import")
						(define import (as VToken (tok:toks:get 1)):val)
						(if (import:equals "%tokens%")
							(this:starImports:add "sjava.compiler.tokens.")
							(if (import:contains "*")
								(this:starImports:add (import:replace "*" ""))
								(this:imports:put (import:substring (+ (import:lastIndexOf ".") 1)) import)
							)
						)
					)
					((first:val:equals "define-macro")
						(define scope (LinkedHashMap))
						(define params (tok:toks:get 1))
						(define name (as VToken (params:toks:get 0)):val)
						(define o 4)
						(define types (Type[] len:(+ o (- (params:toks:size) 1)) (Main:getCompilerType "AMethodInfo") (Type:getType "gnu.bytecode.Type") Type:intType (Main:getCompilerType "handlers.GenHandler")))
						(define mods (| Access:PUBLIC Access:STATIC))
						(scope:put "mi" (Arg 0 (Main:getCompilerType "AMethodInfo")))
						(begin
							(define i 0)
							(while (!= (+ o i) (alen types))
								(define t Type (Main:getCompilerType "tokens.Token"))
								(define name (as VToken (params:toks:get (+ i 1))):val)
								(if (name:contains "@")
									(begin
										(set name (name:replace "@" ""))
										(set mods (| mods Access:TRANSIENT))
										(set t (ArrayType t))
									)
								)
								(aset types (+ o i) t)
								(scope:put name (Arg (+ o i) t))
								(set i (+ i 1))
							)
						)
						(define cname ((("Macros$":concat (this:name:replace "/" "-")):concat "$"):concat (Integer:toString (this:macros:size))))
						(define macros (MacroInfo cname this))
						(macros:c:setModifiers Access:PUBLIC)
						(define macro (MethodInfo macros (tok:toks:subList 2 (tok:toks:size)) (macros:c:addMethod name types (Main:getCompilerType "tokens.Token") mods) scope))
						(if (this:macroNames:containsKey name)
							((this:macroNames:get name):add macros)
							(begin
								(define al (ArrayList{ClassInfo}))
								(al:add macros)
								(this:macroNames:put name al)
							)
						)
						(this:macros:add macros)
						(macros:methods:add macro)
					)
				)
			)
		)
	)
	((compileDefs) void
		(define i 0)
		(while (!= i (this:newClasses:size))
			((this:newClasses:get i):compileDefs)
			(set i (+ i 1))
		)
	)
	((compileMacros) void
		(define i 0)
		(while (!= i (this:macros:size))
			(define macros (this:macros:get i))
			((macros:methods:get 0):compileMethodBody)
			;(Files:write (Paths:get (("macros/":concat cname):concat ".class") (String[])) ba (OpenOption[]))
			;why?
			(set macros:rc (macros:getClazz))
			(set i (+ i 1))
		)
	)
	((compileIncludes) void
		(define includes (MacroInfo "Includes" this))
		(set this:includes includes)
		(includes:c:setModifiers Access:PUBLIC)
		(define n 0)
		(define i 0)
		(while (!= i (this:newClasses:size))
			(define methods (this:newClasses:get i):methods)
			(define j 0)
			(while (!= j (methods:size))
				(define method (methods:get j))
				(if (!= method:block null)
					(set n (this:compileIncludes method:block:toks n))
				)
				(set j (+ j 1))
			)
			(set i (+ i 1))
		)
		;why?
		(set includes:rc (includes:getClazz))
	)
	((compileIncludes toks List{Token} n int) int
		(define i 0)
		(while (!= i (toks:size))
			(define tok (toks:get i))
			(if (&& (!= tok:toks null) (> (tok:toks:size) 0))
				(if (&& (instance? (tok:toks:get 0) VToken) ((as VToken (tok:toks:get 0)):val:equals "include"))
					(begin
						(define name ("$":concat (Integer:toString n)))
						(define scope (LinkedHashMap))
						(scope:put "mi" (Arg 0 (Main:getCompilerType "AMethodInfo")))
						(define mi (MethodInfo this:includes (tok:toks:subList 1 (tok:toks:size)) (this:includes:c:addMethod name (Type[] (Main:getCompilerType "AMethodInfo") (Type:getType "gnu.bytecode.Type") Type:intType (Main:getCompilerType "handlers.GenHandler")) (Main:getCompilerType "tokens.Token") (| Access:PUBLIC Access:STATIC)) scope))
						(toks:set i (IncludeToken tok:line mi))
						(this:includes:methods:add mi)
						(mi:compileMethodBody)
						(set n (+ n 1))
					)
					(set n (this:compileIncludes tok:toks n))
				)
			)
			(set i (+ i 1))
		)
		n
	)
	((compileMethods h GenHandler) void 'public
		(define i 0)
		(while (!= i (this:newClasses:size))
			((this:newClasses:get i):compileMethods h)
			(set i (+ i 1))
		)
	)
)

(define-class ClassInfo () 'public
	(c ClassType 'public)
	(fs FileScope 'public)
	(toks List{Token})
	(methods List{AMethodInfo} 'public)
	(anonClasses List{ClassInfo} 'public)
	(rc Class 'public)
	(tvs HashMap{String TypeVariable})
	(classfile byte[])
	((<init> c ClassType fs FileScope) void 'public
		(super:<init>)
		(set this:fs fs)
		(set this:c c)
		(set this:toks (ArrayList{Token}))
		(set this:methods (ArrayList{AMethodInfo}))
		(set this:anonClasses (ArrayList{ClassInfo}))
		(if (!= c null)
			(begin
				(this:c:setClassfileVersion ClassType:JDK_1_8_VERSION)
				(this:c:setSuper Type:javalangObjectType)
				(define args (c:getTypeParameters))
				(if (!= args null)
					(begin
						(set this:tvs (HashMap{String TypeVariable}))
						(define i 0)
						(while (!= i (alen args))
							(define tv Type (aget args i))
							(if (instance? tv TypeVariable)
								(this:tvs:put (tv:getName) (as TypeVariable tv))
							)
							(set i (+ i 1))
						)
					)
				)
			)
		)
	)
	((<init> name String fs FileScope) void 'public
		(this:<init> (ClassType name) fs)
	)
	((getClassfile) byte[]
		(if (= this:classfile null)
			(set this:classfile (this:c:writeToArray))
		)
		this:classfile
	)
	((addToClassLoader cl ArrayClassLoader) void 'public
		(cl:addClass (this:c:getName) (this:getClassfile))
		(forEach anon this:anonClasses
			(anon:addToClassLoader cl)
		)
	)
	((getClazz cl ArrayClassLoader) Class 'public
		(define c Class null)
		(try (set c (cl:loadClass (this:c:getName))) (e Throwable (throw (RuntimeException e))))
		c
	)
	((getClazz) Class 'public
		(define cl (ArrayClassLoader))
		(this:addToClassLoader cl)
		(this:getClazz cl)
	)
	((writeFiles dir String) void 'public
		(define pre (concat dir "/" (this:fs:package_:replace "." "/")))
		((File pre):mkdirs)
		(try
			(org.apache.commons.io.FileUtils:writeByteArrayToFile (File (concat pre (this:c:getSimpleName) ".class")) (this:getClassfile))
			(e Throwable (throw (RuntimeException e)))
		)
		(forEach anon this:anonClasses
			(anon:writeFiles dir)
		)
	)
	((getType name String) Type
		(define i 0)
		(define dims -1)
		(while (!= i -1)
			(set i (name:indexOf "[]" (+ i 1)))
			(set dims (+ dims 1))
		)
		(set name (name:replace "[" ""))
		(set name (name:replace "]" ""))
		(define abs (name:contains "."))
		(define out Type
			(cond
				((&& (!= this:tvs null) (this:tvs:containsKey name))
					(this:tvs:get name)
				)
				((Main:constTypes:containsKey name)
					(Main:constTypes:get name)
				)
				((this:fs:locals:containsKey name)
					(this:fs:locals:get name)
				)
				((&& (! abs) (this:fs:locals:containsKey (this:fs:package_:concat name)))
					(this:fs:locals:get (this:fs:package_:concat name))
				)
				((this:fs:imports:containsKey name)
					(define fullName (this:fs:imports:get name))
					(if (this:fs:locals:containsKey fullName)
						(this:fs:locals:get fullName)
						(if (this:fs:classExists fullName)
							(Type:getType fullName)
							(throw (RuntimeException))
						)
					)
				)
				(true
					(define type Type null)
					(define i 0)
					(while (&& (! abs) (= type null) (!= i (this:fs:starImports:size)))
						(define fullName ((this:fs:starImports:get i):concat name))
						(if (this:fs:locals:containsKey fullName)
							(set type (this:fs:locals:get fullName))
							(if (this:fs:classExists fullName)
								(set type (Type:getType fullName))
							)
						)
						(set i (+ i 1))
					)
					(if (&& (= type null) (this:fs:classExists name))
						(Type:getType name)
						type
					)
				)
			)
		)
		(set i 0)
		(while (!= i dims)
			(set out (ArrayType out))
			(set i (+ i 1))
		)
		out
	)
	((getType tok Token) Type
		(if (instance? tok GenericToken)
			(begin
				(define tok GenericToken tok)
				(define c ClassType ((this:getType (as VToken tok:tok):val):getRawType))
				(define params tok:toks)
				(define tparams (Type[] len:(params:size)))
				(define i 0)
				(while (!= i (params:size))
					(aset tparams i (this:getType (params:get i)))
					(set i (+ i 1))
				)
				(ParameterizedType c tparams)
			)
			(if (instance? tok VToken)
				(this:getType (as VToken tok):val)
				null
			)
		)
	)
	((compileDef tok Token) void 'public
		(if (instance? tok BlockToken)
			(begin
				(define first (tok:toks:get 0))
				(if (instance? first BlockToken) ;method definition
					(begin
						(define scope (LinkedHashMap))
						(define mods 0)
						(define end false)
						(define i 2)
						(while (! (|| end (= i (tok:toks:size))))
							(define mod (tok:toks:get i))
							(if (instance? mod SingleQuoteToken)
								(begin
									(set mods (| mods (Main:accessModifiers:get (as VToken (mod:toks:get 0)):val)))
									(set i (+ i 1))
								)
								(set end true)
							)
						)
						(define n 0)
						(if (= (& mods Access:STATIC) 0)
							(begin
								(scope:put "this" (Arg 0 this:c))
								(set n 1)
							)
						)
						(define types (Main:getParams this first scope 1 n))
						(define m Method (this:c:addMethod (as VToken (first:toks:get 0)):val types (this:getType (tok:toks:get 1)) mods))
						(this:methods:add (MethodInfo this (tok:toks:subList i (tok:toks:size)) m scope))
					)
					(begin ;field definition
						(define mods 0)
						(define end false)
						(define i 2)
						(while (! (|| (= i (tok:toks:size)) end))
							(define mod (tok:toks:get i))
							(if (instance? mod SingleQuoteToken)
								(begin
									(define nmod (Main:accessModifiers:get (as VToken (mod:toks:get 0)):val))
									(set mods (| mods nmod))
								)
								(set end true)
							)
							(set i (+ i 1))
						)
						(define t (this:getType (tok:toks:get 1)))
						(this:c:addField (as VToken first):val t mods)
					)
				)
			)
		)
	)
	((compileDefs) void
		(define c this:c)
		(define supers (this:toks:get 2):toks)
		(define i 0)
		(while (! (= i (supers:size)))
			(define related Type (this:getType (supers:get i)))
			(if (related:isInterface)
				(c:addInterface related)
				(c:setSuper related)
			)
			(set i (+ i 1))
		)
		(set i 3)
		(while (!= i (this:toks:size))
			(this:compileDef (this:toks:get i))
			(set i (+ i 1))
		)
	)
	((compileMethods h GenHandler) void 'public
		(define i 0)
		(while (!= i (this:methods:size))
			(define mi (this:methods:get i))
			(mi:compileMethodBody h)
			(set i (+ i 1))
		)
	)
)

(define-class MacroInfo (ClassInfo) 'public
	((<init> name String fs FileScope) void
		(super:<init> name fs)
	)
	((getType name String) Type
		(if (name:startsWith "sjava.compiler.")
			(Type:getType name)
			(super:getType name)
		)
	)
)

(define-class AMethodInfo () 'public
	(ci ClassInfo 'public)
	(block BlockToken 'public)
	(method Method 'public)
	(scopes ArrayList{ArrayDeque{Map{String AVar}}} 'public)
	(firstScope Map{String AVar})
	(labels ArrayDeque{HashMap})
	((<init> ci ClassInfo toks List{Token} method Method firstScope Map{String AVar}) void
		(super:<init>)
		(set this:ci ci)
		(if (!= (toks:size) 0)
			(begin
				(define btoks (ArrayList{Token}))
				(btoks:add (VToken (toks:get 0):line "begin"))
				(btoks:addAll toks)
				(set this:block (Main:transformBlockToks (BeginToken (toks:get 0):line btoks) this))
			)
		)
		(set this:method method)
		(set this:scopes (ArrayList))
		(define h (ArrayDeque))
		(this:scopes:add h)
		(set this:firstScope firstScope)
		(set this:labels (ArrayDeque))
	)
	((pushScope code CodeAttr label HashMap) void 'public
		(define output (!= code null))
		(define i 0)
		(while (!= i (this:scopes:size))
			((this:scopes:get i):push (HashMap))
			(set i (+ i 1))
		)
		(this:labels:push label)
		;(if output (code:pushScope))
	)
	((popScope code CodeAttr) void 'public
		(define output (!= code null))
		(define i 0)
		(while (!= i (this:scopes:size))
			((this:scopes:get i):pop)
			(set i (+ i 1))
		)
		(this:labels:pop)
		;(if output (code:popScope))
	)
	((pushLevel) void 'public
		(this:scopes:add (ArrayDeque))
	)
	((popLevel) void 'public
		(this:scopes:remove (- (this:scopes:size) 1))
	)
	((getVar tok VToken) AVar 'public
		(define scopes (this:scopes:get tok:macro))
		(define found AVar null)
		(define it (scopes:iterator))
		(while (&& (it:hasNext) (= found null))
			(define vars (it:next))
			(if (vars:containsKey tok:val)
				(set found (vars:get tok:val))
			)
		)
		(if (= found null) (this:firstScope:get tok:val) found)
	)
	((getLabel name String) Label 'public
		(define found Label null)
		(define it Iterator (this:labels:iterator))
		(while (&& (it:hasNext) (= found null))
			(define vars HashMap (it:next))
			(if (vars:containsKey name)
				(set found (vars:get name))
			)
		)
		found
	)
	((newVar code CodeAttr tok VToken type Type) Variable 'public
		(define output (!= code null))
		(define name tok:val)
		(define var Variable (if output (code:addLocal (type:getRawType) name) null))
		((as HashMap ((this:scopes:get tok:macro):getFirst)):put name (Var var type))
		var
	)
	((getType tok Token) Type 'public
		(this:ci:getType tok)
	)
	((compileMethodBody h GenHandler) void 'public
		(if (! (this:method:isAbstract))
			(begin
				(h:compile this:block this null (this:method:getReturnType))

				(define filter (BridgeFilter this:method))
				(filter:searchAll)

				(define code (this:method:startCode))
				(define paramNames (this:firstScope:keySet))
				(forEachI paramName paramNames i
					(if (! (paramName:equals "this"))
						((code:getArg i):setName paramName)
					)
				)
				(define ret (h:compile this:block this code (this:method:getReturnType)))
				(code:popScope)

				(if (code:reachableHere)
					(code:emitReturn)
				)
			)
		)
	)
	((compileMethodBody) void
		(this:compileMethodBody GenHandler:inst)
	)
	((toString) String 'public
		(concat (super:toString) ":" this:method)
	)
)

(define-class MethodInfo (AMethodInfo) 'public
	((<init> ci ClassInfo toks List{Token} method Method scope LinkedHashMap) void 'public
		(super:<init> ci toks method scope)
	)
)
