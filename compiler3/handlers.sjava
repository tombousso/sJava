(package sjava.compiler.handlers)

(import sjava.compiler.*)
(import sjava.compiler.mfilters.*)
(import sjava.compiler.emitters.*)
(import sjava.compiler.tokens.*)

(import java.util.*)
(import gnu.bytecode.*)

(define-class Handler () abstract public
	((<init>) void (super:<init>))
	((compileAll toks List{Token} i int e int mi AMethodInfo needed Object) Type[] public
		(define l (toks:size))
		(define types (Type[] len:(- e i)))
		(for ((j i)) (! (>= j e)) (inc j)
			(aset types (- j i)
				(this:compile (toks:get j) mi
					(if (instance? needed Type[])
						(aget (as Type[] needed) (- j i))
						(as Type needed)
					)
				)
			)
		)
		types
	)
	((compile tok EmptyToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok SToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok CToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok NToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok FieldToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok QuoteToken2 mi AMethodInfo needed Type) Type public abstract)
	((compile tok ConstToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok VToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok IncludeToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok ObjectToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok MacroIncludeToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok BeginToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok SpecialBeginToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok LabelToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok GotoToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok DefineToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok TryToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok InstanceToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok SetToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok ASetToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok AGetToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok ALenToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok AsToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok NumOpToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok ShiftToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok IfToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok CompareToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok ThrowToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok ClassToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok SynchronizedToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok TypeToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok ReturnToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok CallToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok DefaultToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok ConstructorToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok ArrayConstructorToken mi AMethodInfo needed Type) Type public abstract)
	((compile tok Token mi AMethodInfo needed Type) Type public
		(doubleDispatch (this:compile _ mi needed) tok)
	)
	((castMaybe result Type needed Type) Type public abstract)
)

(define-class GenHandler (Handler) public
	(inst GenHandler static public)
	(code CodeAttr public)
	((<clinit>) void static (set GenHandler:inst (GenHandler)))
	((<init>) void
		(super:<init>)
	)
	((compileAll toks List{Token} i int e int mi AMethodInfo code CodeAttr needed Object) Type[] public
		(define ocode this:code)
		(set this:code code)
		(define out (this:compileAll toks i e mi needed))
		(set this:code ocode)
		out
	)
	((compile tok Token mi AMethodInfo code CodeAttr needed Type) Type public
		(define ocode this:code)
		(set this:code code)
		(define out (this:compile tok mi needed))
		(set this:code ocode)
		out
	)
	((castMaybe result Type needed Type) Type public
		(GenHandler:castMaybe this:code result needed)
	)
	((castMaybe code CodeAttr result Type needed Type) Type public static
		(define output (!= code null))
		(if (|| (= needed Main:unknownType) (= result Main:returnType) (= result Main:throwType))
			result
			(begin
				(if (= needed Type:voidType)
					(if (!= result Type:voidType)
						(if output (code:emitPop 1))
					)
					(if (! (Type:isSame needed result))
						(if (instance? result PrimType)
							(begin
								(if (instance? needed ClassType)
									(if (= result Type:voidType)
										(if (= needed (Type:getType "java.lang.Void"))
											(if output (code:emitPushNull))
											(throw (RuntimeException))
										)
										(begin
											(define prim (PrimType:unboxedType needed))
											(define box
												(if (= prim null)
													(begin ;needed can be Object, Number, etc.
														(set prim result)
														((as PrimType result):boxedType)
													)
													(begin
														(if output (code:emitConvert (as PrimType result) prim))
														(as ClassType needed)
													)
												)
											)
											(if output (code:emitInvoke (box:getMethod "valueOf" (Type[] prim))))
										)
									)
									(if output (code:emitConvert (as PrimType result) (as PrimType needed)))
								)
							)
							(if (instance? needed PrimType)
								(begin
									(define unbox (Main:unboxMethods:get result))
									(if output (code:emitInvoke unbox))
									(if output (code:emitConvert (as PrimType (unbox:getReturnType)) (as PrimType needed)))
								)
								(if output (code:emitCheckcast (needed:getRawType)))
							)
						)
					)
				)
				needed
			)
		)
	)
	((emitTrueFalseClauses_ mi AMethodInfo trueE Emitter falseE Emitter trueCasts List{Tuple2{VToken Type}} falseCasts List{Tuple2{VToken Type}} needed Type skipL Label trueL Label falseL Label) Tuple2{Type Type}
		(define output (!= this:code null))

		(mi:pushScope this:code (HashMap))
		(forEach cast trueCasts
			(GenHandler:putCast mi cast)
		)
		(if output (trueL:define this:code))
		(define trueT (trueE:emit this mi this:code needed))
		(mi:popScope this:code)

		(if (&& output (this:code:reachableHere)) (this:code:emitGoto skipL))

		(mi:pushScope this:code (HashMap))
		(forEach cast falseCasts
			(GenHandler:putCast mi cast)
		)
		(if output (falseL:define this:code))
		(define falseT (falseE:emit this mi this:code needed))
		(mi:popScope this:code)

		(if output (skipL:define this:code))

		(Tuple2 trueT falseT)
	)
	((emitTrueFalseClauses mi AMethodInfo trueE Emitter falseE Emitter trueCasts List{Tuple2{VToken Type}} falseCasts List{Tuple2{VToken Type}} needed Type skipL Label trueL Label falseL Label) Tuple3{Type List{Tuple2{VToken Type}} List{Tuple2{VToken Type}}} public
		(if (= needed Main:unknownType)
			(begin
				(define ocode this:code)
				(set this:code null)
				(define ts (this:emitTrueFalseClauses_ mi trueE falseE trueCasts falseCasts needed skipL trueL falseL))
				(set this:code ocode)
				(set needed
					(Main:commonType
						ts:_1
						ts:_2
					)
				)
			)
		)
		(this:emitTrueFalseClauses_ mi trueE falseE trueCasts falseCasts needed skipL trueL falseL)
		(Tuple3 needed trueCasts falseCasts)
	)
	((emitGotoIf otype Type invCompare String compare String label Label) void public
		(define output (!= this:code null))
		(if (|| (= otype Type:doubleType) (= otype Type:floatType))
			(begin
				(define lt (|| (compare:equals "<") (compare:equals "<=")))
				(define op (if (= otype Type:doubleType) (if lt 151 152) (if lt 149 150)))
				(if output (this:code:emitPrimop op 2 Type:intType))
				(cond
					((invCompare:equals ">") (if output (this:code:emitGotoIfIntLeZero label)))
					((invCompare:equals ">=") (if output (this:code:emitGotoIfIntLtZero label)))
					((invCompare:equals "<") (if output (this:code:emitGotoIfIntGeZero label)))
					((invCompare:equals "<=") (if output (this:code:emitGotoIfIntGtZero label)))
					((invCompare:equals "=") (if output (this:code:emitGotoIfIntNeZero label)))
					((invCompare:equals "!=") (if output (this:code:emitGotoIfIntEqZero label)))
				)
			)
			(if output (this:code:emitGotoIfCompare2 label (Main:compare2Ops:get invCompare)))
		)
	)
	;toks = condition
	((emitIf_ inv bool toks List{Token} compare String trueE Emitter falseE Emitter mi AMethodInfo needed Type) Tuple3{Type List{Tuple2{VToken Type}} List{Tuple2{VToken Type}}} public
		(define output (!= this:code null))

		(define trueCasts (ArrayList{Tuple2{VToken Type}}))
		(define falseCasts (ArrayList{Tuple2{VToken Type}}))
		(cond
			((compare:equals "!")
				(this:emitIf (! inv) (toks:get 0) trueE falseE mi needed)
			)
			((|| (compare:equals "&&") (compare:equals "||"))
				(define skipL (Label))
				(define trueL (Label))
				(define trueG (Goto trueL))
				(define falseL (Label))
				(define falseG (Goto falseL))
				(mi:pushScope this:code (HashMap))
				(if (|| (&& (! inv) (compare:equals "&&")) (&& inv (compare:equals "||")))
					;AND
					(begin
						(for ((i 0)) (!= i (- (toks:size) 1)) (inc i)
							(define a (this:emitIf inv (toks:get i) Nothing:inst falseG mi Type:voidType))
							(forEach cast a:_2
								(GenHandler:putCast mi cast)
							)
							(trueCasts:addAll a:_2)
						)
						(trueCasts:addAll (this:emitIf inv (toks:get (- (toks:size) 1)) Nothing:inst falseG mi Type:voidType):_2)
					)
					;OR
					(begin
						(for ((i 0)) (!= i (- (toks:size) 1)) (inc i)
							(define a (this:emitIf (! inv) (toks:get i) Nothing:inst trueG mi Type:voidType))
							(forEach cast a:_2
								(GenHandler:putCast mi cast)
							)
							(falseCasts:addAll a:_2)
						)
						(falseCasts:addAll (this:emitIf inv (toks:get (- (toks:size) 1)) Nothing:inst falseG mi Type:voidType):_2)
					)
				)
				(mi:popScope this:code)
				(this:emitTrueFalseClauses mi trueE falseE trueCasts falseCasts needed skipL trueL falseL)
			)
			(true
				(define trueL (Label))
				(define cast Tuple2{VToken Type} null)
				(define isFalseGoto (&& (instance? trueE Nothing) (instance? falseE Goto)))
				(define falseLabel
					(if isFalseGoto
						(as Goto falseE):label
						(Label)
					)
				)
				(define invCompare (Main:invertComp inv compare))
				(if (Main:compare1Ops:containsKey invCompare)
					(begin
						(for ((j 0)) (!= j (toks:size)) (inc j)
							(define tok (toks:get j))
							(if
								(&&
									(instance? tok InstanceToken)
									(instance? (as InstanceToken tok):tok VToken)
								)
								(begin
									(define it (as InstanceToken tok))
									(set cast (Tuple2 (as VToken it:tok) it:type))
								)
							)
							(define types (this:compileAll toks j (+ j 1) mi null Main:unknownType))
							(define otype (Main:compareType types))
							(this:compileAll toks j (+ j 1) mi otype)
							(if output (this:code:emitGotoIfCompare1 falseLabel (Main:compare1Ops:get invCompare)))
						)
					)
					(begin
						(if (&& (> (toks:size) 2) (compare:equals "!="))
							(throw (RuntimeException))
						)
						(define types (this:compileAll toks 0 (toks:size) mi null Main:unknownType))
						(define otype (Main:compareType types))
						(define special (&& inv (> (toks:size) 2)))
						(define vars (Variable[] len:(- (toks:size) 2)))
						(for ((j 1)) (< (+ j 1) (toks:size)) (inc j)
							(this:compile (toks:get j) mi otype)
							(if output
								(begin
									(define v (this:code:addLocal otype))
									(this:code:emitStore v)
									(aset vars (- j 1) v)
								)
							)
						)
						(this:compile (toks:get 0) mi otype)
						(for ((i 0)) (< i (alen vars)) (inc i)
							(if output (this:code:emitLoad (aget vars i)))
							(if special
								(this:emitGotoIf otype compare compare trueL)
								(this:emitGotoIf otype invCompare compare falseLabel)
							)
							(if output (this:code:emitLoad (aget vars i)))
						)
						(this:compile (toks:get (- (toks:size) 1)) mi otype)
						(if special
							(this:emitGotoIf otype compare compare trueL)
							(this:emitGotoIf otype invCompare compare falseLabel)
						)
						(if special
							(if output (this:code:emitGoto falseLabel))
						)
					)
				)
				(if (!= cast null)
					(if inv
						(falseCasts:add cast)
						(trueCasts:add cast)
					)
				)
				(cond
					(isFalseGoto
						(if output (trueL:define this:code))
						(Tuple3 Type:voidType trueCasts falseCasts)
					)
					(true
						(define casts (Arrays:asList (Tuple2[] cast)))
						(define trueCasts List{Tuple2{VToken Type}}
							(if (! inv)
								casts
								Collections:EMPTY_LIST
							)
						)
						(define falseCasts List{Tuple2{VToken Type}}
							(if inv
								casts
								Collections:EMPTY_LIST
							)
						)
						(this:emitTrueFalseClauses mi trueE falseE trueCasts falseCasts needed (Label) trueL falseLabel)
					)
				)
			)
		)
	)
	((putCast mi AMethodInfo cast Tuple2{VToken Type}) void static
		(if (!= cast null)
			(mi:putVar cast:_1 (CastVar (mi:getVar cast:_1) cast:_2))
		)
	)
	((emitIf inv bool cond Token trueE Emitter falseE Emitter mi AMethodInfo needed Type) Tuple3{Type List{Tuple2{VToken Type}} List{Tuple2{VToken Type}}} public
		(instanceCond cond
			(CompareToken (this:emitIf_ inv cond:toks cond:compare trueE falseE mi needed))
			(true (this:emitIf_ inv (Arrays:asList (Token[] cond)) "!=0" trueE falseE mi needed))
		)
	)
	((compile tok EmptyToken mi AMethodInfo needed Type) Type public
		Type:voidType
	)
	((compile tok SToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(if output (this:code:emitPushString tok:val))
		(this:castMaybe Type:javalangStringType needed)
	)
	((compile tok CToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(define c int tok:val)
		(if (! (instance? needed PrimType))
			(begin
				(if output (this:code:emitPushInt c))
				(this:castMaybe Type:charType needed)
			)
			(begin
				(if output (this:code:emitPushConstant c needed))
				needed
			)
		)
	)
	((compile tok NToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(define val tok:val)
		(this:castMaybe
			(instanceCond val
				(Double
					(if output (this:code:emitPushDouble val))
					Type:doubleType
				)
				(Float
					(if output (this:code:emitPushFloat val))
					Type:floatType
				)
				(Integer
					(if (Main:isNumeric needed)
						(begin
							(define prim (Main:tryUnbox needed))
							(if output (this:code:emitPushConstant val prim))
							prim
						)
						(begin
							(if output (this:code:emitPushInt val))
							Type:intType
						)
					)
				)
				(Long
					(if output (this:code:emitPushLong val))
					Type:longType
				)
				(true (throw (RuntimeException)))
			)
			needed
		)
	)
	((compile tok FieldToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(define t (mi:getType tok:left))
		(if (= t null)
			(set t (this:compile tok:left mi this:code Main:unknownType))
		)
		(define class ClassType (t:getRawType))
		(define field Field (class:getField tok:right -1))
		(if (field:getStaticFlag)
			(if output (this:code:emitGetStatic field))
			(if output (this:code:emitGetField field))
		)
		(define out (Main:resolveType t (field:getType)))
		(if (!= out Type:voidType)
			(if output (this:code:emitCheckcast (out:getRawType)))
		)
		(this:castMaybe out needed)
	)
	((compileQuasi o Object mi AMethodInfo code CodeAttr needed Type) Type
		(define ocode this:code)
		(set this:code code)
		(define out (this:compileQuasi o mi needed))
		(set this:code ocode)
		out
	)
	((compileQuasi o Object mi AMethodInfo needed Type) Type
		(define output (!= this:code null))
		(if (= o null)
			(begin
				(if output (this:code:emitPushNull))
				(return needed)
			)
		)
		(define result Type
			(instanceCond o
				(UnquoteToken
					(define tok (mi:transformBlock (o:toks:get 0)))
					(define t (this:compile tok mi null Main:unknownType))
					(cond
						((= t (Type:getType "gnu.bytecode.Type"))
							(this:compile tok mi this:code Main:unknownType)
							(if output (this:code:emitInvoke ((Main:getCompilerType "Main"):getDeclaredMethod "typeToTok" 1)))
							(Main:getCompilerType "tokens.LexedParsedToken")
						)
						(
							(||
								(>= (Main:compare (Main:getCompilerType "tokens.LexedParsedToken") t) 0)
								;(&&
								(instance? t ArrayType)
								;	(= (as ArrayType t):elements (Main:getCompilerType "tokens.LexedParsedToken"))
								;)
								((t:getRawType):isSubtype (Type:getType "java.util.List"))
							)
							(this:compile tok mi this:code Main:unknownType)
						)
						(true
							(define t (this:compile tok mi null Main:unknownType))
							(define type ClassType
								(Main:getCompilerType
									(if o:var
										"tokens.VToken"
										(if (= t Type:charType)
											"tokens.CToken"
											(if (instance? t PrimType)
												"tokens.NToken"
												"tokens.SToken"
											)
										)
									)
								)
							)
							(if output (this:code:emitNew type))
							(if output (this:code:emitDup))
							(if output (this:code:emitInvoke (type:getDeclaredMethod "<init>" 0)))
							(if output (this:code:emitDup))
							(this:compile tok mi this:code Type:objectType)
							(if output (this:code:emitPutField (type:getField "val")))
							(Main:getCompilerType "tokens.LexedParsedToken")
						)
					)
				)
				(LexedParsedToken
					(define type ClassType (Type:getType ((o:getClass):getName)))
					(if output (this:code:emitNew type))
					(if output (this:code:emitDup))
					(if output (this:code:emitInvoke (type:getDeclaredMethod "<init>" 0)))
					(define superC type)
					(while (!= superC null)
						(define field (superC:getFields))
						(while (!= field null)
							(if
								(&&
									(!= (& (field:getModifiers) Access:PUBLIC) 0)
									(= (& (field:getModifiers) Access:TRANSIENT) 0)
									(= (& (field:getModifiers) Access:STATIC) 0)
								)
								(begin
									(if output (this:code:emitDup))
									(try
										(this:compileQuasi ((field:getReflectField):get o) mi this:code (field:getType))
										(e NoSuchFieldException (throw (RuntimeException e)))
										(e IllegalAccessException (throw (RuntimeException e)))
									)
									(if output (this:code:emitPutField field))
								)
							)
							(set field (field:getNext))
						)
						(set superC (superC:getSuperclass))
					)
					(if (= type (Main:getCompilerType "tokens.VToken"))
						(begin
							(if output (this:code:emitDup))
							(cond
								((instance? mi:ci MethodMacroInfo)
									(if output (this:code:emitPushInt 0))
								)
								((instance? mi:ci MacroInfo)
									(if output (this:code:emitLoad (this:code:getArg 1)))
								)
							)
							(if output (this:code:emitPutField (type:getField "macro")))
						)
					)
					type
				)
				(String
					(if output (this:code:emitPushString o))
					Type:javalangStringType
				)
				(Integer
					(if output (this:code:emitPushInt o))
					Type:intType
				)
				(Long
					(if output (this:code:emitPushLong o))
					Type:longType
				)
				(Double
					(if output (this:code:emitPushDouble o))
					Type:doubleType
				)
				(Float
					(if output (this:code:emitPushFloat o))
					Type:floatType
				)
				(Boolean
					(if output (this:code:emitPushInt (if o 1 0)))
					Type:booleanType
				)
				(List
					(define al ClassType (Type:getType "java.util.ArrayList"))
					(if output (this:code:emitNew al))
					(if output (this:code:emitDup))
					(if output (this:code:emitInvoke (al:getMethod "<init>" (Type[]))))
					(define i 0)
					(forEach a o
						(define t (this:compileQuasi a mi null Main:unknownType))
						(if (>= (Main:compare (Main:getCompilerType "tokens.LexedParsedToken") t) 0)
							(begin
								(if output (this:code:emitDup))
								(this:compileQuasi a mi this:code Main:unknownType)
								(if output (this:code:emitInvoke (al:getMethod "add" (Type[] Type:objectType))))
								(if output (this:code:emitPop 1))
							)
							(if (instance? t ArrayType)
								(begin
									(if output (this:code:emitDup))
									(this:compileQuasi a mi this:code Main:unknownType)
									(if output (this:code:emitInvoke ((as ClassType (Type:getType "java.util.Collections")):getDeclaredMethod "addAll" 2)))
									(if output (this:code:emitPop 1))
								)
								(begin
									(if output (this:code:emitDup))
									(this:compileQuasi a mi this:code Main:unknownType)
									(if output (this:code:emitInvoke ((as ClassType (Type:getType "java.util.List")):getDeclaredMethod "addAll" 1)))
									(if output (this:code:emitPop 1))
								)
							)
						)
					)
					al
				)
				(true
					(throw (RuntimeException ((o:getClass):toString)))
				)
			)
		)
		(this:castMaybe result needed)
	)
	((compile tok QuoteToken2 mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(this:castMaybe (this:compileQuasi tok:tok mi this:code Main:unknownType) needed)
	)
	((compile tok ConstToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(this:castMaybe
			(if (tok:val:equals "true")
				(begin
					(if output (this:code:emitPushInt 1))
					Type:booleanType
				)
				(if (tok:val:equals "false")
					(begin
						(if output (this:code:emitPushInt 0))
						Type:booleanType
					)
					(begin
						(if output (this:code:emitPushNull))
						Type:nullType
					)
				)
			)
			needed
		)
	)
	((compile tok VToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(define found (mi:getVar tok))
		(this:castMaybe (found:load this:code) needed)
	)
	((compile tok IncludeToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(if (= tok:ret null)
			(begin
				(mi:ci:fs:compileInclude tok)
				(try
					(set tok:ret
						(mi:transformBlock
							(as LexedParsedToken
								(
									((mi:ci:fs:includes:getClazz):getMethod (tok:mi:method:getName)
										(Class[]
											(class AMethodInfo)
											Integer:TYPE
											(class GenHandler)
										)
									):invoke
									null
									(Object[] mi 0 this)
								)
							)
						)
					)
					(e NoSuchMethodException (throw (RuntimeException e)))
					(e IllegalAccessException (throw (RuntimeException e)))
					(e java.lang.reflect.InvocationTargetException (throw (RuntimeException e)))
				)
			)
		)
		(this:castMaybe (this:compile tok:ret mi this:code needed) needed)
	)
	((createCtor c ClassType types Type[] fields Collection{Field}) void
		(define superC (c:getSuperclass))
		(define filter (MFilter "<init>" types superC))
		(filter:searchDeclared)
		(define superCons (filter:getMethod))
		(define n (alen (superCons:getGenericParameterTypes)))
		(define params (Type[] len:(+ n (fields:size))))
		(System:arraycopy (superCons:getGenericParameterTypes) 0 params 0 n)
		(forEach (field i) fields
			(aset params (+ n i) (field:getType))
		)
		(define cons (c:addMethod "<init>" params Type:voidType 0))
		(define ncode (cons:startCode))
		(ncode:emitLoad (ncode:getArg 0))
		(for ((i 0)) (!= i n) (inc i)
			(ncode:emitLoad (ncode:getArg (+ i 1)))
		)
		(ncode:emitInvoke superCons)
		(forEach (field i) fields
			(ncode:emitPushThis)
			(ncode:emitLoad (ncode:getArg (+ n i 1)))
			(ncode:emitPutField field)
		)
		(ncode:emitReturn)
	)
	((compile tok ObjectToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(define ci tok:ci)
		(define emitters List{Emitter} (ArrayList{LexedParsedToken} tok:superArgs))
		(if (= ci null)
			(begin
				(define captureH (CaptureVHandler mi))
				;must wait until output is true
				;because the Variables in capturedH:captured
				;won't be valid if output is false
				(if output
					(begin
						(set ci (ClassInfo ((mi:ci:c:getName):concat ("$":concat (Integer:toString (mi:ci:anonClasses:size)))) mi:ci:fs))
						(set tok:ci ci)
						(mi:ci:anonClasses:add ci)
					)
				)
				(instanceCond tok
					(LambdaFnToken
						(define scope tok:scope)
						(define params tok:params)
						(define generics (ArrayList{Type} params))
						(define toks (ArrayList tok:toks))
						(if (= tok:t null)
							(begin
								(define fakemi (MethodInfo (ClassInfo (as ClassType null) mi:ci:fs) null null scope))
								(define beginTok (mi:transformBlockToks (BeginToken 0 toks)))
								(set tok:ret (Main:tryBox (captureH:compile beginTok fakemi null Main:unknownType)))
								(generics:add tok:ret)
								(define agenerics (Type[] len:(generics:size)))
								(generics:toArray agenerics)
								(set tok:t (ParameterizedType (ClassType:make (concat "sjava.std.Function" (params:size))) agenerics))
							)
						)
						(if output
							(begin
								(ci:c:addInterface tok:t)
								(ci:addMethod "apply" params tok:ret Access:PUBLIC tok:toks scope false)
							)
						)
					)
					(LambdaToken
						(if output
							(begin
								(ci:c:addInterface tok:t)
								(ci:addMethod (tok:sam:getName) tok:params (Main:resolveType tok:t (tok:sam:getReturnType)) Access:PUBLIC tok:toks tok:scope false)
							)
						)
					)
					(true
						(if output
							(begin
								(if ((as ClassType (tok:t:getRawType)):isInterface)
									(ci:c:addInterface tok:t)
									(ci:c:setSuper tok:t)
								)
								(forEach tok tok:toks
									(ci:compileDef (as BlockToken tok))
								)
							)
						)
					)
				)
				(if output
					(begin
						(ci:compileMethods captureH)
						(set tok:captured (captureH:captured:keySet))
						(this:createCtor ci:c (Emitter:emitAll emitters captureH mi null Main:unknownType) (captureH:captured:values))
					)
				)
			)
		)
		(if output
			(begin
				(this:code:emitNew ci:c)
				(this:code:emitDup)
				(forEach v tok:captured
					(emitters:add (LoadAVar v))
				)
				(Main:emitInvoke this "<init>" ci:c emitters mi this:code Main:unknownType)
			)
		)
		(this:castMaybe tok:t needed)
	)
	((compile tok MacroIncludeToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(if (= tok:ret null)
			(begin
				;dupped with runMethodMacro
				(define o 3)
				(define l (tok:toks:size))
				(define types (Type[] len:(+ o l) (Main:getCompilerType "AMethodInfo") Type:intType (Main:getCompilerType "handlers.GenHandler")))
				(for ((j 0)) (!= j l) (inc j)
					(aset types (+ o j) (Main:getCompilerType "tokens.LexedParsedToken"))
				)
				(define method Method null)
				(define ci ClassInfo null)
				(for ((i 0)) (= method null) (inc i)
					(set ci ((mi:ci:fs:macroNames:get tok:name):get i))
					(define filter (MFilter tok:name types ci:c))
					(filter:searchDeclared)
					(set method (filter:getMethod))
				)
				(define params (method:getGenericParameterTypes))
				(define classes (mapA t params (t:getReflectClass)))
				(define args (ArrayList (Arrays:asList (Object[] mi (mi:levels:size) this))))
				(args:addAll
					(if (!= (& (method:getModifiers) Access:TRANSIENT) 0)
						(begin
							(define var (- (alen params) o 1))
							(define al (ArrayList (tok:toks:subList 0 var)))
							(define out (LexedParsedToken[] len:(- (tok:toks:size) var)))
							((tok:toks:subList var (tok:toks:size)):toArray out)
							(al:add out)
							al
						)
						(as ArrayList tok:toks)
					)
				)
				(try
					(begin
						(define clazz (ci:getClazz))
						(define method (clazz:getMethod tok:name classes))
						(define ret (as LexedParsedToken (method:invoke null (args:toArray))))
						(set tok:ret (mi:transformBlock ret))
					)
					(e NoSuchMethodException (throw (RuntimeException e)))
					(e IllegalAccessException (throw (RuntimeException e)))
					(e java.lang.reflect.InvocationTargetException (throw (RuntimeException e)))
				)
			)
		)
		(define out (this:compile tok:ret mi this:code needed))
		(this:castMaybe out needed)
	)
	((compile tok BeginToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(mi:pushScope this:code tok:labels)
		(this:compileAll tok:toks 0 (- (tok:toks:size) 1) mi this:code Type:voidType)
		(define type (this:compile (tok:toks:get (- (tok:toks:size) 1)) mi this:code needed))
		(mi:popScope this:code)
		type
	)
	((compile tok SpecialBeginToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		;tok:labels
		(this:compileAll tok:toks 0 (- (tok:toks:size) 1) mi this:code Type:voidType)
		(this:compile (tok:toks:get (- (tok:toks:size) 1)) mi this:code needed)
	)
	((compile tok LabelToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(define label (mi:getLabel tok:label))
		(if output (label:define this:code))
		Type:voidType
	)
	((compile tok GotoToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(if output (this:code:emitGoto (mi:getLabel tok:label)))
		Type:voidType
	)
	((compile tok DefineToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(define type
			(if (= tok:tok null)
				(begin
					(if output (this:code:emitPushDefaultValue tok:type))
					tok:type
				)
				(this:compile tok:tok mi this:code tok:type)
			)
		)
		(define var (mi:newVar this:code tok:name type))
		(if output (this:code:emitStore var))
		Type:voidType
	)
	((compile tok TryToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(define type (this:compile tok:tok mi null needed))
		(define hasFinally (!= tok:finallyToks null))
		(if output (this:code:emitTryStart hasFinally type))
		(this:compile tok:tok mi this:code needed)
		(forEach catch tok:catches
			(mi:pushScope this:code (Collections:emptyMap)) ;catch:labels
			(define var (mi:newVar this:code catch:_1 catch:_2))
			(if output (this:code:emitCatchStart var))
			(this:compileAll catch:_3 0 (- (catch:_3:size) 1) mi this:code Type:voidType)
			(this:compile (catch:_3:get (- (catch:_3:size) 1)) mi type)
			(if output (this:code:emitCatchEnd))
			(mi:popScope this:code)
		)
		(if hasFinally
			(begin
				(if output (this:code:emitFinallyStart))
				(this:compileAll tok:finallyToks 0 (- (tok:finallyToks:size) 1) mi this:code Type:voidType)
				(this:compile (tok:finallyToks:get (- (tok:finallyToks:size) 1)) mi type)
				(if output (this:code:emitFinallyEnd))
			)
		)
		(if output (this:code:emitTryCatchEnd))
		(this:castMaybe type needed)
	)
	((compile tok InstanceToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(this:compile tok:tok mi this:code Main:unknownType)
		(if output (this:code:emitInstanceof tok:type))
		(this:castMaybe Type:booleanType needed)
	)
	((compile tok SetToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(define first (tok:toks:get 0))
		(define out (tok:toks:get 1))
		(instanceCond out
			(FieldToken
				(define t (mi:getType out:left))
				(if (= t null)
					(set t (this:compile out:left mi this:code Main:unknownType))
				)
				(define class ClassType (t:getRawType))
				(define field Field (class:getField out:right -1))
				(this:compile (tok:toks:get 2) mi this:code (Main:resolveType t (field:getType)))
				(if (field:getStaticFlag)
					(if output (this:code:emitPutStatic field))
					(if output (this:code:emitPutField field))
				)
			)
			(VToken
				(define var (mi:getVar out))
				(while (instance? var CastVar)
					(mi:removeVar out)
					(set var (mi:getVar out))
				)
				(this:compile (tok:toks:get 2) mi this:code var:type)
				(var:store this:code)
			)
			(true
				(throw (RuntimeException))
			)
		)
		Type:voidType
	)
	((compile tok ASetToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(define type ArrayType (this:compile tok:array mi this:code Main:unknownType))
		(this:compile tok:index mi this:code Type:intType)
		(this:compile tok:el mi this:code type:elements)
		(if output (this:code:emitArrayStore))
		Type:voidType
	)
	((compile tok AGetToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(define type ArrayType (this:compile (tok:toks:get 0) mi this:code Main:unknownType))
		(for ((i 1)) (< i (tok:toks:size)) (inc i)
			(this:compile (tok:toks:get i) mi this:code Type:intType)
			(if output (this:code:emitArrayLoad))
			(if (!= i 1) (set type (as ArrayType type:elements))) ;multi-dim arrays
		)
		(this:castMaybe type:elements needed)
	)
	((compile tok ALenToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(this:compile tok:tok mi this:code Main:unknownType)
		(if output (this:code:emitArrayLength))
		(this:castMaybe Type:intType needed)
	)
	((compile tok AsToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(this:castMaybe (this:compile tok:tok mi this:code tok:type) needed)
	)
	((compile tok NumOpToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(define otype (Main:numericOpType (this:compileAll tok:toks 0 (tok:toks:size) mi null Main:unknownType)))
		(this:compile (tok:toks:get 0) mi this:code otype)
		(if (&& (tok:op:equals "-") (= (tok:toks:size) 1))
			(if output
				(this:code:emitPrimop
					(cond
						((= otype Type:longType) 117)
						((= otype Type:floatType) 118)
						((= otype Type:doubleType) 119)
						(true 116)
					)
					1
					otype
				)
			)
			(for ((i 1)) (!= i (tok:toks:size)) (inc i)
				(this:compile (tok:toks:get i) mi this:code otype)
				(if output (this:code:emitBinop (Main:binOps:get tok:op) otype))
			)
		)
		(this:castMaybe otype needed)
	)
	((compile tok ShiftToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(define otype (PrimType:unboxedType (this:compile tok:tok mi null Main:unknownType)))
		(this:compile tok:tok mi this:code otype)
		(this:compile tok:amt mi this:code Type:intType)
		(if output (if tok:right (this:code:emitShr) (this:code:emitShl)))
		(this:castMaybe otype needed)
	)
	((compile tok IfToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(define hasElse (= (tok:toks:size) 4))
		(this:emitIf false (tok:toks:get 1) (tok:toks:get 2) (if hasElse (tok:toks:get 3) Nothing:inst) mi (if hasElse needed Type:voidType)):_1
	)
	((compile tok CompareToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(this:emitIf_ false tok:toks tok:compare (ConstToken tok:line "true") (ConstToken tok:line "false") mi needed):_1
	)
	((compile tok ThrowToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(this:compile tok:tok mi this:code Main:unknownType)
		(if output (this:code:emitThrow))
		Main:throwType
	)
	((compile tok ClassToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(if output (this:code:emitPushClass (as ObjectType (tok:type:getRawType))))
		(this:castMaybe Type:javalangClassType needed)
	)
	((compile tok SynchronizedToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(this:compile (tok:toks:get 1) mi this:code Main:unknownType)
		(mi:pushScope null tok:labels)
		(this:compileAll tok:toks 2 (- (tok:toks:size) 1) mi null Type:voidType)
		(define type (this:compile (tok:toks:get (- (tok:toks:size) 1)) mi null needed))
		(mi:popScope null)
		(mi:pushScope this:code tok:labels)
		(define obj (if output (this:code:addLocal Type:objectType) null))
		(if output (this:code:emitDup))
		(if output (this:code:emitStore obj))
		(if output (this:code:emitMonitorEnter))
		(if output (this:code:emitTryStart true type))
		(this:compileAll tok:toks 2 (- (tok:toks:size) 1) mi this:code Type:voidType)
		(this:compile (tok:toks:get (- (tok:toks:size) 1)) mi this:code needed)
		(if output (this:code:emitFinallyStart))
		(if output (this:code:emitLoad obj))
		(if output (this:code:emitMonitorExit))
		(if output (this:code:emitFinallyEnd))
		(if output (this:code:emitTryCatchEnd))
		(mi:popScope this:code)
		(this:castMaybe type needed)
	)
	((compile tok TypeToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(if output (this:code:emitLoad (this:code:getArg 2)))
		(if output (this:code:emitLoad (this:code:getArg 0)))
		(this:compile tok:tok mi this:code Main:unknownType)
		(if output (this:code:emitInvoke ((Main:getCompilerType "AMethodInfo"):getDeclaredMethod "transformBlock" 1)))
		(if output (this:code:emitLoad (this:code:getArg 0)))
		(if output (this:code:emitPushNull))
		(if output (this:code:emitGetStatic ((Main:getCompilerType "Main"):getField "unknownType")))
		(if output
			(this:code:emitInvoke
				((Main:getCompilerType "handlers.GenHandler"):getDeclaredMethod "compile"
					(Type[]
						(Main:getCompilerType "tokens.Token")
						(Main:getCompilerType "AMethodInfo")
						(ClassType:make "gnu.bytecode.CodeAttr")
						(ClassType:make "gnu.bytecode.Type")
					)
				)
			)
		)
		(this:castMaybe (Type:getType "gnu.bytecode.Type") needed)
	)
	((compile tok ReturnToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(if (!= tok:tok null)
			(this:compile tok:tok mi this:code Main:unknownType)
		)
		(if output (this:code:emitReturn))
		Main:returnType
	)
	((compile tok CallToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(define special
			(&&
				(instance? tok:target VToken)
				((as VToken tok:target):val:equals "super")
			)
		)
		(define t
			(if special
				(begin
					(if output (this:code:emitPushThis))
					(mi:ci:c:getGenericSuperclass)
				)
				(mi:getType tok:target)
			)
		)
		(if (= t null)
			(set t (this:compile tok:target mi this:code Main:unknownType))
		)
		(Main:emitInvoke this tok:method t (Main:toEmitters tok:toks) mi this:code needed special):_1
	)
	((compile tok DefaultToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(define first (tok:toks:get 0))
		(define t (this:compile first mi this:code Main:unknownType))
		(define c ClassType (t:getRawType))
		(define method (c:getDeclaredMethods))
		(define i 0)
		(define tocall Method null)
		(while (!= method null)
			(if (&& (! ((method:getName):equals "<init>")) (= 0 (& Access:SYNTHETIC (method:getModifiers))))
				(if (= tocall null)
					(set tocall method)
					(throw (RuntimeException))
				)
			)
			(set method (method:getNext))
		)
		(Main:emitInvoke this (tocall:getName) t (Main:toEmitters (tok:toks:subList 1 (tok:toks:size))) mi this:code needed):_1
	)
	((compile tok ConstructorToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(define class ClassType (tok:type:getRawType))
		(if output (this:code:emitNew class))
		(if output (this:code:emitDup))
		(define mc (Main:emitInvoke this "<init>" tok:type (Main:toEmitters tok:toks) mi this:code Main:unknownType):_2)
		(if
			(&&
				(instance? tok:type ClassType)
				(!= ((as ClassType tok:type):getTypeParameters) null)
				(!= (alen ((as ClassType tok:type):getTypeParameters)) 0)
			)
			(begin
				(define tparams ((as ClassType tok:type):getTypeParameters))
				(define ptype (ParameterizedType (as ClassType tok:type) tparams))
				(this:castMaybe (Main:resolveType mc:tvs ptype) needed)
			)
			(this:castMaybe tok:type needed)
		)
	)
	((compile tok ArrayConstructorToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(define array ArrayType tok:type)
		(if (!= tok:len null)
			(this:compile tok:len mi this:code Main:unknownType)
			(if output (this:code:emitPushInt (tok:toks:size)))
		)
		(if output (this:code:emitNewArray (array:elements:getRawType)))
		(for ((i 0)) (!= i (tok:toks:size)) (inc i)
			(if output (this:code:emitDup))
			(if output (this:code:emitPushInt i))
			(this:compile (tok:toks:get i) mi this:code array:elements)
			(if output (this:code:emitArrayStore))
		)
		(this:castMaybe tok:type needed)
	)
	((compile tok Token mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(if output (this:code:putLineNumber (mi:ci:fs:path:substring (+ (mi:ci:fs:path:lastIndexOf "/") 1)) tok:line))
		(try
			(begin
				(define t (super:compile tok mi needed))
				(if
					(&&
						(!= needed Main:unknownType)
						(!= t Main:returnType)
						(!= t Main:throwType)
						(! (Type:isSame needed t))
					)
					(throw (RuntimeException (concat t " vs " needed)))
				)
				t
			)
			(e Throwable
				(System:out:println (mi:ci:fs:path:concat (": Error compiling line ":concat (Integer:toString tok:line))))
				(throw e)
			)
		)
	)
)

(define-class CaptureVHandler (GenHandler)
	(enc AMethodInfo)
	(captured Map{AVar Field})
	(n int)
	((<init> enc AMethodInfo) void
		(super:<init>)
		(set this:enc enc)
		(set this:captured (LinkedHashMap))
	)
	((assignField vcaptured VCaptured mi AMethodInfo code CodeAttr) void
		(define output (!= code null))
		(if (&& output (= vcaptured:field null))
			(begin
				(define new (mi:ci:c:addField ("captured$":concat (Integer:toString this:n)) vcaptured:type Access:SYNTHETIC))
				(inc this:n)
				(set vcaptured:field new)
				(this:captured:put vcaptured:avar new)
			)
		)
	)
	((compile tok VToken mi AMethodInfo needed Type) Type public
		(define output (!= this:code null))
		(define found (mi:getVar tok))
		(if (instance? found VCaptured)
			(this:assignField (as VCaptured found) mi this:code)
		)
		(this:castMaybe
			(if (= found null)
				(begin
					(define outer (this:enc:getVar tok))
					(if (= outer null) (throw (RuntimeException (tok:toString))))
					(define vcaptured (VCaptured outer null))
					(this:assignField vcaptured mi this:code)
					(mi:putCapturedVar tok vcaptured)
					(vcaptured:load this:code)
				)
				(found:load this:code)
			)
			needed
		)
	)
)
