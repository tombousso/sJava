(package sjava.compiler.handlers)

(import sjava.compiler.*)
(import sjava.compiler.mfilters.*)
(import sjava.compiler.emitters.*)
(import sjava.compiler.tokens.*)

(import java.util.*)
(import gnu.bytecode.*)

(define-class Handler () abstract public
	(mi AMethodInfo)
	((<init> mi AMethodInfo) void
		(super:<init>)
		(set this:mi mi)
	)
	((compileAll toks List{Token} i int e int needed Object) Type[] public
		(define l (toks:size))
		(define types (Type[] len:(- e i)))
		(for ((j i)) (! (>= j e)) (inc j)
			(aset types (- j i)
				(this:compile (toks:get j)
					(if (instance? needed Type[])
						(aget (as Type[] needed) (- j i))
						(as Type needed)
					)
				)
			)
		)
		types
	)
	((compile tok EmptyToken needed Type) Type public abstract)
	((compile tok SToken needed Type) Type public abstract)
	((compile tok CToken needed Type) Type public abstract)
	((compile tok NToken needed Type) Type public abstract)
	((compile tok FieldToken needed Type) Type public abstract)
	((compile tok QuoteToken2 needed Type) Type public abstract)
	((compile tok ConstToken needed Type) Type public abstract)
	((compile tok VToken needed Type) Type public abstract)
	((compile tok IncludeToken needed Type) Type public abstract)
	((compile tok ObjectToken needed Type) Type public abstract)
	((compile tok MacroIncludeToken needed Type) Type public abstract)
	((compile tok BeginToken needed Type) Type public abstract)
	((compile tok SpecialBeginToken needed Type) Type public abstract)
	((compile tok LabelToken needed Type) Type public abstract)
	((compile tok GotoToken needed Type) Type public abstract)
	((compile tok DefineToken needed Type) Type public abstract)
	((compile tok TryToken needed Type) Type public abstract)
	((compile tok InstanceToken needed Type) Type public abstract)
	((compile tok SetToken needed Type) Type public abstract)
	((compile tok ASetToken needed Type) Type public abstract)
	((compile tok AGetToken needed Type) Type public abstract)
	((compile tok ALenToken needed Type) Type public abstract)
	((compile tok AsToken needed Type) Type public abstract)
	((compile tok NumOpToken needed Type) Type public abstract)
	((compile tok ShiftToken needed Type) Type public abstract)
	((compile tok IfToken needed Type) Type public abstract)
	((compile tok CompareToken needed Type) Type public abstract)
	((compile tok ThrowToken needed Type) Type public abstract)
	((compile tok ClassToken needed Type) Type public abstract)
	((compile tok SynchronizedToken needed Type) Type public abstract)
	((compile tok TypeToken needed Type) Type public abstract)
	((compile tok ReturnToken needed Type) Type public abstract)
	((compile tok CallToken needed Type) Type public abstract)
	((compile tok DefaultToken needed Type) Type public abstract)
	((compile tok ConstructorToken needed Type) Type public abstract)
	((compile tok ArrayConstructorToken needed Type) Type public abstract)
	((compile tok Token needed Type) Type public
		(doubleDispatch (this:compile _ needed) tok)
	)
	((castMaybe result Type needed Type) Type public abstract)
)

(define-class GenHandler (Handler) public
	(code CodeAttr public)
	((<init> mi AMethodInfo) void public
		(super:<init> mi)
	)
	((compileAll toks List{Token} i int e int code CodeAttr needed Object) Type[] public
		(define ocode this:code)
		(set this:code code)
		(define out (this:compileAll toks i e needed))
		(set this:code ocode)
		out
	)
	((compile tok Token code CodeAttr needed Type) Type public
		(define ocode this:code)
		(set this:code code)
		(define out (this:compile tok needed))
		(set this:code ocode)
		out
	)
	((castMaybe result Type needed Type) Type public
		(GenHandler:castMaybe this:code result needed)
	)
	((castMaybe code CodeAttr result Type needed Type) Type public static
		(define output (!= code null))
		(if (|| (= needed Main:unknownType) (= result Main:returnType) (= result Main:throwType))
			result
			(begin
				(if (= needed Type:voidType)
					(if (!= result Type:voidType)
						(if output (code:emitPop 1))
					)
					(if (! (Type:isSame needed result))
						(if (instance? result PrimType)
							(begin
								(if (instance? needed ClassType)
									(if (= result Type:voidType)
										(if (= needed (Type:getType "java.lang.Void"))
											(if output (code:emitPushNull))
											(throw (RuntimeException))
										)
										(begin
											(define prim (PrimType:unboxedType needed))
											(define box
												(if (= prim null)
													(begin ;needed can be Object, Number, etc.
														(set prim result)
														((as PrimType result):boxedType)
													)
													(begin
														(if output (code:emitConvert (as PrimType result) prim))
														(as ClassType needed)
													)
												)
											)
											(if output (code:emitInvoke (box:getMethod "valueOf" (Type[] prim))))
										)
									)
									(if output (code:emitConvert (as PrimType result) (as PrimType needed)))
								)
							)
							(if (instance? needed PrimType)
								(begin
									(define unbox (Main:unboxMethods:get result))
									(if output (code:emitInvoke unbox))
									(if output (code:emitConvert (as PrimType (unbox:getReturnType)) (as PrimType needed)))
								)
								(if output (code:emitCheckcast (needed:getRawType)))
							)
						)
					)
				)
				needed
			)
		)
	)
	((emitTrueFalseClauses_ trueE Emitter falseE Emitter trueCasts List{Tuple2{VToken Type}} falseCasts List{Tuple2{VToken Type}} needed Type skipL Label trueL Label falseL Label) Tuple2{Type Type}
		(define output (!= this:code null))

		(this:mi:pushScope this:code (HashMap))
		(forEach cast trueCasts
			(this:putCast cast)
		)
		(if output (trueL:define this:code))
		(define trueT (trueE:emit this this:code needed))
		(this:mi:popScope this:code)

		(if (&& output (this:code:reachableHere)) (this:code:emitGoto skipL))

		(this:mi:pushScope this:code (HashMap))
		(forEach cast falseCasts
			(this:putCast cast)
		)
		(if output (falseL:define this:code))
		(define falseT (falseE:emit this this:code needed))
		(this:mi:popScope this:code)

		(if output (skipL:define this:code))

		(Tuple2 trueT falseT)
	)
	((emitTrueFalseClauses trueE Emitter falseE Emitter trueCasts List{Tuple2{VToken Type}} falseCasts List{Tuple2{VToken Type}} needed Type skipL Label trueL Label falseL Label) Tuple3{Type List{Tuple2{VToken Type}} List{Tuple2{VToken Type}}} public
		(if (= needed Main:unknownType)
			(begin
				(define ocode this:code)
				(set this:code null)
				(define ts (this:emitTrueFalseClauses_ trueE falseE trueCasts falseCasts needed skipL trueL falseL))
				(set this:code ocode)
				(set needed
					(Main:commonType
						ts:_1
						ts:_2
					)
				)
			)
		)
		(this:emitTrueFalseClauses_ trueE falseE trueCasts falseCasts needed skipL trueL falseL)
		(Tuple3 needed trueCasts falseCasts)
	)
	((emitGotoIf otype Type invCompare String compare String label Label) void public
		(define output (!= this:code null))
		(if (|| (= otype Type:doubleType) (= otype Type:floatType))
			(begin
				(define lt (|| (compare:equals "<") (compare:equals "<=")))
				(define op (if (= otype Type:doubleType) (if lt 151 152) (if lt 149 150)))
				(if output (this:code:emitPrimop op 2 Type:intType))
				(cond
					((invCompare:equals ">") (if output (this:code:emitGotoIfIntLeZero label)))
					((invCompare:equals ">=") (if output (this:code:emitGotoIfIntLtZero label)))
					((invCompare:equals "<") (if output (this:code:emitGotoIfIntGeZero label)))
					((invCompare:equals "<=") (if output (this:code:emitGotoIfIntGtZero label)))
					((invCompare:equals "=") (if output (this:code:emitGotoIfIntNeZero label)))
					((invCompare:equals "!=") (if output (this:code:emitGotoIfIntEqZero label)))
				)
			)
			(if output (this:code:emitGotoIfCompare2 label (Main:compare2Ops:get invCompare)))
		)
	)
	;toks = condition
	((emitIf_ inv bool toks List{Token} compare String trueE Emitter falseE Emitter needed Type) Tuple3{Type List{Tuple2{VToken Type}} List{Tuple2{VToken Type}}} public
		(define output (!= this:code null))

		(define trueCasts (ArrayList{Tuple2{VToken Type}}))
		(define falseCasts (ArrayList{Tuple2{VToken Type}}))
		(cond
			((compare:equals "!")
				(this:emitIf (! inv) (toks:get 0) trueE falseE needed)
			)
			((|| (compare:equals "&&") (compare:equals "||"))
				(define skipL (Label))
				(define trueL (Label))
				(define trueG (Goto trueL))
				(define falseL (Label))
				(define falseG (Goto falseL))
				(this:mi:pushScope this:code (HashMap))
				(if (|| (&& (! inv) (compare:equals "&&")) (&& inv (compare:equals "||")))
					;AND
					(begin
						(for ((i 0)) (!= i (- (toks:size) 1)) (inc i)
							(define a (this:emitIf inv (toks:get i) Nothing:inst falseG Type:voidType))
							(forEach cast a:_2
								(this:putCast cast)
							)
							(trueCasts:addAll a:_2)
						)
						(trueCasts:addAll (this:emitIf inv (toks:get (- (toks:size) 1)) Nothing:inst falseG Type:voidType):_2)
					)
					;OR
					(begin
						(for ((i 0)) (!= i (- (toks:size) 1)) (inc i)
							(define a (this:emitIf (! inv) (toks:get i) Nothing:inst trueG Type:voidType))
							(forEach cast a:_2
								(this:putCast cast)
							)
							(falseCasts:addAll a:_2)
						)
						(falseCasts:addAll (this:emitIf inv (toks:get (- (toks:size) 1)) Nothing:inst falseG Type:voidType):_2)
					)
				)
				(this:mi:popScope this:code)
				(this:emitTrueFalseClauses trueE falseE trueCasts falseCasts needed skipL trueL falseL)
			)
			(true
				(define trueL (Label))
				(define cast Tuple2{VToken Type} null)
				(define isFalseGoto (&& (instance? trueE Nothing) (instance? falseE Goto)))
				(define falseLabel
					(if isFalseGoto
						(as Goto falseE):label
						(Label)
					)
				)
				(define invCompare (Main:invertComp inv compare))
				(if (Main:compare1Ops:containsKey invCompare)
					(begin
						(for ((j 0)) (!= j (toks:size)) (inc j)
							(define tok (toks:get j))
							(if
								(&&
									(instance? tok InstanceToken)
									(instance? (as InstanceToken tok):tok VToken)
								)
								(begin
									(define it (as InstanceToken tok))
									(set cast (Tuple2 (as VToken it:tok) it:type))
								)
							)
							(define types (this:compileAll toks j (+ j 1) null Main:unknownType))
							(define otype (Main:compareType types))
							(this:compileAll toks j (+ j 1) otype)
							(if output (this:code:emitGotoIfCompare1 falseLabel (Main:compare1Ops:get invCompare)))
						)
					)
					(begin
						(if (&& (> (toks:size) 2) (compare:equals "!="))
							(throw (RuntimeException))
						)
						(define types (this:compileAll toks 0 (toks:size) null Main:unknownType))
						(define otype (Main:compareType types))
						(define special (&& inv (> (toks:size) 2)))
						(define vars (Variable[] len:(- (toks:size) 2)))
						(for ((j 1)) (< (+ j 1) (toks:size)) (inc j)
							(this:compile (toks:get j) otype)
							(if output
								(begin
									(define v (this:code:addLocal otype))
									(this:code:emitStore v)
									(aset vars (- j 1) v)
								)
							)
						)
						(this:compile (toks:get 0) otype)
						(for ((i 0)) (< i (alen vars)) (inc i)
							(if output (this:code:emitLoad (aget vars i)))
							(if special
								(this:emitGotoIf otype compare compare trueL)
								(this:emitGotoIf otype invCompare compare falseLabel)
							)
							(if output (this:code:emitLoad (aget vars i)))
						)
						(this:compile (toks:get (- (toks:size) 1)) otype)
						(if special
							(this:emitGotoIf otype compare compare trueL)
							(this:emitGotoIf otype invCompare compare falseLabel)
						)
						(if special
							(if output (this:code:emitGoto falseLabel))
						)
					)
				)
				(if (!= cast null)
					(if inv
						(falseCasts:add cast)
						(trueCasts:add cast)
					)
				)
				(cond
					(isFalseGoto
						(if output (trueL:define this:code))
						(Tuple3 Type:voidType trueCasts falseCasts)
					)
					(true
						(define casts (Arrays:asList (Tuple2[] cast)))
						(define trueCasts List{Tuple2{VToken Type}}
							(if (! inv)
								casts
								Collections:EMPTY_LIST
							)
						)
						(define falseCasts List{Tuple2{VToken Type}}
							(if inv
								casts
								Collections:EMPTY_LIST
							)
						)
						(this:emitTrueFalseClauses trueE falseE trueCasts falseCasts needed (Label) trueL falseLabel)
					)
				)
			)
		)
	)
	((putCast cast Tuple2{VToken Type}) void
		(if (!= cast null)
			(this:mi:putVar cast:_1 (CastVar (this:mi:getVar cast:_1) cast:_2))
		)
	)
	((emitIf inv bool cond Token trueE Emitter falseE Emitter needed Type) Tuple3{Type List{Tuple2{VToken Type}} List{Tuple2{VToken Type}}} public
		(instanceCond cond
			(CompareToken (this:emitIf_ inv cond:toks cond:compare trueE falseE needed))
			(true (this:emitIf_ inv (Arrays:asList (Token[] cond)) "!=0" trueE falseE needed))
		)
	)
	((compile tok EmptyToken needed Type) Type public
		Type:voidType
	)
	((compile tok SToken needed Type) Type public
		(define output (!= this:code null))
		(if output (this:code:emitPushString tok:val))
		(this:castMaybe Type:javalangStringType needed)
	)
	((compile tok CToken needed Type) Type public
		(define output (!= this:code null))
		(define c int tok:val)
		(if (! (instance? needed PrimType))
			(begin
				(if output (this:code:emitPushInt c))
				(this:castMaybe Type:charType needed)
			)
			(begin
				(if output (this:code:emitPushConstant c needed))
				needed
			)
		)
	)
	((compile tok NToken needed Type) Type public
		(define output (!= this:code null))
		(define val tok:val)
		(this:castMaybe
			(instanceCond val
				(Double
					(if output (this:code:emitPushDouble val))
					Type:doubleType
				)
				(Float
					(if output (this:code:emitPushFloat val))
					Type:floatType
				)
				(Integer
					(if (Main:isNumeric needed)
						(begin
							(define prim (Main:tryUnbox needed))
							(if output (this:code:emitPushConstant val prim))
							prim
						)
						(begin
							(if output (this:code:emitPushInt val))
							Type:intType
						)
					)
				)
				(Long
					(if output (this:code:emitPushLong val))
					Type:longType
				)
				(true (throw (RuntimeException)))
			)
			needed
		)
	)
	((getField tok FieldToken) Tuple2{Type Field}
		(define staticTarget true)
		(define t Type
			(if
				(&&
					(instance? tok:left VToken)
					((as VToken tok:left):val:equals "static")
				)
				this:mi:ci:c
				(begin
					(define t2 (this:mi:getType tok:left))
					(when (= t2 null)
						(set t2 (this:compile tok:left this:code Main:unknownType))
						(set staticTarget false)
					)
					t2
				)
			)
		)
		(define class ClassType (t:getRawType))
		(Tuple2
			t
			(if staticTarget
				(class:getDeclaredField tok:right)
				(class:getField tok:right -1)
			)
		)
	)
	((compile tok FieldToken needed Type) Type public
		(define output (!= this:code null))
		(define tup (this:getField tok))
		(define field tup:_2)
		(if (field:getStaticFlag)
			(if output (this:code:emitGetStatic field))
			(if output (this:code:emitGetField field))
		)
		(define out (Main:resolveType tup:_1 (field:getType)))
		(if (!= out Type:voidType)
			(if output (this:code:emitCheckcast (out:getRawType)))
		)
		(this:castMaybe out needed)
	)
	((compileQuasi o Object code CodeAttr needed Type) Type
		(define ocode this:code)
		(set this:code code)
		(define out (this:compileQuasi o needed))
		(set this:code ocode)
		out
	)
	((compileQuasi o Object needed Type) Type
		(define output (!= this:code null))
		(if (= o null)
			(begin
				(if output (this:code:emitPushNull))
				(return needed)
			)
		)
		(define result Type
			(instanceCond o
				(UnquoteToken
					(define tok (this:mi:transformBlock (o:toks:get 0)))
					(define t (this:compile tok null Main:unknownType))
					(cond
						((= t (Type:getType "gnu.bytecode.Type"))
							(this:compile tok this:code Main:unknownType)
							(if output (this:code:emitInvoke ((Main:getCompilerType "Main"):getDeclaredMethod "typeToTok" 1)))
							(Main:getCompilerType "tokens.LexedParsedToken")
						)
						(
							(||
								(>= (Main:compare (Main:getCompilerType "tokens.LexedParsedToken") t) 0)
								;(&&
								(instance? t ArrayType)
								;	(= (as ArrayType t):elements (Main:getCompilerType "tokens.LexedParsedToken"))
								;)
								((t:getRawType):isSubtype (Type:getType "java.util.List"))
							)
							(this:compile tok this:code Main:unknownType)
						)
						(true
							(define t (this:compile tok null Main:unknownType))
							(define type ClassType
								(Main:getCompilerType
									(if o:var
										"tokens.VToken"
										(if (= t Type:charType)
											"tokens.CToken"
											(if (instance? t PrimType)
												"tokens.NToken"
												"tokens.SToken"
											)
										)
									)
								)
							)
							(if output (this:code:emitNew type))
							(if output (this:code:emitDup))
							(if output (this:code:emitInvoke (type:getDeclaredMethod "<init>" 0)))
							(if output (this:code:emitDup))
							(this:compile tok this:code Type:objectType)
							(if output (this:code:emitPutField (type:getField "val")))
							(Main:getCompilerType "tokens.LexedParsedToken")
						)
					)
				)
				(LexedParsedToken
					(define type ClassType (Type:getType ((o:getClass):getName)))
					(if output (this:code:emitNew type))
					(if output (this:code:emitDup))
					(if output (this:code:emitInvoke (type:getDeclaredMethod "<init>" 0)))
					(define superC type)
					(while (!= superC null)
						(define field (superC:getFields))
						(while (!= field null)
							(if
								(&&
									(!= (& (field:getModifiers) Access:PUBLIC) 0)
									(= (& (field:getModifiers) Access:TRANSIENT) 0)
									(= (& (field:getModifiers) Access:STATIC) 0)
								)
								(begin
									(if output (this:code:emitDup))
									(try
										(this:compileQuasi ((field:getReflectField):get o) this:code (field:getType))
										(e NoSuchFieldException (throw (RuntimeException e)))
										(e IllegalAccessException (throw (RuntimeException e)))
									)
									(if output (this:code:emitPutField field))
								)
							)
							(set field (field:getNext))
						)
						(set superC (superC:getSuperclass))
					)
					(if (= type (Main:getCompilerType "tokens.VToken"))
						(begin
							(if output (this:code:emitDup))
							(cond
								((instance? this:mi:ci MethodMacroInfo)
									(if output (this:code:emitPushInt 0))
								)
								((instance? this:mi:ci MacroInfo)
									(if output (this:code:emitLoad (this:code:getArg 1)))
								)
							)
							(if output (this:code:emitPutField (type:getField "macro")))
						)
					)
					type
				)
				(String
					(if output (this:code:emitPushString o))
					Type:javalangStringType
				)
				(Integer
					(if output (this:code:emitPushInt o))
					Type:intType
				)
				(Long
					(if output (this:code:emitPushLong o))
					Type:longType
				)
				(Double
					(if output (this:code:emitPushDouble o))
					Type:doubleType
				)
				(Float
					(if output (this:code:emitPushFloat o))
					Type:floatType
				)
				(Boolean
					(if output (this:code:emitPushInt (if o 1 0)))
					Type:booleanType
				)
				(List
					(define al ClassType (Type:getType "java.util.ArrayList"))
					(if output (this:code:emitNew al))
					(if output (this:code:emitDup))
					(if output (this:code:emitInvoke (al:getMethod "<init>" (Type[]))))
					(define i 0)
					(forEach a o
						(define t (this:compileQuasi a null Main:unknownType))
						(if (>= (Main:compare (Main:getCompilerType "tokens.LexedParsedToken") t) 0)
							(begin
								(if output (this:code:emitDup))
								(this:compileQuasi a this:code Main:unknownType)
								(if output (this:code:emitInvoke (al:getMethod "add" (Type[] Type:objectType))))
								(if output (this:code:emitPop 1))
							)
							(if (instance? t ArrayType)
								(begin
									(if output (this:code:emitDup))
									(this:compileQuasi a this:code Main:unknownType)
									(if output (this:code:emitInvoke ((as ClassType (Type:getType "java.util.Collections")):getDeclaredMethod "addAll" 2)))
									(if output (this:code:emitPop 1))
								)
								(begin
									(if output (this:code:emitDup))
									(this:compileQuasi a this:code Main:unknownType)
									(if output (this:code:emitInvoke ((as ClassType (Type:getType "java.util.List")):getDeclaredMethod "addAll" 1)))
									(if output (this:code:emitPop 1))
								)
							)
						)
					)
					al
				)
				(true
					(throw (RuntimeException ((o:getClass):toString)))
				)
			)
		)
		(this:castMaybe result needed)
	)
	((compile tok QuoteToken2 needed Type) Type public
		(define output (!= this:code null))
		(this:castMaybe (this:compileQuasi tok:tok this:code Main:unknownType) needed)
	)
	((compile tok ConstToken needed Type) Type public
		(define output (!= this:code null))
		(this:castMaybe
			(if (tok:val:equals "true")
				(begin
					(if output (this:code:emitPushInt 1))
					Type:booleanType
				)
				(if (tok:val:equals "false")
					(begin
						(if output (this:code:emitPushInt 0))
						Type:booleanType
					)
					(begin
						(if output (this:code:emitPushNull))
						Type:nullType
					)
				)
			)
			needed
		)
	)
	((compile tok VToken needed Type) Type public
		(define output (!= this:code null))
		(define found (this:mi:getVar tok))
		(this:castMaybe (found:load this:code) needed)
	)
	((compile tok IncludeToken needed Type) Type public
		(define output (!= this:code null))
		(if (= tok:ret null)
			(begin
				(this:mi:ci:fs:compileInclude tok)
				(try
					(set tok:ret
						(this:mi:transformBlock
							(as LexedParsedToken
								(
									((this:mi:ci:fs:includes:getClazz):getMethod (tok:mi:method:getName)
										(Class[]
											(class AMethodInfo)
											Integer:TYPE
											(class GenHandler)
										)
									):invoke
									null
									(Object[] this:mi 0 this)
								)
							)
						)
					)
					(e NoSuchMethodException (throw (RuntimeException e)))
					(e IllegalAccessException (throw (RuntimeException e)))
					(e java.lang.reflect.InvocationTargetException (throw (RuntimeException e)))
				)
			)
		)
		(this:castMaybe (this:compile tok:ret this:code needed) needed)
	)
	((createCtor c ClassType types Type[] fields Collection{Field}) void
		(define superC (c:getSuperclass))
		(define filter (MFilter "<init>" types superC false))
		(filter:searchDeclared)
		(define superCons (filter:getMethod))
		(define n (alen (superCons:getGenericParameterTypes)))
		(define params (Type[] len:(+ n (fields:size))))
		(System:arraycopy (superCons:getGenericParameterTypes) 0 params 0 n)
		(forEach (field i) fields
			(aset params (+ n i) (field:getType))
		)
		(define cons (c:addMethod "<init>" params Type:voidType 0))
		(define ncode (cons:startCode))
		(ncode:emitLoad (ncode:getArg 0))
		(for ((i 0)) (!= i n) (inc i)
			(ncode:emitLoad (ncode:getArg (+ i 1)))
		)
		(ncode:emitInvoke superCons)
		(forEach (field i) fields
			(ncode:emitPushThis)
			(ncode:emitLoad (ncode:getArg (+ n i 1)))
			(ncode:emitPutField field)
		)
		(ncode:emitReturn)
	)
	((compile tok ObjectToken needed Type) Type public
		(define output (!= this:code null))
		(define ci tok:ci)
		(define emitters List{Emitter} (ArrayList{LexedParsedToken} tok:superArgs))
		(if (= ci null)
			(begin
				;must wait until output is true
				;because the Variables in capturedH:captured
				;won't be valid if output is false
				(if output
					(begin
						(set ci
							(ClassInfo
								(concat
									(this:mi:ci:c:getName)
									"$"
									(this:mi:ci:anonClasses:size)
								)
								this:mi:ci:fs
							)
						)
						(set tok:ci ci)
						(this:mi:ci:anonClasses:add ci)
					)
				)
				(instanceCond tok
					(LambdaFnToken
						(define scope tok:scope)
						(define params tok:params)
						(define generics (ArrayList{Type} params))
						(define toks (ArrayList tok:toks))
						(if (= tok:t null)
							(begin
								(define fakemi (MethodInfo (ClassInfo (as ClassType null) this:mi:ci:fs) null null scope))
								(define beginTok (this:mi:transformBlockToks (BeginToken 0 toks)))
								(define captureH (CaptureVHandler fakemi this:mi (LinkedHashMap)))
								(set tok:ret (Main:tryBox (captureH:compile beginTok null Main:unknownType)))
								(generics:add tok:ret)
								(define agenerics (Type[] len:(generics:size)))
								(generics:toArray agenerics)
								(set tok:t (ParameterizedType (ClassType:make (concat "sjava.std.Function" (params:size))) agenerics))
							)
						)
						(if output
							(begin
								(ci:c:addInterface tok:t)
								(ci:addMethod "apply" params tok:ret Access:PUBLIC tok:toks scope false)
							)
						)
					)
					(LambdaToken
						(if output
							(begin
								(ci:c:addInterface tok:t)
								(ci:addMethod (tok:sam:getName) tok:params (Main:resolveType tok:t (tok:sam:getReturnType)) Access:PUBLIC tok:toks tok:scope false)
							)
						)
					)
					(true
						(if output
							(begin
								(if ((as ClassType (tok:t:getRawType)):isInterface)
									(ci:c:addInterface tok:t)
									(ci:c:setSuper tok:t)
								)
								(forEach tok tok:toks
									(ci:compileDef (as BlockToken tok))
								)
							)
						)
					)
				)
				(if output
					(begin
						(define captured (LinkedHashMap))
						(forEach mi ci:methods
							(define captureH (CaptureVHandler mi this:mi captured))
							(mi:compileMethodBody captureH)
						)
						(set tok:captured (captured:keySet))
						(this:createCtor ci:c (Emitter:emitAll emitters this null Main:unknownType) (captured:values))
					)
				)
			)
		)
		(if output
			(begin
				(this:code:emitNew ci:c)
				(this:code:emitDup)
				(forEach v tok:captured
					(emitters:add (LoadAVar v))
				)
				(Main:emitInvoke this "<init>" ci:c emitters Main:unknownType false)
			)
		)
		(this:castMaybe tok:t needed)
	)
	((compile tok MacroIncludeToken needed Type) Type public
		(define output (!= this:code null))
		(if (= tok:ret null)
			(begin
				;dupped with runMethodMacro
				(define o 3)
				(define l (tok:toks:size))
				(define types (Type[] len:(+ o l) (Main:getCompilerType "AMethodInfo") Type:intType (Main:getCompilerType "handlers.GenHandler")))
				(for ((j 0)) (!= j l) (inc j)
					(aset types (+ o j) (Main:getCompilerType "tokens.LexedParsedToken"))
				)
				(define method Method null)
				(define ci ClassInfo null)
				(for ((i 0)) (= method null) (inc i)
					(set ci ((this:mi:ci:fs:macroNames:get tok:name):get i))
					(define filter (MFilter tok:name types ci:c true))
					(filter:searchDeclared)
					(set method (filter:getMethod))
				)
				(define params (method:getGenericParameterTypes))
				(define classes (mapA t params (t:getReflectClass)))
				(define args (ArrayList (Arrays:asList (Object[] this:mi (this:mi:levels:size) this))))
				(args:addAll
					(if (!= (& (method:getModifiers) Access:TRANSIENT) 0)
						(begin
							(define var (- (alen params) o 1))
							(define al (ArrayList (tok:toks:subList 0 var)))
							(define out (LexedParsedToken[] len:(- (tok:toks:size) var)))
							((tok:toks:subList var (tok:toks:size)):toArray out)
							(al:add out)
							al
						)
						(as ArrayList tok:toks)
					)
				)
				(try
					(begin
						(define clazz (ci:getClazz))
						(define method (clazz:getMethod tok:name classes))
						(define ret (as LexedParsedToken (method:invoke null (args:toArray))))
						(set tok:ret (this:mi:transformBlock ret))
					)
					(e NoSuchMethodException (throw (RuntimeException e)))
					(e IllegalAccessException (throw (RuntimeException e)))
					(e java.lang.reflect.InvocationTargetException (throw (RuntimeException e)))
				)
			)
		)
		(define out (this:compile tok:ret this:code needed))
		(this:castMaybe out needed)
	)
	((compile tok BeginToken needed Type) Type public
		(define output (!= this:code null))
		(this:mi:pushScope this:code tok:labels)
		(this:compileAll tok:toks 0 (- (tok:toks:size) 1) this:code Type:voidType)
		(define type (this:compile (tok:toks:get (- (tok:toks:size) 1)) this:code needed))
		(this:mi:popScope this:code)
		type
	)
	((compile tok SpecialBeginToken needed Type) Type public
		(define output (!= this:code null))
		;tok:labels
		(this:compileAll tok:toks 0 (- (tok:toks:size) 1) this:code Type:voidType)
		(this:compile (tok:toks:get (- (tok:toks:size) 1)) this:code needed)
	)
	((compile tok LabelToken needed Type) Type public
		(define output (!= this:code null))
		(define label (this:mi:getLabel tok:label))
		(if output (label:define this:code))
		Type:voidType
	)
	((compile tok GotoToken needed Type) Type public
		(define output (!= this:code null))
		(if output (this:code:emitGoto (this:mi:getLabel tok:label)))
		Type:voidType
	)
	((compile tok DefineToken needed Type) Type public
		(define output (!= this:code null))
		(define type
			(if (= tok:tok null)
				(begin
					(if output (this:code:emitPushDefaultValue tok:type))
					tok:type
				)
				(this:compile tok:tok this:code tok:type)
			)
		)
		(define var (this:mi:newVar this:code tok:name type))
		(if output (this:code:emitStore var))
		Type:voidType
	)
	((compile tok TryToken needed Type) Type public
		(define output (!= this:code null))
		(define type (this:compile tok:tok null needed))
		(define hasFinally (!= tok:finallyToks null))
		(if output (this:code:emitTryStart hasFinally type))
		(this:compile tok:tok this:code needed)
		(forEach catch tok:catches
			(this:mi:pushScope this:code (Collections:emptyMap)) ;catch:labels
			(define var (this:mi:newVar this:code catch:_1 catch:_2))
			(if output (this:code:emitCatchStart var))
			(this:compileAll catch:_3 0 (- (catch:_3:size) 1) this:code Type:voidType)
			(this:compile (catch:_3:get (- (catch:_3:size) 1)) type)
			(if output (this:code:emitCatchEnd))
			(this:mi:popScope this:code)
		)
		(if hasFinally
			(begin
				(if output (this:code:emitFinallyStart))
				(this:compileAll tok:finallyToks 0 (- (tok:finallyToks:size) 1) this:code Type:voidType)
				(this:compile (tok:finallyToks:get (- (tok:finallyToks:size) 1)) type)
				(if output (this:code:emitFinallyEnd))
			)
		)
		(if output (this:code:emitTryCatchEnd))
		(this:castMaybe type needed)
	)
	((compile tok InstanceToken needed Type) Type public
		(define output (!= this:code null))
		(this:compile tok:tok this:code Main:unknownType)
		(if output (this:code:emitInstanceof tok:type))
		(this:castMaybe Type:booleanType needed)
	)
	((compile tok SetToken needed Type) Type public
		(define output (!= this:code null))
		(define first (tok:toks:get 0))
		(define out (tok:toks:get 1))
		(instanceCond out
			(FieldToken
				(define tup (this:getField (as FieldToken out)))
				(define field tup:_2)
				(this:compile (tok:toks:get 2) this:code (Main:resolveType tup:_1 (field:getType)))
				(if (field:getStaticFlag)
					(if output (this:code:emitPutStatic field))
					(if output (this:code:emitPutField field))
				)
			)
			(VToken
				(define var (this:mi:getVar out))
				(while (instance? var CastVar)
					(this:mi:removeVar out)
					(set var (this:mi:getVar out))
				)
				(this:compile (tok:toks:get 2) this:code var:type)
				(var:store this:code)
			)
			(true
				(throw (RuntimeException))
			)
		)
		Type:voidType
	)
	((compile tok ASetToken needed Type) Type public
		(define output (!= this:code null))
		(define type ArrayType (this:compile tok:array this:code Main:unknownType))
		(this:compile tok:index this:code Type:intType)
		(this:compile tok:el this:code type:elements)
		(if output (this:code:emitArrayStore))
		Type:voidType
	)
	((compile tok AGetToken needed Type) Type public
		(define output (!= this:code null))
		(define type ArrayType (this:compile (tok:toks:get 0) this:code Main:unknownType))
		(for ((i 1)) (< i (tok:toks:size)) (inc i)
			(this:compile (tok:toks:get i) this:code Type:intType)
			(if output (this:code:emitArrayLoad))
			(if (!= i 1) (set type (as ArrayType type:elements))) ;multi-dim arrays
		)
		(this:castMaybe type:elements needed)
	)
	((compile tok ALenToken needed Type) Type public
		(define output (!= this:code null))
		(this:compile tok:tok this:code Main:unknownType)
		(if output (this:code:emitArrayLength))
		(this:castMaybe Type:intType needed)
	)
	((compile tok AsToken needed Type) Type public
		(define output (!= this:code null))
		(this:castMaybe (this:compile tok:tok this:code tok:type) needed)
	)
	((compile tok NumOpToken needed Type) Type public
		(define output (!= this:code null))
		(define otype (Main:numericOpType (this:compileAll tok:toks 0 (tok:toks:size) null Main:unknownType)))
		(this:compile (tok:toks:get 0) this:code otype)
		(if (&& (tok:op:equals "-") (= (tok:toks:size) 1))
			(if output
				(this:code:emitPrimop
					(cond
						((= otype Type:longType) 117)
						((= otype Type:floatType) 118)
						((= otype Type:doubleType) 119)
						(true 116)
					)
					1
					otype
				)
			)
			(for ((i 1)) (!= i (tok:toks:size)) (inc i)
				(this:compile (tok:toks:get i) this:code otype)
				(if output (this:code:emitBinop (Main:binOps:get tok:op) otype))
			)
		)
		(this:castMaybe otype needed)
	)
	((compile tok ShiftToken needed Type) Type public
		(define output (!= this:code null))
		(define otype (PrimType:unboxedType (this:compile tok:tok null Main:unknownType)))
		(this:compile tok:tok this:code otype)
		(this:compile tok:amt this:code Type:intType)
		(if output (if tok:right (this:code:emitShr) (this:code:emitShl)))
		(this:castMaybe otype needed)
	)
	((compile tok IfToken needed Type) Type public
		(define output (!= this:code null))
		(define hasElse (= (tok:toks:size) 4))
		(this:emitIf false (tok:toks:get 1) (tok:toks:get 2) (if hasElse (tok:toks:get 3) Nothing:inst) (if hasElse needed Type:voidType)):_1
	)
	((compile tok CompareToken needed Type) Type public
		(define output (!= this:code null))
		(this:emitIf_ false tok:toks tok:compare (ConstToken tok:line "true") (ConstToken tok:line "false") needed):_1
	)
	((compile tok ThrowToken needed Type) Type public
		(define output (!= this:code null))
		(this:compile tok:tok this:code Main:unknownType)
		(if output (this:code:emitThrow))
		Main:throwType
	)
	((compile tok ClassToken needed Type) Type public
		(define output (!= this:code null))
		(if output (this:code:emitPushClass (as ObjectType (tok:type:getRawType))))
		(this:castMaybe Type:javalangClassType needed)
	)
	((compile tok SynchronizedToken needed Type) Type public
		(define output (!= this:code null))
		(this:compile (tok:toks:get 1) this:code Main:unknownType)
		(this:mi:pushScope null tok:labels)
		(this:compileAll tok:toks 2 (- (tok:toks:size) 1) null Type:voidType)
		(define type (this:compile (tok:toks:get (- (tok:toks:size) 1)) null needed))
		(this:mi:popScope null)
		(this:mi:pushScope this:code tok:labels)
		(define obj (if output (this:code:addLocal Type:objectType) null))
		(if output (this:code:emitDup))
		(if output (this:code:emitStore obj))
		(if output (this:code:emitMonitorEnter))
		(if output (this:code:emitTryStart true type))
		(this:compileAll tok:toks 2 (- (tok:toks:size) 1) this:code Type:voidType)
		(this:compile (tok:toks:get (- (tok:toks:size) 1)) this:code needed)
		(if output (this:code:emitFinallyStart))
		(if output (this:code:emitLoad obj))
		(if output (this:code:emitMonitorExit))
		(if output (this:code:emitFinallyEnd))
		(if output (this:code:emitTryCatchEnd))
		(this:mi:popScope this:code)
		(this:castMaybe type needed)
	)
	((compile tok TypeToken needed Type) Type public
		(define output (!= this:code null))
		(if output (this:code:emitLoad (this:code:getArg 2)))
		(if output (this:code:emitLoad (this:code:getArg 0)))
		(this:compile tok:tok this:code Main:unknownType)
		(if output (this:code:emitInvoke ((Main:getCompilerType "AMethodInfo"):getDeclaredMethod "transformBlock" 1)))
		(if output (this:code:emitPushNull))
		(if output (this:code:emitGetStatic ((Main:getCompilerType "Main"):getField "unknownType")))
		(if output
			(this:code:emitInvoke
				((Main:getCompilerType "handlers.GenHandler"):getDeclaredMethod "compile"
					(Type[]
						(Main:getCompilerType "tokens.Token")
						(ClassType:make "gnu.bytecode.CodeAttr")
						(ClassType:make "gnu.bytecode.Type")
					)
				)
			)
		)
		(this:castMaybe (Type:getType "gnu.bytecode.Type") needed)
	)
	((compile tok ReturnToken needed Type) Type public
		(define output (!= this:code null))
		(if (!= tok:tok null)
			(this:compile tok:tok this:code Main:unknownType)
		)
		(if output (this:code:emitReturn))
		Main:returnType
	)
	((compile tok CallToken needed Type) Type public
		(define output (!= this:code null))
		(define special
			(&&
				(instance? tok:target VToken)
				((as VToken tok:target):val:equals "super")
			)
		)
		(define staticTarget
			(&&
				(instance? tok:target VToken)
				((as VToken tok:target):val:equals "static")
			)
		)
		(define static_ true)
		(define t
			(cond
				(special
					(set static_ false)
					(if output (this:code:emitPushThis))
					(this:mi:ci:c:getGenericSuperclass)
				)
				(staticTarget
					this:mi:ci:c
				)
				(true
					(this:mi:getType tok:target)
				)
			)
		)
		(when (= t null)
			(set static_ false)
			(set t (this:compile tok:target this:code Main:unknownType))
		)
		(Main:emitInvoke this tok:method t (Main:toEmitters tok:toks) needed special static_):_1
	)
	((compile tok DefaultToken needed Type) Type public
		(define output (!= this:code null))
		(define first (tok:toks:get 0))
		(define t (this:compile first this:code Main:unknownType))
		(define c ClassType (t:getRawType))
		(define method (c:getDeclaredMethods))
		(define i 0)
		(define tocall Method null)
		(while (!= method null)
			(if (&& (! ((method:getName):equals "<init>")) (= 0 (& Access:SYNTHETIC (method:getModifiers))))
				(if (= tocall null)
					(set tocall method)
					(throw (RuntimeException))
				)
			)
			(set method (method:getNext))
		)
		(Main:emitInvoke this (tocall:getName) t (Main:toEmitters (tok:toks:subList 1 (tok:toks:size))) needed false):_1
	)
	((compile tok ConstructorToken needed Type) Type public
		(define output (!= this:code null))
		(define class ClassType (tok:type:getRawType))
		(if output (this:code:emitNew class))
		(if output (this:code:emitDup))
		(define mc (Main:emitInvoke this "<init>" tok:type (Main:toEmitters tok:toks) Main:unknownType false):_2)
		(if
			(&&
				(instance? tok:type ClassType)
				(!= ((as ClassType tok:type):getTypeParameters) null)
				(!= (alen ((as ClassType tok:type):getTypeParameters)) 0)
			)
			(begin
				(define tparams ((as ClassType tok:type):getTypeParameters))
				(define ptype (ParameterizedType (as ClassType tok:type) tparams))
				(this:castMaybe (Main:resolveType mc:tvs ptype) needed)
			)
			(this:castMaybe tok:type needed)
		)
	)
	((compile tok ArrayConstructorToken needed Type) Type public
		(define output (!= this:code null))
		(define array ArrayType tok:type)
		(if (!= tok:len null)
			(this:compile tok:len this:code Main:unknownType)
			(if output (this:code:emitPushInt (tok:toks:size)))
		)
		(if output (this:code:emitNewArray (array:elements:getRawType)))
		(for ((i 0)) (!= i (tok:toks:size)) (inc i)
			(if output (this:code:emitDup))
			(if output (this:code:emitPushInt i))
			(this:compile (tok:toks:get i) this:code array:elements)
			(if output (this:code:emitArrayStore))
		)
		(this:castMaybe tok:type needed)
	)
	((compile tok Token needed Type) Type public
		(define output (!= this:code null))
		(if output (this:code:putLineNumber (this:mi:ci:fs:path:substring (+ (this:mi:ci:fs:path:lastIndexOf "/") 1)) tok:line))
		(try
			(begin
				(define t (super:compile tok needed))
				(if
					(&&
						(!= needed Main:unknownType)
						(!= t Main:returnType)
						(!= t Main:throwType)
						(! (Type:isSame needed t))
					)
					(throw (RuntimeException (concat t " vs " needed)))
				)
				t
			)
			(e Throwable
				(println
					this:mi:ci:fs:path
					": Error compiling line "
					tok:line
				)
				(throw e)
			)
		)
	)
)

(define-class CaptureVHandler (GenHandler)
	(enc AMethodInfo)
	(captured Map{AVar Field})
	(n int)
	((<init> mi AMethodInfo enc AMethodInfo captured Map) void
		(super:<init> mi)
		(set this:enc enc)
		(set this:captured captured)
	)
	((assignField vcaptured VCaptured code CodeAttr) void
		(define output (!= code null))
		(if (&& output (= vcaptured:field null))
			(begin
				(define new (this:mi:ci:c:addField ("captured$":concat (Integer:toString this:n)) vcaptured:type Access:SYNTHETIC))
				(inc this:n)
				(set vcaptured:field new)
				(this:captured:put vcaptured:avar new)
			)
		)
	)
	((compile tok VToken needed Type) Type public
		(define output (!= this:code null))
		(define found (this:mi:getVar tok))
		(if (instance? found VCaptured)
			(this:assignField (as VCaptured found) this:code)
		)
		(this:castMaybe
			(if (= found null)
				(begin
					(define outer (this:enc:getVar tok))
					(if (= outer null) (throw (RuntimeException (tok:toString))))
					(define vcaptured (VCaptured outer null))
					(this:assignField vcaptured this:code)
					(this:mi:putCapturedVar tok vcaptured)
					(vcaptured:load this:code)
				)
				(found:load this:code)
			)
			needed
		)
	)
)
