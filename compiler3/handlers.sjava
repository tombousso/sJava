(package sjava.compiler.handlers)

(import sjava.compiler.*)
(import sjava.compiler.mfilters.*)
(import sjava.compiler.emitters.*)
(import sjava.compiler.tokens.*)

(import java.util.*)
(import gnu.bytecode.*)

(define-class Handler () 'abstract 'public
	((<init>) void (super:<init>))
	((valid tok Token mi AMethodInfo needed Type) bool false)
	((compileAll toks List{Token} i int e int mi AMethodInfo code CodeAttr needed Object) Type[] 'public
		(define l (toks:size))
		(define types (Type[] len:(- e i)))
		(define j i)
		(while (! (>= j e))
			(aset types (- j i)
				(this:compile (toks:get j) mi code
					(if (instance? needed Type[])
						(aget (as Type[] needed) (- j i))
						needed
					)
				)
			)
			(set j (+ j 1))
		)
		types
	)
	((compile tok EmptyToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok SToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok CToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok NToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok ColonToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok QuoteToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok ConstToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok VToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok IncludeToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok ObjectToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok MacroCallToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok BeginToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok LabelToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok GotoToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok DefineToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok TryToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok InstanceToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok SetToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok ASetToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok AGetToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok ALenToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok AsToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok BinOpToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok IfToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok WhileToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok CompareToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok ThrowToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok ClassToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok SynchronizedToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok TypeToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok ReturnToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok CallToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok DefaultToken mi AMethodInfo code CodeAttr needed Type) Type 'public 'abstract)
	((compile tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(doubleDispatch (this:compile _ mi code needed) tok)
	)
	((castMaybe code CodeAttr result Type needed Type) Type 'public
		(define output (!= code null))
		(if (|| (= needed Main:unknownType) (= result Main:returnType) (= result Main:throwType))
			result
			(begin
				(if (= needed Type:voidType)
					(if (!= result Type:voidType)
						(if output (code:emitPop 1))
					)
					(if (! (Type:isSame needed result))
						(if (instance? result PrimType)
							(begin
								(if (instance? needed ClassType)
									(if (= result Type:voidType)
										(if output (code:emitPushNull))
										(begin
											(define prim (PrimType:unboxedType needed))
											(define box
												(if (= prim null)
													(begin
														(set prim result)
														((as PrimType result):boxedType)
													)
													(begin
														(if output (code:emitConvert (as PrimType result) prim))
														(as ClassType needed)
													)
												)
											)
											(if output (code:emitInvoke (box:getMethod "valueOf" (Type[] prim))))
										)
									)
									(if output (code:emitConvert (as PrimType result) (as PrimType needed)))
								)
							)
							(if (instance? needed PrimType)
								(begin
									(define unbox (Main:unboxMethods:get result))
									(if output (code:emitInvoke unbox))
									(if output (code:emitConvert (as PrimType (unbox:getReturnType)) (as PrimType needed)))
								)
								(if output (code:emitCheckcast (needed:getRawType)))
							)
						)
					)
				)
				needed
			)
		)
	)
)

(define-class GenHandler (Handler) 'public
	(inst GenHandler 'static 'public)
	((<clinit>) void 'static (set GenHandler:inst (GenHandler)))
	((<init>) void
		(super:<init>)
	)
	((compile tok EmptyToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		Type:voidType
	)
	((compile tok SToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(if output (code:emitPushString (as SToken tok):val))
		Type:javalangStringType
	)
	((compile tok CToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define c int (as CToken tok):val)
		(if (! (instance? needed PrimType))
			(begin
				(if output (code:emitPushInt c))
				Type:charType
			)
			(begin
				(if output (code:emitPushConstant c needed))
				needed
			)
		)
	)
	((compile tok NToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(if (instance? tok:val Double)
			(begin
				(if output (code:emitPushDouble (as Double tok:val)))
				Type:doubleType
			)
			(begin
				(if (! (instance? needed PrimType))
					(begin
						(if output (code:emitPushInt (as Integer tok:val)))
						Type:intType
					)
					(begin
						(if output (code:emitPushConstant (as Integer tok:val) needed))
						needed
					)
				)
			)
		)
	)
	((compile tok ColonToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:toks:get 0))
		(define t (mi:getType first))
		(if (= t null)
			(set t (this:compile first mi code Main:unknownType))
		)
		(define class ClassType (t:getRawType))
		(define field Field (class:getField (as VToken (tok:toks:get 1)):val -1))
		(if (field:getStaticFlag)
			(if output (code:emitGetStatic field))
			(if output (code:emitGetField field))
		)
		(define out (Main:resolveType t (field:getType)))
		(if (!= out Type:voidType)
			(if output (code:emitCheckcast (out:getRawType)))
		)
		out
	)
	((compileQuasi o Object mi AMethodInfo code CodeAttr needed Type) Type
		(define output (!= code null))
		(define result
			(cond
				((= o null)
					(if output (code:emitPushNull))
					Type:nullType
				)
				((instance? o Token)
					(define tok Token o)
					(define t (if (instance? tok UnquoteToken) (this:compile (tok:toks:get 0) mi null Main:unknownType) null))
					(if
						(&&
							(instance? tok UnquoteToken)
							(||
								(= t (Main:getCompilerType "tokens.Token"))
								(&&
									(instance? t ArrayType)
									(= (as ArrayType t):elements (Main:getCompilerType "tokens.Token"))
								)
								((t:getRawType):isSubtype (Type:getType "java.util.List"))
							)
						)
						(this:compile (tok:toks:get 0) mi code Main:unknownType)
						(if (instance? tok UnquoteToken)
							(begin
								(define const (tok:toks:get 0))
								(define t (this:compile const mi null Main:unknownType))
								(define type ClassType
									(Main:getCompilerType
										(if (as UnquoteToken tok):s
											"tokens.SToken"
											(if (= t Type:charType)
												"tokens.CToken"
												(if (instance? t PrimType)
													"tokens.NToken"
													"tokens.VToken"
												)
											)
										)
									)
								)
								(if output (code:emitNew type))
								(if output (code:emitDup))
								(if output (code:emitInvoke (type:getDeclaredMethod "<init>" 0)))
								(if output (code:emitDup))
								(this:compile const mi code Type:objectType)
								(if output (code:emitPutField (type:getField "val")))
								(Main:getCompilerType "tokens.Token")
							)
							(begin
								(define type ClassType (Type:getType ((o:getClass):getName)))
								(if output (code:emitNew type))
								(if output (code:emitDup))
								(if output (code:emitInvoke (type:getDeclaredMethod "<init>" 0)))
								(define superC type)
								(while (!= superC null)
									(define field (superC:getFields))
									(while (!= field null)
										(if
											(&&
												(!= (& (field:getModifiers) Access:PUBLIC) 0)
												(= (& (field:getModifiers) Access:TRANSIENT) 0)
											)
											(begin
												(if output (code:emitDup))
												(try (if (= (field:getType) Type:intType)
													(this:compileQuasi ((field:getReflectField):getInt tok) mi code (field:getType))
													(this:compileQuasi ((field:getReflectField):get tok) mi code (field:getType))
												) (e Throwable (throw (RuntimeException e))))
												(if output (code:emitPutField field))
											)
										)
										(set field (field:getNext))
									)
									(set superC (superC:getSuperclass))
								)
								(if (= type (Main:getCompilerType "tokens.VToken"))
									(begin
										(if output (code:emitDup))
										(if output (code:emitLoad (code:getArg 2)))
										(if output (code:emitPutField (type:getField "macro")))
									)
								)
								(Main:getCompilerType "tokens.Token")
							)
						)
					)
				)
				((instance? o String)
					(if output (code:emitPushString (as String o)))
					Type:javalangStringType
				)
				((instance? o Integer)
					(if output (code:emitPushInt (as Integer o)))
					Type:intType
				)
				((instance? o Boolean)
					(if output (code:emitPushInt (if (as Boolean o) 1 0)))
					Type:booleanType
				)
				((instance? o List)
					(define o List o)
					(define al ClassType (Type:getType "java.util.ArrayList"))
					(if output (code:emitNew al))
					(if output (code:emitDup))
					(if output (code:emitInvoke (al:getMethod "<init>" (Type[]))))
					(define i 0)
					(while (!= i (o:size))
						(define t (this:compileQuasi (o:get i) mi null Main:unknownType))
						(if (= t (Main:getCompilerType "tokens.Token"))
							(begin
								(if output (code:emitDup))
								(this:compileQuasi (o:get i) mi code Main:unknownType)
								(if output (code:emitInvoke (al:getMethod "add" (Type[] Type:objectType))))
								(if output (code:emitPop 1))
							)
							(if (instance? t ArrayType)
								(begin
									(if output (code:emitDup))
									(this:compileQuasi (o:get i) mi code Main:unknownType)
									(if output (code:emitInvoke ((as ClassType (Type:getType "java.util.Collections")):getDeclaredMethod "addAll" 2)))
									(if output (code:emitPop 1))
								)
								(begin
									(if output (code:emitDup))
									(this:compileQuasi (o:get i) mi code Main:unknownType)
									(if output (code:emitInvoke ((as ClassType (Type:getType "java.util.List")):getDeclaredMethod "addAll" 1)))
									(if output (code:emitPop 1))
								)
							)
						)
						(set i (+ i 1))
					)
					al
				)
				(true
					(throw (RuntimeException))
				)
			)
		)
		(this:castMaybe code result needed)
	)
	((compile tok QuoteToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define out (this:compileQuasi (tok:toks:get 0) mi code (Main:getCompilerType "tokens.Token")))
		(if (as QuoteToken tok):transform
			(begin
				(if output (code:emitLoad (code:getArg 0)))
				(if output (code:emitInvoke ((as ClassType (Main:getCompilerType "Main")):getDeclaredMethod "transformBlock" 2)))
			)
		)
		out
	)
	((compile tok ConstToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(if (tok:what:equals "true")
			(begin
				(if output (code:emitPushInt 1))
				Type:booleanType
			)
			(if (tok:what:equals "false")
				(begin
					(if output (code:emitPushInt 0))
					Type:booleanType
				)
				(begin
					(if output (code:emitPushNull))
					Type:nullType
				)
			)
		)
	)
	((compile tok VToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define found (mi:getVar (as VToken tok)))
		(found:load code)
	)
	((compile tok IncludeToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(if (= tok:ret null)
			(try (set tok:ret
				((mi:ci:fs:includes:rc:getMethod ((as IncludeToken tok):mi:method:getName) (Class[]
					(class AMethodInfo)
					(class gnu.bytecode.Type)
					Integer:TYPE
					(class Handler)
				)):invoke null (Object[] mi needed 0 this))
			) (e Throwable (throw (RuntimeException e))))
		)
		(this:compile tok:ret mi code needed)
	)
	((compile tok ObjectToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define lambda (instance? tok LambdaToken))
		(define ci tok:ci)
		(define superT (tok:toks:get 1))
		(define FunctionN (&& lambda (instance? superT BlockToken)))
		(define emitters
			(Emitters
				(if (|| lambda (! (instance? superT BlockToken)))
					(ArrayList)
					(superT:toks:subList 1 (superT:toks:size))
				)
			)
		)
		(if (= ci null)
			(begin
				(define captureH (CaptureVHandler mi))
				(if output
					(begin
						(set ci (ClassInfo ((mi:ci:c:getName):concat ("$":concat (Integer:toString mi:ci:anonymous))) mi:ci:fs))
						(set tok:ci ci)
						(mi:ci:fs:anonClasses:add ci)
						(set mi:ci:anonymous (+ mi:ci:anonymous 1))
					)
				)
				(if FunctionN
					(begin
						(define scope (LinkedHashMap))
						(define params (Main:getParams mi:ci superT scope 0 1))
						(define generics (Type[] len:(+ (alen params) 1)))
						(System:arraycopy params 0 generics 0 (alen params))
						(define toks (tok:toks:subList 2 (tok:toks:size)))
						(define fakemi (MethodInfo (ClassInfo null mi:ci:fs) toks null scope))
						(define ret (Main:tryBox (captureH:compile fakemi:block fakemi null Main:unknownType)))
						(aset generics (alen params) ret)
						(define t (ParameterizedType (ClassType:make ("sjava.std.Function":concat (Integer:toString (alen params)))) generics))
						(set tok:t t)
						(if output
							(begin
								(define m (ci:c:addMethod "apply" params ret Access:PUBLIC))
								(ci:c:addInterface t)
								(ci:methods:add (MethodInfo ci toks m scope))
								(ci:compileMethods captureH)
							)
						)
					)
					(if lambda
						(begin
							(define t (mi:getType superT))
							(set tok:t t)
							(if output
								(begin
									(define sam ((as ClassType (t:getRawType)):checkSingleAbstractMethod))
									(define scope (LinkedHashMap))
									(define args (tok:toks:get 2))
									(define i 0)
									(define params (Type[] len:(args:toks:size)))
									(while (!= i (args:toks:size))
										(define arg VToken (args:toks:get i))
										(define param (Main:resolveType t (aget (sam:getGenericParameterTypes) i)))
										(scope:put arg:val (Arg (+ i 1) param))
										(aset params i param)
										(set i (+ i 1))
									)
									(ci:c:addInterface t)
									(define m (ci:c:addMethod (sam:getName) params (Main:resolveType t (sam:getReturnType)) Access:PUBLIC))
									(ci:methods:add (MethodInfo ci (tok:toks:subList 3 (tok:toks:size)) m scope))
									(ci:compileMethods captureH)
								)
							)
						)
						(begin
							(define t
								(if (instance? superT BlockToken)
									(mi:getType (superT:toks:get 0))
									(mi:getType superT)
								)
							)
							(set tok:t t)
							(if output
								(begin
									(if ((as ClassType (t:getRawType)):isInterface)
										(ci:c:addInterface t)
										(ci:c:setSuper t)
									)
									(define i 2)
									(while (!= i (tok:toks:size))
										(ci:compileDef (tok:toks:get i))
										(set i (+ i 1))
									)
									(ci:compileMethods captureH)
								)
							)
						)
					)
				)
				(if output
					(begin
						(define superC (ci:c:getSuperclass))
						(define types (emitters:emitAll captureH mi null Main:unknownType))
						(define filter (MFilter "<init>" types superC))
						(filter:searchDeclared)
						(define superCons (filter:getMethod))
						(set tok:captured (AVar[] len:(captureH:captured:size)))
						((captureH:captured:keySet):toArray tok:captured)
						(define fields (Field[] len:(captureH:captured:size)))
						((captureH:captured:values):toArray fields)
						(define n (alen (superCons:getGenericParameterTypes)))
						(define params (Type[] len:(+ n (alen fields))))
						(System:arraycopy (superCons:getGenericParameterTypes) 0 params 0 n)
						(define i 0)
						(while (!= i (alen fields))
							(aset params (+ n i) ((aget fields i):getType))
							(set i (+ i 1))
						)
						(define cons (ci:c:addMethod "<init>" params Type:voidType 0))
						(define code (cons:startCode))
						(code:emitLoad (code:getArg 0))
						(set i 0)
						(while (!= i n)
							(code:emitLoad (code:getArg (+ i 1)))
							(set i (+ i 1))
						)
						(code:emitInvoke superCons)
						(set i 0)
						(while (!= i (alen fields))
							(code:emitPushThis)
							(code:emitLoad (code:getArg (+ n i 1)))
							(code:emitPutField (aget fields i))
							(set i (+ i 1))
						)
						(code:emitReturn)
					)
				)
			)
		)
		(if output (code:emitNew ci:c))
		(if output (code:emitDup))
		(if output
			(begin
				(define i 0)
				(while (!= i (alen tok:captured))
					(emitters:emitters:add (LoadAVar (aget tok:captured i)))
					(set i (+ i 1))
				)
				(Main:emitInvoke this "<init>" ci:c emitters mi code Main:unknownType)
			)
		)
		tok:t
	)
	((compile tok MacroCallToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(if (= tok:ret null)
			(begin
				(define name (as VToken (tok:toks:get 0)):val)
				(define o 4)
				(define l (- (tok:toks:size) 1))
				(define types (Type[] len:(+ o l) (Main:getCompilerType "AMethodInfo") (Type:getType "gnu.bytecode.Type") Type:intType (Main:getCompilerType "handlers.Handler")))
				(define j 0)
				(while (!= j l)
					(aset types (+ o j) (Main:getCompilerType "tokens.Token"))
					(set j (+ j 1))
				)
				(define method Method null)
				(define ci ClassInfo null)
				(define i 0)
				(while (= method null)
					(set ci ((mi:ci:fs:macroNames:get name):get i))
					(define filter (MFilter name types ci:c))
					(filter:searchDeclared)
					(set method (filter:getMethod))
					(set i (+ i 1))
				)
				(define params (method:getGenericParameterTypes))
				(define classes (Class[] len:(alen params)))
				(set j 0)
				(while (!= j (alen params))
					(aset classes j ((aget params j):getReflectClass))
					(set j (+ j 1))
				)
				(define args (ArrayList (Arrays:asList (Object[] mi needed (mi:scopes:size) this))))
				(args:addAll
					(if (&& (> (alen params) 0) (instance? (aget params (- (alen params) 1)) ArrayType))
						(begin
							(define var (- (alen params) o))
							(define al (ArrayList (tok:toks:subList 1 var)))
							(define out (Token[] len:(- (tok:toks:size) var)))
							((tok:toks:subList var (tok:toks:size)):toArray out)
							(al:add out)
							al
						)
						(tok:toks:subList 1 (tok:toks:size))
					)
				)
				(try
					(set tok:ret (as Token ((ci:rc:getMethod name classes):invoke null (args:toArray))))
					(e Throwable (throw (RuntimeException e)))
				)
			)
		)
		(mi:pushLevel)
		(define out (this:compile tok:ret mi code needed))
		(mi:popLevel)
		out
	)
	((compile tok BeginToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(mi:pushScope code (as BlockToken tok):labels)
		(this:compileAll tok:toks 1 (- (tok:toks:size) 1) mi code Type:voidType)
		(define type (this:compile (tok:toks:get (- (tok:toks:size) 1)) mi code needed))
		(mi:popScope code)
		type
	)
	((compile tok LabelToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define label (mi:getLabel (as VToken (tok:toks:get 1)):val))
		(if output (label:define code))
		Type:voidType
	)
	((compile tok GotoToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define label (mi:getLabel (as VToken (tok:toks:get 1)):val))
		(if output (code:emitGoto label))
		Type:voidType
	)
	((compile tok DefineToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define type (mi:getType (tok:toks:get 2)))
		(if (= type null)
			(set type (this:compile (tok:toks:get 2) mi code Main:unknownType))
			(if (= (tok:toks:size) 4)
				(this:compile (tok:toks:get 3) mi code type)
				(if output (code:emitPushDefaultValue needed))
			)
		)
		(define var (mi:newVar code (as VToken (tok:toks:get 1)) type))
		(if output (code:emitStore var))
		Type:voidType
	)
	((compile tok TryToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define type (this:compile (tok:toks:get 1) mi null needed))
		(define last (tok:toks:get (- (tok:toks:size) 1)))
		(define hasFinally ((as VToken (last:toks:get 0)):val:equals "finally"))
		(if output (code:emitTryStart hasFinally type))
		(this:compile (tok:toks:get 1) mi code needed)
		(define e (- (tok:toks:size) (if hasFinally 1 0)))
		(for (define i 2) (!= i e) (inc i)
			(define catch (tok:toks:get i))
			(mi:pushScope code (as BlockToken catch):labels)
			(define var (mi:newVar code (as VToken (catch:toks:get 0)) (mi:getType (catch:toks:get 1))))
			(if output (code:emitCatchStart var))
			(this:compileAll catch:toks 2 (catch:toks:size) mi code type)
			(if output (code:emitCatchEnd))
			(mi:popScope code)
		)
		(if hasFinally
			(begin
				(if output (code:emitFinallyStart))
				(this:compileAll last:toks 1 (last:toks:size) mi code type)
				(if output (code:emitFinallyEnd))
			)
		)
		(if output (code:emitTryCatchEnd))
		type
	)
	((compile tok InstanceToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(this:compile (tok:toks:get 1) mi code Main:unknownType)
		(if output (code:emitInstanceof (mi:getType (tok:toks:get 2))))
		Type:booleanType
	)
	((compile tok SetToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:toks:get 0))
		(define out (tok:toks:get 1))
		(if (instance? out ColonToken)
			(begin
				(define first (out:toks:get 0))
				(define t (mi:getType first))
				(if (= t null)
					(set t (this:compile first mi code Main:unknownType))
				)
				(define class ClassType (t:getRawType))
				(define field Field (class:getField (as VToken (out:toks:get 1)):val -1))
				(this:compile (tok:toks:get 2) mi code (Main:resolveType t (field:getType)))
				(if (field:getStaticFlag)
					(if output (code:emitPutStatic field))
					(if output (code:emitPutField field))
				)
			)
			(begin
				(define var (mi:getVar (as VToken (tok:toks:get 1))))
				(this:compile (tok:toks:get 2) mi code var:type)
				(var:store code)
			)
		)
		Type:voidType
	)
	((compile tok ASetToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define type ArrayType (this:compile (tok:toks:get 1) mi code Main:unknownType))
		(this:compile (tok:toks:get 2) mi code Main:unknownType)
		(this:compile (tok:toks:get 3) mi code type:elements)
		(if output (code:emitArrayStore))
		Type:voidType
	)
	((compile tok AGetToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define type ArrayType (this:compile (tok:toks:get 1) mi code Main:unknownType))
		(this:compile (tok:toks:get 2) mi code Type:intType)
		(if output (code:emitArrayLoad))
		type:elements
	)
	((compile tok ALenToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(this:compile (tok:toks:get 1) mi code Main:unknownType)
		(if output (code:emitArrayLength))
		Type:intType
	)
	((compile tok AsToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define cast (mi:getType (tok:toks:get 1)))
		(this:compile (tok:toks:get 2) mi code cast)
	)
	((compile tok BinOpToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first VToken (tok:toks:get 0))
		(define otype (Main:numericOpType (this:compileAll tok:toks 1 (tok:toks:size) mi null Main:unknownType)))
		(this:compile (tok:toks:get 1) mi code otype)
		(define i 2)
		(while (!= i (tok:toks:size))
			(this:compile (tok:toks:get i) mi code otype)
			(if output (code:emitBinop (Main:binOps:get first:val) otype))
			(set i (+ i 1))
		)
		otype
	)
	((compile tok IfToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define hasElse (= (tok:toks:size) 4))
		(Main:emitIf this false tok 1 (tok:toks:get 2) (if hasElse (tok:toks:get 3) null) mi code (if hasElse needed Type:voidType))
	)
	((compile tok WhileToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(mi:pushScope code (as BlockToken tok):labels)
		(define start Label (Label))
		(if output (start:define code))
		(define t (Main:emitIf this false tok 1 (Emitters (Emitter[] (Emitters (tok:toks:subList 2 (tok:toks:size))) (Goto start))) null mi code needed))
		(mi:popScope code)
		t
	)
	((compile tok CompareToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:toks:get 0))
		(Main:emitIf_ this false tok 1 (tok:toks:size) (as VToken first):val (ConstToken tok:line "true") (ConstToken tok:line "false") mi code Type:booleanType)
	)
	((compile tok ThrowToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(this:compile (tok:toks:get 1) mi code Main:unknownType)
		(if output (code:emitThrow))
		Main:throwType
	)
	((compile tok ClassToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(if output (code:emitPushClass (as ObjectType (mi:getType (tok:toks:get 1)))))
		Type:javalangClassType
	)
	((compile tok SynchronizedToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(this:compile (tok:toks:get 1) mi code Main:unknownType)
		(mi:pushScope null (as BlockToken tok):labels)
		(this:compileAll tok:toks 2 (- (tok:toks:size) 1) mi null Type:voidType)
		(define type (this:compile (tok:toks:get (- (tok:toks:size) 1)) mi null needed))
		(mi:popScope null)
		(mi:pushScope code (as BlockToken tok):labels)
		(define obj (if output (code:addLocal Type:objectType) null))
		(if output (code:emitDup))
		(if output (code:emitStore obj))
		(if output (code:emitMonitorEnter))
		(if output (code:emitTryStart true type))
		(this:compileAll tok:toks 2 (- (tok:toks:size) 1) mi code Type:voidType)
		(this:compile (tok:toks:get (- (tok:toks:size) 1)) mi code needed)
		(if output (code:emitFinallyStart))
		(if output (code:emitLoad obj))
		(if output (code:emitMonitorExit))
		(if output (code:emitFinallyEnd))
		(if output (code:emitTryCatchEnd))
		(mi:popScope code)
		type
	)
	((compile tok TypeToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(if output (code:emitLoad (code:getArg 0)))
		(if output (code:emitInvoke ((Main:getCompilerType "AMethodInfo"):getDeclaredMethod "pushLevel" 0)))
		(if output (code:emitLoad (code:getArg 3)))
		(this:compile (tok:toks:get 1) mi code Main:unknownType)
		(if output (code:emitLoad (code:getArg 0)))
		(if output (code:emitInvoke ((Main:getCompilerType "Main"):getDeclaredMethod "transformBlock" 2)))
		(if output (code:emitLoad (code:getArg 0)))
		(if output (code:emitPushNull))
		(if output (code:emitGetStatic ((Main:getCompilerType "Main"):getField "unknownType")))
		(if output (code:emitInvoke ((Main:getCompilerType "handlers.Handler"):getDeclaredMethod "compile" (Type[]
			(Main:getCompilerType "tokens.Token")
			(Main:getCompilerType "AMethodInfo")
			(ClassType:make "gnu.bytecode.CodeAttr")
			(ClassType:make "gnu.bytecode.Type")
		))))
		(if output (code:emitLoad (code:getArg 0)))
		(if output (code:emitInvoke ((Main:getCompilerType "AMethodInfo"):getDeclaredMethod "popLevel" 0)))
		(Type:getType "gnu.bytecode.Type")
	)
	((compile tok ReturnToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(if (= (tok:toks:size) 2)
			(this:compile (tok:toks:get 1) mi code Main:unknownType)
		)
		(if output (code:emitReturn))
		Main:returnType
	)
	((compile tok CallToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:toks:get 0))
		(define name (as VToken (first:toks:get 1)):val)
		(define special
			(&&
				(instance? (first:toks:get 0) VToken)
				((as VToken (first:toks:get 0)):val:equals "super")
			)
		)
		(define t
			(if special
				(begin
					(if output (code:emitPushThis))
					(mi:ci:c:getGenericSuperclass)
				)
				(mi:getType (first:toks:get 0))
			)
		)
		(if (= t null)
			(set t (this:compile (first:toks:get 0) mi code Main:unknownType))
		)
		(Main:emitInvoke this name t (Emitters (tok:toks:subList 1 (tok:toks:size))) mi code needed special)
	)
	((compile tok DefaultToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:toks:get 0))
		(define type Type (mi:getType first))
		(if (= type null)
			(begin
				(define t (this:compile first mi code Main:unknownType))
				(define c ClassType (t:getRawType))
				(define method (c:getDeclaredMethods))
				(define i 0)
				(define tocall Method null)
				(while (!= method null)
					(if (&& (! ((method:getName):equals "<init>")) (= 0 (& Access:SYNTHETIC (method:getModifiers))))
						(if (= tocall null)
							(set tocall method)
							(throw (RuntimeException))
						)
					)
					(set method (method:getNext))
				)
				(Main:emitInvoke this (tocall:getName) t (Emitters (tok:toks:subList 1 (tok:toks:size))) mi code Main:unknownType)
			)
			(if (instance? type ArrayType)
				(begin
					(define array ArrayType type)
					(define len Token (if (> (tok:toks:size) 1) (tok:toks:get 1) null))
					(define i0
						(if (&& (!= len null) (instance? len ColonToken) ((as VToken (len:toks:get 0)):val:equals "len"))
							(begin (this:compile (len:toks:get 1) mi code Main:unknownType) 2)
							(begin (if output (code:emitPushInt (- (tok:toks:size) 1))) 1)
						)
					)
					(if output (code:emitNewArray (array:elements:getRawType)))
					(define i i0)
					(while (!= i (tok:toks:size))
						(if output (code:emitDup))
						(if output (code:emitPushInt (- i i0)))
						(this:compile (tok:toks:get i) mi code array:elements)
						(if output (code:emitArrayStore))
						(set i (+ i 1))
					)
					type
				)
				(begin
					(define class ClassType (type:getRawType))
					(if output (code:emitNew class))
					(if output (code:emitDup))
					(Main:emitInvoke this "<init>" type (Emitters (tok:toks:subList 1 (tok:toks:size))) mi code Main:unknownType)
					type
				)
			)
		)
	)
	((compile tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(if output (code:putLineNumber (mi:ci:fs:name:substring (+ (mi:ci:fs:name:lastIndexOf "/") 1)) tok:line))
		(try
			(begin
				(define type (super:compile tok mi code needed))
				(this:castMaybe code type needed)
			)
			(e Throwable
				(System:out:println (mi:ci:fs:name:concat (": Error compiling line ":concat (Integer:toString tok:line))))
				(throw e)
			)
		)
	)
)

(define-class CaptureVHandler (GenHandler)
	(enc AMethodInfo)
	(captured Map{AVar Field})
	(n int)
	((<init> enc AMethodInfo) void
		(super:<init>)
		(set this:enc enc)
		(set this:captured (LinkedHashMap))
	)
	((assignField vcaptured VCaptured mi AMethodInfo code CodeAttr) void
		(define output (!= code null))
		(if (&& output (= vcaptured:field null))
			(begin
				(define new (mi:ci:c:addField ("captured$":concat (Integer:toString this:n)) vcaptured:type Access:SYNTHETIC))
				(inc this:n)
				(set vcaptured:field new)
				(this:captured:put vcaptured:avar new)
			)
		)
	)
	((compile tok VToken mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define found (mi:getVar (as VToken tok)))
		(if (instance? found VCaptured)
			(this:assignField (as VCaptured found) mi code)
		)
		(if (= found null)
			(begin
				(define outer (this:enc:getVar tok))
				(if (= outer null) (throw (RuntimeException)))
				(define vcaptured (VCaptured outer null))
				(this:assignField vcaptured mi code)
				(((mi:scopes:get tok:macro):getLast):put tok:val vcaptured)
				(vcaptured:load code)
			)
			(found:load code)
		)
	)
)

;(define-class JavaHandler (GenHandler) 'public
;	(buf StringBuffer 'public)
;	(emit bool 'public)
;	(varNum int)
;	((<init>) void 'public
;		(super:<init>)
;		(set this:emit true)
;	)
;	((newMethod) void 'public
;		(set this:varNum 0)
;	)
;	((varNum) int
;		(define ret this:varNum)
;		(inc this:varNum)
;		ret
;	)
;	((compile tok SToken mi AMethodInfo code CodeAttr needed Type) Type 'public
;		(define emit this:emit)
;		(if emit (this:buf:append #\"))
;		(if emit (this:buf:append (org.apache.commons.lang3.StringEscapeUtils:escapeJava tok:val)))
;		(if emit (this:buf:append #\"))
;		(super:compile tok mi code needed)
;	)
;	((compile tok CToken mi AMethodInfo code CodeAttr needed Type) Type 'public
;		(define emit this:emit)
;		(if emit (this:buf:append #\singlequote))
;		(if emit (this:buf:append (if (= tok:val #\singlequote) "\\'" (tok:val:toString))))
;		(if emit (this:buf:append #\singlequote))
;		(super:compile tok mi code needed)
;	)
;	((compile tok NToken mi AMethodInfo code CodeAttr needed Type) Type 'public
;		(define emit this:emit)
;		(if emit (this:buf:append tok:val))
;		(super:compile tok mi code needed)
;	)
;	((compile tok ColonToken mi AMethodInfo code CodeAttr needed Type) Type 'public
;		(define emit this:emit)
;		(define first (tok:toks:get 0))
;		(define t (mi:getType first))
;		(if (!= t null)
;			(if emit (this:buf:append (t:getName)))
;		)
;		(define out (super:compile tok mi code needed))
;		(if emit (this:buf:append #\.))
;		(if emit (this:buf:append (as VToken (tok:toks:get 1)):val))
;		out
;	)
;	((compile tok ConstToken mi AMethodInfo code CodeAttr needed Type) Type 'public
;		(define emit this:emit)
;		(if emit (this:buf:append tok:what))
;		(super:compile tok mi code needed)
;	)
;	((compile tok VToken mi AMethodInfo code CodeAttr needed Type) Type 'public
;		(define emit this:emit)
;		(if emit (this:buf:append tok:val))
;		(super:compile tok mi code needed)
;	)
;	((compile tok CallToken mi AMethodInfo code CodeAttr needed Type) Type 'public
;		(define emit this:emit)
;		(define num this:varNum)
;		(for (define i 1) (!= i (tok:toks:size)) (inc i)
;			(define arg (tok:toks:get i))
;			(if (instance? arg BlockToken)
;				(this:compile (tok:toks:get i) mi null Main:unknownType)
;			)
;		)
;		(define method ColonToken (tok:toks:get 0))
;		(define obj (method:toks:get 0))
;		(if (&& (instance? obj VToken) ((as VToken obj):val:equals "super"))
;			(if emit (this:buf:append "super"))
;			(begin
;				(if (= (mi:getType obj) null)
;					(this:compile (method:toks:get 0) mi null Main:unknownType)
;					(if emit (this:buf:append ((as VToken obj):javaName)))
;				)
;			)
;		)
;		(define mname (as VToken (method:toks:get 1)):val)
;		(if (! (mname:equals "<init>"))
;			(begin
;				(if emit (this:buf:append #\.))
;				(if emit (this:buf:append mname))
;			)
;		)
;		(if emit (this:buf:append "("))
;		(for (define i 1) (!= i (tok:toks:size)) (inc i)
;			(define arg (tok:toks:get i))
;			(if (instance? arg BlockToken)
;				(begin
;					(if emit (this:buf:append "$"))
;					(if emit (this:buf:append num))
;					(inc num)
;				)
;				(this:compile (tok:toks:get i) mi null Main:unknownType)
;			)
;			(if (!= (+ i 1) (tok:toks:size))
;				(if emit (this:buf:append ", "))
;			)
;		)
;		(if emit (this:buf:append ")"))
;		(set this:emit false)
;		(define out (super:compile tok mi code needed))
;		(set this:emit emit)
;		out
;	)
;	((compile tok BinOpToken mi AMethodInfo code CodeAttr needed Type) Type 'public
;		(define emit this:emit)
;		(if emit (this:buf:append "("))
;		(for (define i 1) (!= i (tok:toks:size)) (inc i)
;			(this:compile (tok:toks:get i) mi null Main:unknownType)
;			(if (!= (+ i 1) (tok:toks:size))
;				(if emit (this:buf:append (tok:toks:get 0)))
;			)
;		)
;		(if emit (this:buf:append ")"))
;		(set this:emit false)
;		(define out (super:compile tok mi code needed))
;		(set this:emit emit)
;		out
;	)
;	((compile tok CompareToken mi AMethodInfo code CodeAttr needed Type) Type 'public
;		(define emit this:emit)
;		(if emit (this:buf:append "("))
;		(for (define i 1) (!= i (tok:toks:size)) (inc i)
;			(this:compile (tok:toks:get i) mi null Main:unknownType)
;			(if (!= (+ i 1) (tok:toks:size))
;				(if emit (this:buf:append (tok:toks:get 0)))
;			)
;		)
;		(if emit (this:buf:append ")"))
;		(set this:emit false)
;		(define out (super:compile tok mi code needed))
;		(set this:emit emit)
;		out
;	)
;	((compile tok BeginToken mi AMethodInfo code CodeAttr needed Type) Type 'public
;		(define emit this:emit)
;		(set this:emit false)
;		(mi:pushScope null tok:labels)
;		(this:compileAll tok:toks 1 (- (tok:toks:size) 1) mi null Type:voidType)
;		(define type (this:compile (tok:toks:get (- (tok:toks:size) 1)) mi null needed))
;		(mi:popScope null)
;		(set this:emit emit)
;		(define num (if emit (this:varNum) -999))
;		(if (!= type Type:voidType)
;			(begin
;				(if emit (this:buf:append (type:getName)))
;				(if emit (this:buf:append " $"))
;				(if emit (this:buf:append num))
;				(if emit (this:buf:append ";\n"))
;			)
;		)
;		(if emit (this:buf:append "{\n"))
;		(mi:pushScope code tok:labels)
;		(for (define i 1) (< (+ i 1) (tok:toks:size)) (inc i)
;			(this:compile (tok:toks:get i) mi code Type:voidType)
;			(if emit (this:buf:append ";\n"))
;		)
;		(define last (tok:toks:get (- (tok:toks:size) 1)))
;		(if (instance? last BlockToken) (this:compile last mi code needed))
;		(if (!= type Type:voidType)
;			(begin
;				(if emit (this:buf:append "$"))
;				(if emit (this:buf:append num))
;				(if emit (this:buf:append " = "))
;			)
;		)
;		(if (instance? last BlockToken)
;			(begin
;				(if emit (this:buf:append "$"))
;				(if emit (this:buf:append (- this:varNum 1)))
;			)
;			(this:compile last mi code needed)
;		)
;		(if emit (this:buf:append ";\n"))
;		(if emit (this:buf:append "}\n"))
;		(mi:popScope code)
;		(if emit (set this:varNum (+ num 1)))
;		type
;	)
;	((compile tok SetToken mi AMethodInfo code CodeAttr needed Type) Type 'public
;		(define emit this:emit)
;		(define out (tok:toks:get 1))
;		(if (instance? out ColonToken)
;			(begin
;				(define first (out:toks:get 0))
;				(define t (mi:getType first))
;				(if (= t null)
;					(this:compile first mi null Main:unknownType)
;					(if emit (this:buf:append ((as VToken first):javaName)))
;				)
;				(if emit (this:buf:append #\.))
;				(if emit (this:buf:append (as VToken (out:toks:get 1)):val))
;			)
;			(if emit (this:buf:append ((as VToken out):javaName)))
;		)
;		(if emit (this:buf:append " = "))
;		(define type (this:compile (tok:toks:get 2) mi null needed))
;		(set this:emit false)
;		(define type (super:compile tok mi code needed))
;		(set this:emit emit)
;		type
;	)
;	((compile tok DefineToken mi AMethodInfo code CodeAttr needed Type) Type 'public
;		(define emit this:emit)
;		(define type (mi:getType (tok:toks:get 2)))
;		(define n 2)
;		(if (= type null)
;			(begin
;				(set this:emit false)
;				(set type (this:compile (tok:toks:get 2) mi null Main:unknownType))
;				(set this:emit emit)
;			)
;		(if (= (tok:toks:size) 4)
;			(set n 3)
;			;(if output (code:emitPushDefaultValue needed))
;		)
;		)
;		(if emit (this:buf:append (type:getName)))
;		(if emit (this:buf:append #\space))
;		(if emit (this:buf:append ((as VToken (tok:toks:get 1)):javaName)))
;		(if emit (this:buf:append " = "))
;		(this:compile (tok:toks:get n) mi null Main:unknownType)
;		(set this:emit false)
;		(define type (super:compile tok mi code needed))
;		(set this:emit emit)
;		type
;	)
;)
