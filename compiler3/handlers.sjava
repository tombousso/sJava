(package sjava.compiler.handlers)

(import sjava.compiler.*)
(import sjava.compiler.mfilters.*)
(import sjava.compiler.emitters.*)
(import sjava.compiler.tokens.*)

(import java.util.*)
(import gnu.bytecode.*)

(define-class Handler () 'abstract 'public
	((<init>) void (super:<init>))
	((compileAll toks List{Token} i int e int mi AMethodInfo needed Object) Type[] 'public
		(define l (toks:size))
		(define types (Type[] len:(- e i)))
		(define j i)
		(while (! (>= j e))
			(aset types (- j i)
				(this:compile (toks:get j) mi
					(if (instance? needed Type[])
						(aget (as Type[] needed) (- j i))
						needed
					)
				)
			)
			(set j (+ j 1))
		)
		types
	)
	((compile tok EmptyToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok SToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok CToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok NToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok FieldToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok QuoteToken2 mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok ConstToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok VToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok IncludeToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok ObjectToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok MacroCallToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok BeginToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok LabelToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok GotoToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok DefineToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok TryToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok InstanceToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok SetToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok ASetToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok AGetToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok ALenToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok AsToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok NumOpToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok ShiftToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok IfToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok WhileToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok CompareToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok ThrowToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok ClassToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok SynchronizedToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok TypeToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok ReturnToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok CallToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok DefaultToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok ConstructorToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok ArrayConstructorToken mi AMethodInfo needed Type) Type 'public 'abstract)
	((compile tok Token mi AMethodInfo needed Type) Type 'public
		(doubleDispatch (this:compile _ mi needed) tok)
	)
	((castMaybe result Type needed Type) Type 'public 'abstract)
)

(define-class GenHandler (Handler) 'public
	(inst GenHandler 'static 'public)
	(code CodeAttr 'public)
	((<clinit>) void 'static (set GenHandler:inst (GenHandler)))
	((<init>) void
		(super:<init>)
	)
	((compileAll toks List{Token} i int e int mi AMethodInfo code CodeAttr needed Object) Type[] 'public
		(define ocode this:code)
		(set this:code code)
		(define out (this:compileAll toks i e mi needed))
		(set this:code ocode)
		out
	)
	((compile tok Token mi AMethodInfo code CodeAttr needed Type) Type 'public
		(define ocode this:code)
		(set this:code code)
		(define out (this:compile tok mi needed))
		(set this:code ocode)
		out
	)
	((castMaybe result Type needed Type) Type 'public
		(GenHandler:castMaybe this:code result needed)
	)
	((castMaybe code CodeAttr result Type needed Type) Type 'public 'static
		(define output (!= code null))
		(if (|| (= needed Main:unknownType) (= result Main:returnType) (= result Main:throwType))
			result
			(begin
				(if (= needed Type:voidType)
					(if (!= result Type:voidType)
						(if output (code:emitPop 1))
					)
					(if (! (Type:isSame needed result))
						(if (instance? result PrimType)
							(begin
								(if (instance? needed ClassType)
									(if (= result Type:voidType)
										(if output (code:emitPushNull))
										(begin
											(define prim (PrimType:unboxedType needed))
											(define box
												(if (= prim null)
													(begin
														(set prim result)
														((as PrimType result):boxedType)
													)
													(begin
														(if output (code:emitConvert (as PrimType result) prim))
														(as ClassType needed)
													)
												)
											)
											(if output (code:emitInvoke (box:getMethod "valueOf" (Type[] prim))))
										)
									)
									(if output (code:emitConvert (as PrimType result) (as PrimType needed)))
								)
							)
							(if (instance? needed PrimType)
								(begin
									(define unbox (Main:unboxMethods:get result))
									(if output (code:emitInvoke unbox))
									(if output (code:emitConvert (as PrimType (unbox:getReturnType)) (as PrimType needed)))
								)
								(if output (code:emitCheckcast (needed:getRawType)))
							)
						)
					)
				)
				needed
			)
		)
	)
	((compile tok EmptyToken mi AMethodInfo needed Type) Type 'public
		Type:voidType
	)
	((compile tok SToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(if output (this:code:emitPushString tok:val))
		Type:javalangStringType
	)
	((compile tok CToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(define c int tok:val)
		(if (! (instance? needed PrimType))
			(begin
				(if output (this:code:emitPushInt c))
				Type:charType
			)
			(begin
				(if output (this:code:emitPushConstant c needed))
				needed
			)
		)
	)
	((compile tok NToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(define val tok:val)
		(instanceCond val
			(Double
				(if output (this:code:emitPushDouble val))
				Type:doubleType
			)
			(Float
				(if output (this:code:emitPushFloat val))
				Type:floatType
			)
			(Integer
				(if (! (instance? needed PrimType))
					(begin
						(if output (this:code:emitPushInt val))
						Type:intType
					)
					(begin
						(if output (this:code:emitPushConstant val needed))
						needed
					)
				)
			)
			(true (throw (RuntimeException)))
		)
	)
	((compile tok FieldToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(define t (mi:getType tok:left))
		(if (= t null)
			(set t (this:compile tok:left mi this:code Main:unknownType))
		)
		(define class ClassType (t:getRawType))
		(define field Field (class:getField tok:right -1))
		(if (field:getStaticFlag)
			(if output (this:code:emitGetStatic field))
			(if output (this:code:emitGetField field))
		)
		(define out (Main:resolveType t (field:getType)))
		(if (!= out Type:voidType)
			(if output (this:code:emitCheckcast (out:getRawType)))
		)
		out
	)
	((compileQuasi o Object mi AMethodInfo code CodeAttr needed Type) Type
		(define ocode this:code)
		(set this:code code)
		(define out (this:compileQuasi o mi needed))
		(set this:code ocode)
		out
	)
	((compileQuasi o Object mi AMethodInfo needed Type) Type
		(define output (!= this:code null))
		(if (= o null)
			(begin
				(if output (this:code:emitPushNull))
				(return needed)
			)
		)
		(define result
			(instanceCond o
				(UnquoteToken
					(define tok (Main:transformBlock (o:toks:get 0) mi))
					(define t (this:compile tok mi null Main:unknownType))
					(cond
						((= t (Type:getType "gnu.bytecode.Type"))
							(this:compile tok mi this:code Main:unknownType)
							(if output (this:code:emitInvoke ((Main:getCompilerType "Main"):getDeclaredMethod "typeToTok" 1)))
							(Main:getCompilerType "tokens.LexedParsedToken")
						)
						(
							(||
								(= t (Main:getCompilerType "tokens.LexedParsedToken"))
								;(&&
								(instance? t ArrayType)
								;	(= (as ArrayType t):elements (Main:getCompilerType "tokens.LexedParsedToken"))
								;)
								((t:getRawType):isSubtype (Type:getType "java.util.List"))
							)
							(this:compile tok mi this:code Main:unknownType)
						)
						(true
							(define t (this:compile tok mi null Main:unknownType))
							(define type ClassType
								(Main:getCompilerType
									(if o:var
										"tokens.VToken"
										(if (= t Type:charType)
											"tokens.CToken"
											(if (instance? t PrimType)
												"tokens.NToken"
												"tokens.SToken"
											)
										)
									)
								)
							)
							(if output (this:code:emitNew type))
							(if output (this:code:emitDup))
							(if output (this:code:emitInvoke (type:getDeclaredMethod "<init>" 0)))
							(if output (this:code:emitDup))
							(this:compile tok mi this:code Type:objectType)
							(if output (this:code:emitPutField (type:getField "val")))
							(Main:getCompilerType "tokens.LexedParsedToken")
						)
					)
				)
				(LexedParsedToken
					(define type ClassType (Type:getType ((o:getClass):getName)))
					(if output (this:code:emitNew type))
					(if output (this:code:emitDup))
					(if output (this:code:emitInvoke (type:getDeclaredMethod "<init>" 0)))
					(define superC type)
					(while (!= superC null)
						(define field (superC:getFields))
						(while (!= field null)
							(if
								(&&
									(!= (& (field:getModifiers) Access:PUBLIC) 0)
									(= (& (field:getModifiers) Access:TRANSIENT) 0)
									(= (& (field:getModifiers) Access:STATIC) 0)
								)
								(begin
									(if output (this:code:emitDup))
									(try
										(this:compileQuasi ((field:getReflectField):get o) mi this:code (field:getType))
										(e NoSuchFieldException (throw (RuntimeException e)))
										(e IllegalAccessException (throw (RuntimeException e)))
									)
									(if output (this:code:emitPutField field))
								)
							)
							(set field (field:getNext))
						)
						(set superC (superC:getSuperclass))
					)
					(if (= type (Main:getCompilerType "tokens.VToken"))
						(begin
							(if output (this:code:emitDup))
							(cond
								((instance? mi:ci MethodMacroInfo)
									(if output (this:code:emitPushInt 0))
								)
								((instance? mi:ci MacroInfo)
									(if output (this:code:emitLoad (this:code:getArg 2)))
								)
							)
							(if output (this:code:emitPutField (type:getField "macro")))
						)
					)
					(Main:getCompilerType "tokens.LexedParsedToken")
				)
				(String
					(if output (this:code:emitPushString o))
					Type:javalangStringType
				)
				(Integer
					(if output (this:code:emitPushInt o))
					Type:intType
				)
				(Long
					(if output (this:code:emitPushLong o))
					Type:longType
				)
				(Double
					(if output (this:code:emitPushDouble o))
					Type:doubleType
				)
				(Float
					(if output (this:code:emitPushFloat o))
					Type:floatType
				)
				(Boolean
					(if output (this:code:emitPushInt (if o 1 0)))
					Type:booleanType
				)
				(List
					(define al ClassType (Type:getType "java.util.ArrayList"))
					(if output (this:code:emitNew al))
					(if output (this:code:emitDup))
					(if output (this:code:emitInvoke (al:getMethod "<init>" (Type[]))))
					(define i 0)
					(while (!= i (o:size))
						(define t (this:compileQuasi (o:get i) mi null Main:unknownType))
						(if (= t (Main:getCompilerType "tokens.LexedParsedToken"))
							(begin
								(if output (this:code:emitDup))
								(this:compileQuasi (o:get i) mi this:code Main:unknownType)
								(if output (this:code:emitInvoke (al:getMethod "add" (Type[] Type:objectType))))
								(if output (this:code:emitPop 1))
							)
							(if (instance? t ArrayType)
								(begin
									(if output (this:code:emitDup))
									(this:compileQuasi (o:get i) mi this:code Main:unknownType)
									(if output (this:code:emitInvoke ((as ClassType (Type:getType "java.util.Collections")):getDeclaredMethod "addAll" 2)))
									(if output (this:code:emitPop 1))
								)
								(begin
									(if output (this:code:emitDup))
									(this:compileQuasi (o:get i) mi this:code Main:unknownType)
									(if output (this:code:emitInvoke ((as ClassType (Type:getType "java.util.List")):getDeclaredMethod "addAll" 1)))
									(if output (this:code:emitPop 1))
								)
							)
						)
						(set i (+ i 1))
					)
					al
				)
				(true
					(throw (RuntimeException ((o:getClass):toString)))
				)
			)
		)
		(this:castMaybe result needed)
	)
	((compile tok QuoteToken2 mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(this:compileQuasi tok:tok mi this:code (Main:getCompilerType "tokens.LexedParsedToken"))
	)
	((compile tok ConstToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(if (tok:val:equals "true")
			(begin
				(if output (this:code:emitPushInt 1))
				Type:booleanType
			)
			(if (tok:val:equals "false")
				(begin
					(if output (this:code:emitPushInt 0))
					Type:booleanType
				)
				(begin
					(if output (this:code:emitPushNull))
					Type:nullType
				)
			)
		)
	)
	((compile tok VToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(if (tok:val:equals "this")
			(begin
				(if (!= (& (mi:method:getModifiers) Access:STATIC) 0) (throw (RuntimeException)))
				(if output (this:code:emitPushThis))
				mi:ci:c
			)
			(begin
				(define found (mi:getVar tok))
				(found:load this:code)
			)
		)
	)
	((compile tok IncludeToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(if (= tok:ret null)
			(begin
				(mi:ci:fs:compileInclude tok)
				(try
					(set tok:ret
						(Main:transformBlock
							(as LexedParsedToken
								(
									((mi:ci:fs:includes:getClazz):getMethod (tok:mi:method:getName)
										(Class[]
											(class AMethodInfo)
											(class gnu.bytecode.Type)
											Integer:TYPE
											(class GenHandler)
										)
									):invoke null (Object[] mi needed 0 this)
								)
							)
							mi
						)
					)
					(e NoSuchMethodException (throw (RuntimeException e)))
					(e IllegalAccessException (throw (RuntimeException e)))
					(e java.lang.reflect.InvocationTargetException (throw (RuntimeException e)))
				)
			)
		)
		(this:compile tok:ret mi this:code needed)
	)
	((compile tok ObjectToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(define lambda (instance? tok LambdaToken))
		(define ci tok:ci)
		(define superT (tok:toks:get 1))
		(define FunctionN (&& lambda (instance? superT BlockToken)))
		(define emitters List{Emitter}
			(if (|| lambda (! (instance? superT BlockToken)))
				(ArrayList)
				(superT:toks:subList 1 (superT:toks:size))
			)
		)
		(if (= ci null)
			(begin
				(define captureH (CaptureVHandler mi))
				(if output
					(begin
						(set ci (ClassInfo ((mi:ci:c:getName):concat ("$":concat (Integer:toString (mi:ci:anonClasses:size)))) mi:ci:fs))
						(set tok:ci ci)
						(mi:ci:anonClasses:add ci)
					)
				)
				(if FunctionN
					(begin
						(define scope (LinkedHashMap))
						(define params (Main:getParams mi:ci superT scope 0 1))
						(define generics (ArrayList{Type} params))
						(define toks (tok:toks:subList 2 (tok:toks:size)))
						(define fakemi (MethodInfo (ClassInfo (as ClassType null) mi:ci:fs) toks null scope))
						(define ret (Main:tryBox (captureH:compile fakemi:block fakemi null Main:unknownType)))
						(generics:add ret)
						(define agenerics (Type[] len:(generics:size)))
						(generics:toArray agenerics)
						(define t (ParameterizedType (ClassType:make ("sjava.std.Function":concat (Integer:toString (params:size)))) agenerics))
						(set tok:t t)
						(if output
							(begin
								(ci:c:addInterface t)
								(ci:addMethod "apply" params ret Access:PUBLIC toks scope)
								(ci:compileMethods captureH)
							)
						)
					)
					(if lambda
						(begin
							(define t (mi:getType superT))
							(set tok:t t)
							(if output
								(begin
									(define sam ((as ClassType (t:getRawType)):checkSingleAbstractMethod))
									(define scope (LinkedHashMap))
									(define args (tok:toks:get 2))
									(define i 0)
									(define params (ArrayList{Type} (args:toks:size)))
									(while (!= i (args:toks:size))
										(define arg VToken (args:toks:get i))
										(define param (Main:resolveType t (aget (sam:getGenericParameterTypes) i)))
										(scope:put arg:val (Arg (+ i 1) param))
										(params:add param)
										(set i (+ i 1))
									)
									(ci:c:addInterface t)
									(ci:addMethod (sam:getName) params (Main:resolveType t (sam:getReturnType)) Access:PUBLIC (tok:toks:subList 3 (tok:toks:size)) scope)
									(ci:compileMethods captureH)
								)
							)
						)
						(begin
							(define t
								(if (instance? superT BlockToken)
									(mi:getType (superT:toks:get 0))
									(mi:getType superT)
								)
							)
							(set tok:t t)
							(if output
								(begin
									(if ((as ClassType (t:getRawType)):isInterface)
										(ci:c:addInterface t)
										(ci:c:setSuper t)
									)
									(define i 2)
									(while (!= i (tok:toks:size))
										(ci:compileDef (tok:toks:get i))
										(set i (+ i 1))
									)
									(ci:compileMethods captureH)
								)
							)
						)
					)
				)
				(if output
					(begin
						(define superC (ci:c:getSuperclass))
						(define types (Emitter:emitAll emitters captureH mi null Main:unknownType))
						(define filter (MFilter "<init>" types superC))
						(filter:searchDeclared)
						(define superCons (filter:getMethod))
						(set tok:captured (AVar[] len:(captureH:captured:size)))
						((captureH:captured:keySet):toArray tok:captured)
						(define fields (Field[] len:(captureH:captured:size)))
						((captureH:captured:values):toArray fields)
						(define n (alen (superCons:getGenericParameterTypes)))
						(define params (Type[] len:(+ n (alen fields))))
						(System:arraycopy (superCons:getGenericParameterTypes) 0 params 0 n)
						(define i 0)
						(while (!= i (alen fields))
							(aset params (+ n i) ((aget fields i):getType))
							(set i (+ i 1))
						)
						(define cons (ci:c:addMethod "<init>" params Type:voidType 0))
						(define ncode (cons:startCode))
						(ncode:emitLoad (ncode:getArg 0))
						(set i 0)
						(while (!= i n)
							(ncode:emitLoad (ncode:getArg (+ i 1)))
							(set i (+ i 1))
						)
						(ncode:emitInvoke superCons)
						(set i 0)
						(while (!= i (alen fields))
							(ncode:emitPushThis)
							(ncode:emitLoad (ncode:getArg (+ n i 1)))
							(ncode:emitPutField (aget fields i))
							(set i (+ i 1))
						)
						(ncode:emitReturn)
					)
				)
			)
		)
		(if output (this:code:emitNew ci:c))
		(if output (this:code:emitDup))
		(if output
			(begin
				(define i 0)
				(while (!= i (alen tok:captured))
					(emitters:add (LoadAVar (aget tok:captured i)))
					(set i (+ i 1))
				)
				(Main:emitInvoke this "<init>" ci:c emitters mi this:code Main:unknownType)
			)
		)
		tok:t
	)
	((compile tok MacroCallToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(if (= tok:ret null)
			(begin
				(define o 4)
				(define l (tok:toks:size))
				(define types (Type[] len:(+ o l) (Main:getCompilerType "AMethodInfo") (Type:getType "gnu.bytecode.Type") Type:intType (Main:getCompilerType "handlers.GenHandler")))
				(define j 0)
				(while (!= j l)
					(aset types (+ o j) (Main:getCompilerType "tokens.LexedParsedToken"))
					(set j (+ j 1))
				)
				(define method Method null)
				(define ci ClassInfo null)
				(define i 0)
				(while (= method null)
					(set ci ((mi:ci:fs:macroNames:get tok:name):get i))
					(define filter (MFilter tok:name types ci:c))
					(filter:searchDeclared)
					(set method (filter:getMethod))
					(set i (+ i 1))
				)
				(ci:compileMethods GenHandler:inst)
				(define params (method:getGenericParameterTypes))
				(define classes (Class[] len:(alen params)))
				(set j 0)
				(while (!= j (alen params))
					(aset classes j ((aget params j):getReflectClass))
					(set j (+ j 1))
				)
				(define args (ArrayList (Arrays:asList (Object[] mi needed (mi:scopes:size) this))))
				(args:addAll
					(if (&& (> (alen params) 0) (instance? (aget params (- (alen params) 1)) ArrayType))
						(begin
							(define var (- (alen params) o 1))
							(define al (ArrayList (tok:toks:subList 0 var)))
							(define out (LexedParsedToken[] len:(- (tok:toks:size) var)))
							((tok:toks:subList var (tok:toks:size)):toArray out)
							(al:add out)
							al
						)
						tok:toks
					)
				)
				(try
					(begin
						(define ret (as LexedParsedToken (((ci:getClazz):getMethod tok:name classes):invoke null (args:toArray))))
						(set tok:ret
							(Main:transformBlock
								ret
								mi
							)
						)
					)
					(e NoSuchMethodException (throw (RuntimeException e)))
					(e IllegalAccessException (throw (RuntimeException e)))
					(e java.lang.reflect.InvocationTargetException (throw (RuntimeException e)))
				)
			)
		)
		(mi:pushLevel)
		(define out (this:compile tok:ret mi this:code needed))
		(mi:popLevel)
		out
	)
	((compile tok BeginToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(mi:pushScope this:code tok:labels)
		(this:compileAll tok:toks 0 (- (tok:toks:size) 1) mi this:code Type:voidType)
		(define type (this:compile (tok:toks:get (- (tok:toks:size) 1)) mi this:code needed))
		(mi:popScope this:code)
		type
	)
	((compile tok LabelToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(define label (mi:getLabel tok:label))
		(if output (label:define this:code))
		Type:voidType
	)
	((compile tok GotoToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(if output (this:code:emitGoto (mi:getLabel tok:label)))
		Type:voidType
	)
	((compile tok DefineToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(define type
			(if (= tok:tok null)
				(begin
					(if output (this:code:emitPushDefaultValue tok:type))
					tok:type
				)
				(this:compile tok:tok mi this:code tok:type)
			)
		)
		(define var (mi:newVar this:code tok:name type))
		(if output (this:code:emitStore var))
		Type:voidType
	)
	((compile tok TryToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(define type (this:compile (tok:toks:get 1) mi null needed))
		(define last DefaultToken (tok:toks:get (- (tok:toks:size) 1)))
		(define hasFinally ((as VToken (last:toks:get 0)):val:equals "finally"))
		(if output (this:code:emitTryStart hasFinally type))
		(this:compile (tok:toks:get 1) mi this:code needed)
		(define e (- (tok:toks:size) (if hasFinally 1 0)))
		(for ((i 2)) (!= i e) (inc i)
			(define catch DefaultToken (tok:toks:get i))
			(mi:pushScope this:code (Collections:emptyMap)) ;catch:labels
			(define var (mi:newVar this:code (as VToken (catch:toks:get 0)) (mi:getType (catch:toks:get 1))))
			(if output (this:code:emitCatchStart var))
			(this:compileAll catch:toks 2 (catch:toks:size) mi this:code type)
			(if output (this:code:emitCatchEnd))
			(mi:popScope this:code)
		)
		(if hasFinally
			(begin
				(if output (this:code:emitFinallyStart))
				(this:compileAll last:toks 1 (last:toks:size) mi this:code type)
				(if output (this:code:emitFinallyEnd))
			)
		)
		(if output (this:code:emitTryCatchEnd))
		type
	)
	((compile tok InstanceToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(this:compile tok:tok mi this:code Main:unknownType)
		(if output (this:code:emitInstanceof tok:type))
		Type:booleanType
	)
	((compile tok SetToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(define first (tok:toks:get 0))
		(define out (tok:toks:get 1))
		(instanceCond out
			(FieldToken
				(define t (mi:getType out:left))
				(if (= t null)
					(set t (this:compile out:left mi this:code Main:unknownType))
				)
				(define class ClassType (t:getRawType))
				(define field Field (class:getField out:right -1))
				(this:compile (tok:toks:get 2) mi this:code (Main:resolveType t (field:getType)))
				(if (field:getStaticFlag)
					(if output (this:code:emitPutStatic field))
					(if output (this:code:emitPutField field))
				)
			)
			(true
				(define var (mi:getVar (as VToken (tok:toks:get 1))))
				(this:compile (tok:toks:get 2) mi this:code var:type)
				(var:store this:code)
			)
		)
		Type:voidType
	)
	((compile tok ASetToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(define type ArrayType (this:compile (tok:toks:get 1) mi this:code Main:unknownType))
		(this:compile (tok:toks:get 2) mi this:code Main:unknownType)
		(this:compile (tok:toks:get 3) mi this:code type:elements)
		(if output (this:code:emitArrayStore))
		Type:voidType
	)
	((compile tok AGetToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(define type ArrayType (this:compile (tok:toks:get 1) mi this:code Main:unknownType))
		(for ((i 2)) (< i (tok:toks:size)) (inc i)
			(this:compile (tok:toks:get i) mi this:code Type:intType)
			(if output (this:code:emitArrayLoad))
			(if (!= i 2) (set type (as ArrayType type:elements)))
		)
		type:elements
	)
	((compile tok ALenToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(this:compile tok:tok mi this:code Main:unknownType)
		(if output (this:code:emitArrayLength))
		Type:intType
	)
	((compile tok AsToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(this:compile tok:tok mi this:code tok:type)
	)
	((compile tok NumOpToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(define otype (Main:numericOpType (this:compileAll tok:toks 0 (tok:toks:size) mi null Main:unknownType)))
		(this:compile (tok:toks:get 0) mi this:code otype)
		(if (&& (tok:op:equals "-") (= (tok:toks:size) 1))
			(if output
				(this:code:emitPrimop
					(cond
						((= otype Type:longType) 117)
						((= otype Type:floatType) 118)
						((= otype Type:doubleType) 119)
						(true 116)
					)
					1
					otype
				)
			)
			(begin
				(define i 1)
				(while (!= i (tok:toks:size))
					(this:compile (tok:toks:get i) mi this:code otype)
					(if output (this:code:emitBinop (Main:binOps:get tok:op) otype))
					(set i (+ i 1))
				)
			)
		)
		otype
	)
	((compile tok ShiftToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(define otype (PrimType:unboxedType (this:compile tok:tok mi null Main:unknownType)))
		(this:compile tok:tok mi this:code otype)
		(this:compile tok:amt mi this:code Type:intType)
		(if output (if tok:right (this:code:emitShr) (this:code:emitShl)))
		otype
	)
	((compile tok IfToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(define hasElse (= (tok:toks:size) 4))
		(Main:emitIf this false tok:toks 1 (tok:toks:get 2) (if hasElse (tok:toks:get 3) Nothing:inst) mi this:code (if hasElse needed Type:voidType))
	)
	((compile tok WhileToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(mi:pushScope this:code tok:labels)
		(define start Label (Label))
		(if output (start:define this:code))
		(define t (Main:emitIf this false tok:toks 1 (Emitters (Emitter[] (Emitters (tok:toks:subList 2 (tok:toks:size))) (Goto start))) Nothing:inst mi this:code needed))
		(mi:popScope this:code)
		t
	)
	((compile tok CompareToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(Main:emitIf_ this false tok:toks 0 (tok:toks:size) tok:compare (ConstToken tok:line "true") (ConstToken tok:line "false") mi this:code Type:booleanType)
	)
	((compile tok ThrowToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(this:compile tok:tok mi this:code Main:unknownType)
		(if output (this:code:emitThrow))
		Main:throwType
	)
	((compile tok ClassToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(if output (this:code:emitPushClass (as ObjectType (tok:type:getRawType))))
		Type:javalangClassType
	)
	((compile tok SynchronizedToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(this:compile (tok:toks:get 1) mi this:code Main:unknownType)
		(mi:pushScope null tok:labels)
		(this:compileAll tok:toks 2 (- (tok:toks:size) 1) mi null Type:voidType)
		(define type (this:compile (tok:toks:get (- (tok:toks:size) 1)) mi null needed))
		(mi:popScope null)
		(mi:pushScope this:code tok:labels)
		(define obj (if output (this:code:addLocal Type:objectType) null))
		(if output (this:code:emitDup))
		(if output (this:code:emitStore obj))
		(if output (this:code:emitMonitorEnter))
		(if output (this:code:emitTryStart true type))
		(this:compileAll tok:toks 2 (- (tok:toks:size) 1) mi this:code Type:voidType)
		(this:compile (tok:toks:get (- (tok:toks:size) 1)) mi this:code needed)
		(if output (this:code:emitFinallyStart))
		(if output (this:code:emitLoad obj))
		(if output (this:code:emitMonitorExit))
		(if output (this:code:emitFinallyEnd))
		(if output (this:code:emitTryCatchEnd))
		(mi:popScope this:code)
		type
	)
	((compile tok TypeToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(if output (this:code:emitLoad (this:code:getArg 0)))
		(if output (this:code:emitInvoke ((Main:getCompilerType "AMethodInfo"):getDeclaredMethod "pushLevel" 0)))
		(if output (this:code:emitLoad (this:code:getArg 3)))
		(this:compile tok:tok mi this:code Main:unknownType)
		(if output (this:code:emitLoad (this:code:getArg 0)))
		(if output (this:code:emitInvoke ((Main:getCompilerType "Main"):getDeclaredMethod "transformBlock" 2)))
		(if output (this:code:emitLoad (this:code:getArg 0)))
		(if output (this:code:emitPushNull))
		(if output (this:code:emitGetStatic ((Main:getCompilerType "Main"):getField "unknownType")))
		(if output
			(this:code:emitInvoke
				((Main:getCompilerType "handlers.GenHandler"):getDeclaredMethod "compile"
					(Type[]
						(Main:getCompilerType "tokens.Token")
						(Main:getCompilerType "AMethodInfo")
						(ClassType:make "gnu.bytecode.CodeAttr")
						(ClassType:make "gnu.bytecode.Type")
					)
				)
			)
		)
		(if output (this:code:emitLoad (this:code:getArg 0)))
		(if output (this:code:emitInvoke ((Main:getCompilerType "AMethodInfo"):getDeclaredMethod "popLevel" 0)))
		(Type:getType "gnu.bytecode.Type")
	)
	((compile tok ReturnToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(if (!= tok:tok null)
			(this:compile tok:tok mi this:code Main:unknownType)
		)
		(if output (this:code:emitReturn))
		Main:returnType
	)
	((compile tok CallToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(define special
			(&&
				(instance? tok:target VToken)
				((as VToken tok:target):val:equals "super")
			)
		)
		(define t
			(if special
				(begin
					(if output (this:code:emitPushThis))
					(mi:ci:c:getGenericSuperclass)
				)
				(mi:getType tok:target)
			)
		)
		(if (= t null)
			(set t (this:compile tok:target mi this:code Main:unknownType))
		)
		(Main:emitInvoke this tok:method t (Main:toEmitters tok:toks) mi this:code needed special)
	)
	((compile tok DefaultToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(define first (tok:toks:get 0))
		(define t (this:compile first mi this:code Main:unknownType))
		(define c ClassType (t:getRawType))
		(define method (c:getDeclaredMethods))
		(define i 0)
		(define tocall Method null)
		(while (!= method null)
			(if (&& (! ((method:getName):equals "<init>")) (= 0 (& Access:SYNTHETIC (method:getModifiers))))
				(if (= tocall null)
					(set tocall method)
					(throw (RuntimeException))
				)
			)
			(set method (method:getNext))
		)
		(Main:emitInvoke this (tocall:getName) t (Main:toEmitters (tok:toks:subList 1 (tok:toks:size))) mi this:code Main:unknownType)
	)
	((compile tok ConstructorToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(define class ClassType (tok:type:getRawType))
		(if output (this:code:emitNew class))
		(if output (this:code:emitDup))
		(Main:emitInvoke this "<init>" tok:type (Main:toEmitters tok:toks) mi this:code Main:unknownType)
		tok:type
	)
	((compile tok ArrayConstructorToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(define array ArrayType tok:type)
		(if (!= tok:len null)
			(this:compile tok:len mi this:code Main:unknownType)
			(if output (this:code:emitPushInt (tok:toks:size)))
		)
		(if output (this:code:emitNewArray (array:elements:getRawType)))
		(define i 0)
		(while (!= i (tok:toks:size))
			(if output (this:code:emitDup))
			(if output (this:code:emitPushInt i))
			(this:compile (tok:toks:get i) mi this:code array:elements)
			(if output (this:code:emitArrayStore))
			(set i (+ i 1))
		)
		tok:type
	)
	((compile tok Token mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(if output (this:code:putLineNumber (mi:ci:fs:name:substring (+ (mi:ci:fs:name:lastIndexOf "/") 1)) tok:line))
		(try
			(begin
				(define type (super:compile tok mi needed))
				(this:castMaybe type needed)
			)
			(e Throwable
				(System:out:println (mi:ci:fs:name:concat (": Error compiling line ":concat (Integer:toString tok:line))))
				(throw e)
			)
		)
	)
)

(define-class CaptureVHandler (GenHandler)
	(enc AMethodInfo)
	(captured Map{AVar Field})
	(n int)
	((<init> enc AMethodInfo) void
		(super:<init>)
		(set this:enc enc)
		(set this:captured (LinkedHashMap))
	)
	((assignField vcaptured VCaptured mi AMethodInfo code CodeAttr) void
		(define output (!= code null))
		(if (&& output (= vcaptured:field null))
			(begin
				(define new (mi:ci:c:addField ("captured$":concat (Integer:toString this:n)) vcaptured:type Access:SYNTHETIC))
				(inc this:n)
				(set vcaptured:field new)
				(this:captured:put vcaptured:avar new)
			)
		)
	)
	((compile tok VToken mi AMethodInfo needed Type) Type 'public
		(define output (!= this:code null))
		(define found (mi:getVar tok))
		(if (instance? found VCaptured)
			(this:assignField (as VCaptured found) mi this:code)
		)
		(if (= found null)
			(begin
				(define outer (this:enc:getVar tok))
				(if (= outer null) (throw (RuntimeException)))
				(define vcaptured (VCaptured outer null))
				(this:assignField vcaptured mi this:code)
				(((mi:scopes:get tok:macro):getLast):put tok:val vcaptured)
				(vcaptured:load this:code)
			)
			(found:load this:code)
		)
	)
)
