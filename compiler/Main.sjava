(package sjava.compiler)

(import sjava.compiler.mfilters.*)
(import sjava.compiler.emitters.*)
(import sjava.compiler.handlers.*)
(import sjava.compiler.tokens.*)
(import sjava.compiler.commands.*)

(import java.util.*)
(import java.io.*)
(import java.nio.file.*)
(import gnu.bytecode.*)
(import org.apache.commons.cli.*)

(define-class Main () public
	(unknownType Type static public)
	(returnType Type static public)
	(throwType Type static public)
	(unboxMethods HashMap{Type Method} static public)
	(constTypes HashMap{String Type} static)
	(accessModifiers HashMap{String Short} static)
	(binOps HashMap{String Integer} static public)
	(compare2Ops HashMap{String Integer} public static)
	(compare1Ops HashMap{String Integer} public static)
	(oppositeOps HashMap{String String} static)
	(precs String[][] static) ;precedence to special token array
	(specialChars HashMap{String Character} static public)
	(MP int static) ;max precedence
	(ML int static) ;max length of a special token
	(s2prec HashMap{String Integer} static) ;special token to precedence
	(commands Map{String Command} static)
	((<clinit>) void static
		(set Main:unknownType (Type:getType "unknownType"))
		(set Main:returnType (Type:getType "returnType"))
		(set Main:throwType (Type:getType "throwType"))

		(set Main:unboxMethods (HashMap{Type Method}))
		(Main:unboxMethods:put (Type:shortType:boxedType) (Type:javalangNumberType:getDeclaredMethod "shortValue" 0))
		(Main:unboxMethods:put (Type:intType:boxedType) (Type:javalangNumberType:getDeclaredMethod "intValue" 0))
		(Main:unboxMethods:put (Type:longType:boxedType) (Type:javalangNumberType:getDeclaredMethod "longValue" 0))
		(Main:unboxMethods:put (Type:floatType:boxedType) (Type:javalangNumberType:getDeclaredMethod "floatValue" 0))
		(Main:unboxMethods:put (Type:doubleType:boxedType) (Type:javalangNumberType:getDeclaredMethod "doubleValue" 0))
		(Main:unboxMethods:put (Type:booleanType:boxedType) (Type:javalangBooleanType:getDeclaredMethod "booleanValue" 0))
		(Main:unboxMethods:put (Type:charType:boxedType) (Type:javalangCharacterType:getDeclaredMethod "charValue" 0))

		(set Main:constTypes (HashMap{String Type}))
		(Main:constTypes:put "bool" Type:booleanType)
		(Main:constTypes:put "byte" Type:byteType)
		(Main:constTypes:put "char" Type:charType)
		(Main:constTypes:put "double" Type:doubleType)
		(Main:constTypes:put "float" Type:floatType)
		(Main:constTypes:put "int" Type:intType)
		(Main:constTypes:put "long" Type:longType)
		(Main:constTypes:put "short" Type:shortType)
		(Main:constTypes:put "void" Type:voidType)

		(set Main:accessModifiers (HashMap{String Short}))
		(Main:accessModifiers:put "static" Access:STATIC)
		(Main:accessModifiers:put "public" Access:PUBLIC)
		(Main:accessModifiers:put "abstract" Access:ABSTRACT)
		(Main:accessModifiers:put "final" Access:FINAL)
		(Main:accessModifiers:put "private" Access:PRIVATE)
		(Main:accessModifiers:put "protected" Access:PROTECTED)
		(Main:accessModifiers:put "synchronized" Access:SYNCHRONIZED)
		(Main:accessModifiers:put "transient" Access:TRANSIENT)
		(Main:accessModifiers:put "volatile" Access:VOLATILE)
		(Main:accessModifiers:put "native" Access:NATIVE)
		(Main:accessModifiers:put "interface" Access:INTERFACE)
		(Main:accessModifiers:put "super" Access:SUPER)

		(set Main:binOps (HashMap{String Integer}))
		(Main:binOps:put "+" 96)
		(Main:binOps:put "-" 100)
		(Main:binOps:put "*" 104)
		(Main:binOps:put "/" 108)
		(Main:binOps:put "%" 112)
		(Main:binOps:put "&" 126)
		(Main:binOps:put "|" 128)
		(Main:binOps:put "^" 130)

		(set Main:compare2Ops (HashMap{String Integer}))
		;opposites
		(Main:compare2Ops:put "!=" 153)
		(Main:compare2Ops:put "=" 154)
		(Main:compare2Ops:put ">=" 155)
		(Main:compare2Ops:put "<" 156)
		(Main:compare2Ops:put "<=" 157)
		(Main:compare2Ops:put ">" 158)

		(set Main:compare1Ops (HashMap{String Integer}))
		;opposites
		(Main:compare1Ops:put "!=0" 153)
		(Main:compare1Ops:put "==0" 154)
		(Main:compare1Ops:put ">=0" 155)
		(Main:compare1Ops:put "<0" 156)
		(Main:compare1Ops:put "<=0" 157)
		(Main:compare1Ops:put ">0" 158)
		(Main:compare1Ops:put "!=null" 198)
		(Main:compare1Ops:put "==null" 199)

		(set Main:oppositeOps (HashMap{String String}))
		(Main:oppositeOps:put "!=" "=")
		(Main:oppositeOps:put "=" "!=")
		(Main:oppositeOps:put ">=" "<")
		(Main:oppositeOps:put "<" ">=")
		(Main:oppositeOps:put "<=" ">")
		(Main:oppositeOps:put ">" "<=")
		(Main:oppositeOps:put "!=0" "==0")
		(Main:oppositeOps:put "==0" "!=0")

		(set Main:precs
			(String[][]
				(String[] "\"\"\"" "\"" ")" "}" "]" ";")
				(String[] "'" "," ",$" "`" ":" "(" "{" "[")
			)
		)

		(set Main:specialChars (HashMap{String Character}))
		(Main:specialChars:put "space" #\space)
		(Main:specialChars:put "newline" #\newline)
		(Main:specialChars:put "lparen" #\lparen)
		(Main:specialChars:put "rparen" #\rparen)

		(set Main:MP (- (alen Main:precs) 1))

		(set Main:ML 3)

		(set Main:s2prec (HashMap{String Integer}))

		(forEach (a i) Main:precs
			(forEach b a
				(Main:s2prec:put b i)
			)
		)
	)
	((addCommandToMap c Command) void static
		(Main:commands:put (c:name) c)
	)
	((main args String[]) void public static
		(set Main:commands (LinkedHashMap))
		(Main:addCommandToMap (BuildCommand))
		(Main:addCommandToMap (RunCommand))
		(Main:addCommandToMap (FormatCommand))
		(if (= (alen args) 0)
			(begin
				(Main:printHelp)
				(return)
			)
		)
		(define arg (aget args 0))
		(if (Main:commands:containsKey arg)
			(begin
				(define cmd (Main:commands:get arg))
				(set args (Arrays:copyOfRange args 1 (alen args)))
				(define commandLine (cmd:parse args))
				(if (commandLine:hasOption "h")
					(cmd:printHelp)
					(cmd:run commandLine (commandLine:getArgList))
				)
			)
			(Main:printHelp)
		)
	)
	((printHelp) void static
		(println "usage: sjava [command] [arguments]")
		(println)
		(println "Commands:")
		(println)
		(forEach command (Main:commands:keySet)
			(println "\t" command)
		)
		(println)
	)
	((parse code String lexer Lexer parser Parser) List{LexedParsedToken} public static
		(parser:parseAll (lexer:lex code))
	)
	((compile files Collection{File} dir String) void public static
		(forEach fs (Main:compile files)
			(forEach ci fs:newClasses
				(ci:writeFiles dir)
			)
		)
	)
	((compile files Collection{File}) List{FileScope} public static
		(define mFiles (ArrayList{File}))
		(define pre
			(if (!= (System:getProperty "sjava.home") null)
				(System:getProperty "sjava.home")
				(let ((path (((((class Main):getProtectionDomain):getCodeSource):getLocation):getPath)))
					(if (path:endsWith ".jar")
						((File path):getParent)
						"."
					)
				)
			)
		)
		(mFiles:add (File (concat pre "/std/macros.sjava")))
		(mFiles:addAll files)
		(define files (LinkedHashMap{File List{LexedParsedToken}}))

		(forEach file mFiles
			(define code String null)
			(try (set code (org.apache.commons.io.FileUtils:readFileToString file)) (e IOException (throw (RuntimeException e))))
			(define line (Formatter:checkFormatted code))
			(if (!= line -1)
				(println "Warning: " file " isn't formatted (line " line ")")
			)
			(files:put file (Main:parse code (Lexer) (Parser)))
		)
		(Main:compile files)
	)
	((compile files HashMap{File List{LexedParsedToken}}) List{FileScope} public static
		(define cs (CompileScope))
		(define fileScopes (ArrayList{FileScope}))
		(define macros (ArrayList{MacroInfo}))

		(forEach entry (files:entrySet)
			(define toks (entry:getValue))
			(define fs (FileScope cs ((entry:getKey):toString) toks))
			(fileScopes:add fs)
			(fs:compileRoot macros)
		)

		(forEach fs fileScopes
			(fs:compileDefs)
		)

		(forEach macro macros
			(macro:compileMethods)
			;(Files:write (Paths:get (("macros/":concat (macro:c:getName)):concat ".class") (String[])) (macro:getClassfile) (OpenOption[]))
			(macro:addToClassLoader cs:mcl)
			(set macro:rc (macro:getClazz cs:mcl))
		)

		(forEach fs fileScopes
			(fs:runClassMacros)
		)

		(forEach fs fileScopes
			(forEach ci fs:newClasses
				(ci:compileMethods)
			)
		)

		fileScopes
	)
	((resolveType map Map{TypeVariable Type} pt Type t Type defaultToRaw bool) Type static public
		(cond
			((instance? t TypeVariable)
				(if (instance? pt ParameterizedType)
					(begin
						(define tvs ((as ClassType ((as ParameterizedType pt):getRawType)):getTypeParameters))
						(define s String ((as TypeVariable t):getName))
						(forEach (tv i) tvs
							(if ((tv:getName):equals s)
								(return ((as ParameterizedType pt):getTypeArgumentType i))
							)
						)
					)
				)
				(if (&& (!= map null) (map:containsKey (as TypeVariable t)))
					(map:get (as TypeVariable t))
					(if defaultToRaw
						(t:getRawType)
						null
					)
				)
			)
			((instance? t ArrayType)
				(ArrayType (Main:resolveType map pt (as ArrayType t):elements defaultToRaw))
			)
			((instance? t ParameterizedType)
				(define types ((as ParameterizedType t):getTypeArgumentTypes))
				(define parameterized (Type[] len:(alen types)))
				(forEach (type i) types
					(define r (Main:resolveType map pt type false))
					(if (|| (= r null) (!= 0 (as int ((as ParameterizedType t):getTypeArgumentBound i))))
						(return (t:getRawType))
					)
					(aset parameterized i r)
				)
				(ParameterizedType (as ClassType (t:getRawType)) parameterized)
			)
			(true
				t
			)
		)
	)
	((resolveType map Map{TypeVariable Type} pt Type t Type) Type static public
		(Main:resolveType map pt t true)
	)
	((resolveType pt Type t Type) Type static public
		(Main:resolveType null pt t true)
	)
	((resolveType map Map{TypeVariable Type} t Type) Type static public
		(Main:resolveType map null t true)
	)
	((unresolveTv tv TypeVariable generic Type real Type) Type static
		(cond
			((instance? generic TypeVariable)
				(if (tv:equals generic)
					(Main:tryBox real)
					null
				)
			)
			(
				(&&
					(instance? generic ParameterizedType)
					(instance? real ParameterizedType)
					((generic:getRawType):equals (real:getRawType))
				)
				(define gtypes ((as ParameterizedType generic):getTypeArgumentTypes))
				(define rtypes ((as ParameterizedType real):getTypeArgumentTypes))
				(forEach (gtype i) gtypes
					(define ret (Main:unresolveTv tv gtype (aget rtypes i)))
					(if (!= ret null)
						(return ret)
					)
				)
				null
			)
			((&& (instance? generic ArrayType) (instance? real ArrayType))
				(Main:unresolveTv tv (as ArrayType generic):elements (as ArrayType real):elements)
			)
			(true
				null
			)
		)
	)
	((unresolveTvs tvs TypeVariable[] generics Type[] reals Type[]) Map{TypeVariable Type} static public
		(if (|| (= tvs null) (!= (alen generics) (alen reals)))
			null
			(begin
				(define out (HashMap{TypeVariable Type}))
				(forEach tv tvs
					(define t Type null)
					(for ((j 0)) (&& (= t null) (!= j (alen generics))) (inc j)
						(set t (Main:unresolveTv tv (aget generics j) (aget reals j)))
					)
					(if (!= t null)
						(out:put tv t)
					)
				)
				out
			)
		)
	)
	((arrayDim t Type) int static public
		(define out 0)
		(while (instance? t ArrayType)
			(set t (as ArrayType t):elements)
			(set out (+ out 1))
		)
		out
	)
	((compileClassMod tok LexedParsedToken c ClassType) bool static
		(if (instance? tok VToken)
			(begin
				(define nmod (Main:accessModifiers:get (as VToken tok):val))
				(c:addModifiers nmod)
				true
			)
			false
		)
	)
	((getParams ci ClassInfo tok BlockToken scope LinkedHashMap i int o int) List{Type} static public
		(define n (/ (- (tok:toks:size) i) 2))
		(define types (ArrayList{Type} n))
		(for ((j 0)) (!= j n) (inc j)
			(define arg VToken (tok:toks:get (+ (* j 2) i)))
			(define type (ci:getType (tok:toks:get (+ (* j 2) i 1))))
			(types:add type)
			(scope:put arg:val (Arg type (+ o j) arg:macro))
		)
		types
	)
	((numericOpType types Type[]) Type static public
		(define l (Arrays:asList types))
		(cond
			((|| (l:contains Type:doubleType) (l:contains (Type:doubleType:boxedType)))
				Type:doubleType
			)
			((|| (l:contains Type:floatType) (l:contains (Type:floatType:boxedType)))
				Type:floatType
			)
			((|| (l:contains Type:longType) (l:contains (Type:longType:boxedType)))
				Type:longType
			)
			(true Type:intType)
		)
	)
	((isNumeric type Type) bool static public
		(define unbox (Main:tryUnbox type))
		(&& (instance? unbox PrimType) (!= unbox Type:voidType) (!= unbox Type:booleanType))
	)
	((allNumeric types Type[]) bool static public
		(forEach type types
			(if (! (Main:isNumeric type))
				(return false)
			)
		)
		true
	)
	((tryBox t Type) Type static public
		(if (instance? t PrimType)
			((as PrimType t):boxedType)
			t
		)
	)
	((tryUnbox t Type) Type static public
		(define o (PrimType:unboxedType t))
		(if (= o null)
			t
			o
		)
	)
	((isCompare s String) bool static public
		(|| (s:equals "!") (s:equals "&&") (s:equals "||") (Main:compare2Ops:containsKey s))
	)
	((invertComp inv bool comp String) String public static
		(if inv
			(Main:oppositeOps:get comp)
			comp
		)
	)
	((emitInvoke h GenHandler name String type Type emitters List{Emitter} needed Type special bool static_ bool) Tuple2{Type MethodCall} static public
		(define types (Emitter:emitAll emitters h null Main:unknownType))
		;(System:out:println name)
		;(System:out:println type)
		;(System:out:println (Arrays:toString types))
		(define filter (MFilter name types type static_))
		(if special
			(filter:searchDeclared)
			(filter:searchAll)
		)
		(define mc (filter:getMethodCall))
		(Tuple2 (Main:emitInvoke h mc emitters needed special) mc)
	)
	((emitInvoke h GenHandler name String type Type emitters List{Emitter} needed Type static_ bool) Tuple2{Type MethodCall} static public
		(Main:emitInvoke h name type emitters needed false static_)
	)
	((emitInvoke h GenHandler mc MethodCall emitters List{Emitter} needed Type special bool) Type static public
		(define code h:code)
		(define output (!= code null))
		(define method mc:m)
		;(System:out:println method)
		(define typeParameters (method:getTypeParameters))
		(define params (method:getGenericParameterTypes))
		(define varargs (!= (& (method:getModifiers) Access:TRANSIENT) 0))
		(begin
			(define j 0)
			(define n
				(if
					(&&
						varargs
						(||
							(< (alen mc:types) (alen params))
							(!= (Main:arrayDim (aget params (- (alen params) 1))) (Main:arrayDim (aget mc:types (- (alen params) 1))))
						)
					)
					1
					0
				)
			)
			(while (!= j (- (alen params) n))
				((emitters:get j):emit h code (Main:resolveType mc:tvs mc:t (aget params j)))
				(inc j)
			)
			(if (= n 1)
				(begin
					(define at ArrayType (aget params (- (alen params) 1)))
					(define et (Main:resolveType mc:tvs mc:t at:elements))
					(if output (code:emitPushInt (+ 1 (- (alen mc:types) (alen params)))))
					(if output (code:emitNewArray (at:elements:getRawType)))
					(define oj j)
					(while (!= j (alen mc:types))
						(if output (code:emitDup))
						(if output (code:emitPushInt (- j oj)))
						((emitters:get j):emit h code et)
						(if output (code:emitArrayStore))
						(inc j)
					)
				)
			)
		)
		(if special
			(if output (code:emitInvokeSpecial method))
			(if output (code:emitInvoke method))
		)
		(define out (Main:resolveType mc:tvs mc:t (method:getReturnType)))
		(if (&& (!= out Type:voidType) (!= needed Type:voidType))
			(if output (code:emitCheckcast (out:getRawType)))
		)
		(h:castMaybe out needed)
	)
	((emitInvoke h GenHandler mc MethodCall emitters List{Emitter} needed Type) Type static public
		(Main:emitInvoke h mc emitters needed false)
	)
	((compareType types Type[]) Type public static
		(cond
			((Main:allNumeric types)
				(Main:numericOpType types)
			)
			(
				(=
					(+
						(Collections:frequency (Arrays:asList types) Type:booleanType)
						(Collections:frequency (Arrays:asList types) (ClassType:make "java.lang.Boolean"))
					)
					(alen types)
				)
				Type:booleanType
			)
			(true Type:objectType)
		)
	)
	((compare a Type b Type) int public static
		(cond
			(
				(&&
					(|| (instance? a ClassType) (instance? a ParameterizedType))
					(|| (instance? b ClassType) (instance? b ParameterizedType))
				)
				;raw types
				(if
					(&&
						(instance? a ClassType) (instance? b ParameterizedType)
						(!= ((as ClassType a):getTypeParameters) null) (!= (alen ((as ClassType a):getTypeParameters)) 0)
					)
					(set b (b:getRawType))
				)
				(if
					(&&
						(instance? a ParameterizedType) (instance? b ClassType)
						(!= ((as ClassType b):getTypeParameters) null) (!= (alen ((as ClassType b):getTypeParameters)) 0)
					)
					(set a (a:getRawType))
				)
				(cond
					((Type:isSame a b)
						0
					)
					;return 1 if "a" is supertype of "b"
					(true
						(forEach super (Main:superTypes b)
							(if (Type:isSame a super)
								(return 1)
							)
						)
						-1
					)
				)
			)
			(true
				(a:compare b)
			)
		)
	)
	((getGenericSuperclass a Type) Type public static
		(Main:resolveType a ((as ClassType (a:getRawType)):getGenericSuperclass))
	)
	((getGenericInterfaces a Type) List{Type} public static
		(define gintfs ((as ClassType (a:getRawType)):getGenericInterfaces))
		(cond
			((= gintfs null)
				Collections:EMPTY_LIST
			)
			(true
				(define o (ArrayList{Type}))
				(forEach intf gintfs
					(o:add (Main:resolveType a intf))
				)
				o
			)
		)
	)
	((superClasses a Type) LinkedHashSet{Type} public static
		(define o (LinkedHashSet{Type}))
		(for ((superA Type a)) (!= superA null) (set superA (Main:getGenericSuperclass superA))
			(o:add superA)
		)
		(o:add Type:javalangObjectType)
		o
	)
	((superIntfs sc LinkedHashSet{Type}) LinkedHashSet{Type} public static
		(define o (LinkedHashSet{Type}))
		(forEach superA sc
			(if (superA:isInterface)
				(o:add superA)
			)
			(define q (ArrayDeque{Type}))
			(q:addAll (Main:getGenericInterfaces superA))
			(while (! (q:isEmpty))
				(define t (q:poll))
				(o:add t)
				(q:addAll (Main:getGenericInterfaces t))
			)
		)
		o
	)
	((superTypes a Type) LinkedHashSet{Type} public static
		(define o (Main:superClasses a))
		(o:addAll (Main:superIntfs o))
		o
	)
	((superType a Type b Type) Type public static
		(define supersA (Main:superClasses a))
		(define supersB (Main:superClasses b))
		(forEach t supersA
			(if (&& (!= t Type:javalangObjectType) (supersB:contains t))
				(return t)
			)
		)
		(define intfsA (Main:superIntfs supersA))
		(define intfsB (Main:superIntfs supersB))
		(intfsA:retainAll intfsB)
		(forEach intf1 intfsA
			(define supers (static:superIntfs (static:superClasses intf1)))
			(forEach intf2 intfsA
				(if (! (supers:contains intf2))
					(goto next)
				)
			)
			(return intf1)
			(label next)
		)
		Type:objectType
	)
	((commonType a Type b Type) Type public static
		(define aReturns
			(||
				(= a Main:returnType)
				(= a Main:throwType)
			)
		)
		(define bReturns
			(||
				(= b Main:returnType)
				(= b Main:throwType)
			)
		)
		(cond
			((|| (= a Type:voidType) (= b Type:voidType))
				Type:voidType
			)
			((&& aReturns bReturns)
				Type:voidType
			)
			(aReturns
				b
			)
			(bReturns
				a
			)
			((= a Type:nullType)
				(Main:tryBox b)
			)
			((= b Type:nullType)
				(Main:tryBox a)
			)
			((Type:isSame a b)
				a
			)
			((&& (Main:isNumeric a) (Main:isNumeric b))
				(set a (Main:tryUnbox a))
				(set b (Main:tryUnbox b))
				(define l (Arrays:asList (Type[] a b)))
				(cond
					((Type:isSame a b)
						a
					)
					((l:contains Type:doubleType)
						Type:doubleType
					)
					((l:contains Type:floatType)
						Type:floatType
					)
					((l:contains Type:longType)
						Type:longType
					)
					((l:contains Type:intType)
						Type:intType
					)
					((&& (l:contains Type:shortType) (l:contains Type:booleanType)) ;one of each
						Type:shortType
					)
					(true (throw (RuntimeException)))
				)
			)
			((&& (= (Main:tryUnbox a) Type:booleanType) (= (Main:tryUnbox b) Type:booleanType))
				Type:booleanType
			)
			(true
				(Main:superType a b)
			)
		)
	)
	((generateBridgeMethod target Method params Type[] ret Type) void static public
		(define c (target:getDeclaringClass))
		(define rparams (Type[] len:(alen params)))
		(for ((i 0)) (!= i (alen params)) (inc i)
			(aset rparams i ((aget params i):getRawType))
		)
		(define found (c:getDeclaredMethod (target:getName) rparams))
		(if (|| (= found null) (! (Type:isSame (found:getReturnType) ret)))
			(begin
				(define m (c:addMethod (target:getName) rparams (ret:getRawType) (| Access:PUBLIC Access:BRIDGE Access:SYNTHETIC)))
				(define code (m:startCode))
				(code:emitPushThis)
				(for ((i 0)) (!= i (alen rparams)) (inc i)
					(code:emitLoad (code:getArg (+ i 1)))
					(GenHandler:castMaybe code (aget rparams i) (aget (target:getGenericParameterTypes) i))
				)
				(code:emitInvoke target)
				(GenHandler:castMaybe code (target:getReturnType) (ret:getRawType))
				(code:emitReturn)
			)
		)
	)
	((getCompilerType name String) ClassType static public
		(ClassType:make (concat "sjava.compiler." name))
	)
	((toEmitters l List) List{Emitter} public static
		l
	)
	((toLexedParsed l List) List{LexedParsedToken} public static
		l
	)
	((typeToTok t Type) LexedParsedToken public static
		(instanceCond t
			(ArrayType
				(ArrayToken -1 (ArrayList (Arrays:asList (Main:typeToTok (t:getComponentType)))))
			)
			(ParameterizedType
				(define toks (ArrayList{LexedParsedToken}))
				(forEach ta (t:getTypeArgumentTypes)
					(toks:add (Main:typeToTok ta))
				)
				(GenericToken -1 (Main:typeToTok (t:getRawType)) toks)
			)
			(true
				(VToken -1 (t:getName))
			)
		)
	)
	((extractModifiers toks List{LexedParsedToken} i int) Tuple2{Integer Integer} public static
		(define mods 0)
		(for () (< i (toks:size)) (inc i)
			(define tok (toks:get i))
			(if (&& (instance? tok VToken) (Main:accessModifiers:containsKey (as VToken tok):val))
				(set mods (| mods (Main:accessModifiers:get (as VToken tok):val)))
				(return (Tuple2 mods i))
			)
		)
		(Tuple2 mods i)
	)
	((getClassLoader) ArrayClassLoader public static
		(ArrayClassLoader)
	)
)

(define-class Formatter () public
	((formatCode code String) String public static
		(concat (Formatter:formatToks (Main:parse code (Lexer) (Parser false))) #\newline)
	)
	((formatToks block LexedParsedToken tabs int before String after String sb StringBuffer toks List{LexedParsedToken}) int static
		(sb:append before)
		(define line 0)
		(define prevMultiline false)
		(forEach (tok i) toks
			(define indent false)
			(define toLine tok:line)
			(define multiline (!= (tok:firstLine) (tok:lastLine)))
			(if (= i 0)
				(if multiline
					(begin
						(set toLine (+ line 1))
						(set indent true)
					)
					(set toLine line)
				)
				(if (&& (= tok:line line) multiline)
					(begin
						(set toLine (+ tok:line 1))
						(set indent true)
					)
					(begin
						(if (= tok:line line)
							(if prevMultiline
								(inc toLine 1)
								(sb:append " ")
							)
						)
						(set indent (!= tok:line block:line))
					)
				)
			)
			(set line (Formatter:formatTok tok line toLine (+ tabs (if indent 1 0)) sb))
			(set prevMultiline multiline)
		)
		(if (!= (block:firstLine) (block:lastLine))
			(begin
				(sb:append "\n")
				(repeat tabs (sb:append "\t"))
			)
		)
		(sb:append after)
		(set line block:endLine)
		line
	)
	((formatToks toks List{LexedParsedToken}) String static
		(define sb (StringBuffer))
		(define line (if (!= (toks:size) 0) (toks:get 0):line 1))
		(forEach (tok i) toks
			(define off (if (&& (= tok:line line) (!= i 0)) 1 0))
			(set line (Formatter:formatTok tok line (+ tok:line off) 0 sb))
		)
		(sb:toString)
	)
	((formatTok tok LexedParsedToken line int toLine int tabs int sb StringBuffer) int static
		(repeat (- toLine line) (sb:append "\n"))
		(if (!= toLine line) (repeat tabs (sb:append "\t")))
		(set line tok:line)
		(instanceCond tok
			(BlockToken
				(set line (Formatter:formatToks tok tabs "(" ")" sb tok:toks))
			)
			(GenericToken
				(set line (Formatter:formatTok tok:tok line line tabs sb))
				(set line (Formatter:formatToks tok tabs "{" "}" sb tok:toks))
			)
			(ArrayToken
				(set line (Formatter:formatTok (tok:toks:get 0) line line tabs sb))
				(set line (Formatter:formatToks tok tabs "[" "]" sb (tok:toks:subList 1 (tok:toks:size))))
			)
			(ColonToken
				(set line (Formatter:formatTok tok:left line line tabs sb))
				(sb:append ":")
				(set line (Formatter:formatTok tok:right line line tabs sb))
			)
			(SingleQuoteToken
				(sb:append "'")
				(set line (Formatter:formatTok (tok:toks:get 0) line line tabs sb))
			)
			(QuoteToken
				(sb:append "`")
				(set line (Formatter:formatTok (tok:toks:get 0) line line tabs sb))
			)
			(UnquoteToken
				(sb:append (if tok:var ",$" ","))
				(set line (Formatter:formatTok (tok:toks:get 0) line line tabs sb))
			)
			(CommentToken
				(sb:append ";")
				(sb:append tok:val)
			)
			(true
				(sb:append (tok:toString))
			)
		)
		tok:endLine
	)
	((checkFormatted code String) int public static
		(define formatted (Formatter:formatCode code))
		(define line 1)
		(define len (Math:min (code:length) (formatted:length)))
		(for ((i 0)) (< i len) (inc i)
			(if (!= (code:charAt i) (formatted:charAt i))
				(return line)
			)
			(if (= (code:charAt i) #\newline) (inc line))
		)
		(if (!= (code:length) (formatted:length))
			line
			-1
		)
	)
)

(define-class Tester () public
	((main args String[]) void public static
		(define exit 0)
		(try
			(begin
				(define dir (File "examples/"))
				(define fileFilter Object (org.apache.commons.io.filefilter.WildcardFileFilter "*.expected.txt"))
				(define files (dir:listFiles (as FileFilter fileFilter)))
				(System:setProperty "line.separator" "\n")
				(forEach file files
					(define fname (file:getName))
					(define name (fname:substring 0 (fname:indexOf ".")))
					(define c (Class:forName (concat "examples." name ".Main")))
					(define baos (ByteArrayOutputStream))
					(define ps (PrintStream baos))
					(define old System:out)
					(System:setOut ps)
					((c:getMethod "main" (class String[])):invoke null null)
					(ps:flush)
					(System:setOut old)
					(define expected (org.apache.commons.io.FileUtils:readFileToString file))
					(define out (baos:toString))
					(define passed (out:equals expected))
					(println name ": " (if passed "PASSED" "FAILED"))
					(if (! passed) (set exit 1))
				)
			)
			(e Throwable
				(e:printStackTrace)
				(System:exit 1)
			)
		)
		(System:exit exit)
	)
)

(define-class Lexer () public
	(code String)
	(i int)
	(len int)
	(s String)
	(line int)
	((<init>) void public
		(super:<init>)
	)
	((getprec) int
		;check if code at i is a special token
		(define p -1)
		(define l Main:ML)
		(while (&& (= p -1) (!= l 0))
			(if (<= (+ this:i l) this:len)
				(begin
					(set this:s (this:peek 0 l))
					(if (Main:s2prec:containsKey this:s)
						(set p (Main:s2prec:get this:s))
					)
				)
			)
			(set l (- l 1))
		)
		p
	)
	((peek n int l int) String
		(this:code:substring (+ this:i n) (+ this:i n l))
	)
	((peek n int) char
		(this:code:charAt (+ this:i n))
	)
	((peek) char
		(this:peek 0)
	)
	((skip n int) void
		(for ((i 0)) (< i n) (inc i)
			(if (= (this:peek) #\newline)
				(inc this:line)
			)
			(inc this:i)
		)
	)
	((skip) void
		(this:skip 1)
	)
	((nextTok) void
		(while (&& (!= this:i this:len) (= (this:getprec) -1) (! (Character:isWhitespace (this:peek))))
			(this:skip 1)
		)
	)
	((token) LexedToken
		(while (&& (!= this:i this:len) (= (this:getprec) -1) (Character:isWhitespace (this:peek)))
			(this:skip 1)
		)
		(define p (this:getprec))
		(define oline this:line)
		(define out LexedToken
			(if (= p -1)
				(begin
					(define c (if (= this:i this:len) (as char 0) (this:peek)))
					(define oi this:i)
					(if (= c #\#)
						(begin
							(while (&& (!= (this:peek) #\space) (!= (this:peek) #\rparen))
								(this:skip 1)
							)
							(define schar (this:code:substring (+ oi 2) this:i))
							(CToken this:line
								(if (= (schar:length) 1)
									(schar:charAt 0)
									(Main:specialChars:get schar)
								)
							)
						)
						(if (|| (Character:isDigit c) (&& (= c #\-) (Character:isDigit (this:peek 1))))
							(begin
								(this:nextTok)
								(NToken this:line (this:code:substring oi this:i))
							)
							(begin
								(this:nextTok)
								(define s (this:code:substring oi this:i))
								(if (s:equals "")
									null
									(if (|| (s:equals "null") (s:equals "true") (s:equals "false"))
										(ConstToken this:line s)
										(VToken this:line s)
									)
								)
							)
						)
					)
				)
				(begin
					(this:skip (this:s:length))
					(define oi this:i)
					(if (this:s:equals "\"\"\"")
						(begin
							(while (! ((this:peek 0 3):equals "\"\"\""))
								(if ((this:peek 0 7):equals "\\\"\"\"\"\"\"")
									(this:skip 4)
									(if (|| ((this:peek 0 5):equals "\\\\\"\"\"") ((this:peek 0 5):equals "\\\"\"\"\""))
										(this:skip 2)
										(if ((this:peek 0 4):equals "\\\"\"\"")
											(this:skip 4)
											(this:skip)
										)
									)
								)
							)
							(define str ((this:code:substring oi this:i):replace "\\\"\"\"" "\"\"\""))
							(if (str:endsWith "\\\\")
								(set str (concat (str:substring 0 (- (str:length) 2)) "\\"))
								(if (str:endsWith "\\\"")
									(set str (concat (str:substring 0 (- (str:length) 2)) "\""))
								)
							)
							(this:skip 3)
							(SToken oline str true)
						)
						(if (this:s:equals "\"")
							(begin
								(while (!= (this:peek) #\")
									(if (= (this:peek) #\\)
										(this:skip 2)
										(this:skip)
									)
								)
								(this:skip)
								(SToken this:line (org.apache.commons.lang3.StringEscapeUtils:unescapeJava (this:code:substring oi (- this:i 1))) false)
							)
							(if (this:s:equals ";")
								(begin
									(while (&& (!= this:i this:len) (!= (this:peek) #\newline))
										(this:skip)
									)
									(CommentToken this:line (this:code:substring oi this:i))
								)
								(LexedToken this:line p this:s)
							)
						)
					)
				)
			)
		)
		(if (!= out null)
			(set out:endLine this:line)
		)
		out
	)
	((lex code String) List{LexedToken}
		(set this:code code)
		(set this:i 0)
		(set this:len (code:length))
		(set this:line 1)
		(define out (ArrayList{LexedToken}))
		(while
			(!= this:i this:len)
			(define tok (this:token))
			(if (!= tok null) (out:add tok))
		)
		out
	)
)

(define-class Parser () public
	(toks List{LexedToken})
	(i int)
	(ignoreComments bool)
	((<init> ignoreComments bool) void public
		(super:<init>)
		(set this:ignoreComments ignoreComments)
	)
	((<init>) void public
		(this:<init> true)
	)
	((next) LexedToken
		(define ret (this:toks:get this:i))
		(inc this:i)
		ret
	)
	((peek n int) LexedToken
		(this:toks:get (+ this:i n))
	)
	((subToks end String) ArrayList{LexedParsedToken}
		(define toks (ArrayList{LexedParsedToken}))
		(while (! ((this:peek 0):what:equals end))
			(define t (this:parse 0))
			(if (!= t null) (toks:add t))
		)
		(this:next)
		toks
	)
	((parse prec int) LexedParsedToken
		(define t (this:next))
		(define w t:what)
		(define left LexedParsedToken
			(cond
				((w:equals "(")
					(define toks (this:subToks ")"))
					(BlockToken t:line toks)
				)
				((|| (w:equals "'") (w:equals "`") (w:equals ",$") (w:equals ","))
					(define al (Arrays:asList (this:parse 0)))
					(if (|| (w:equals ",") (w:equals ",$"))
						(UnquoteToken t:line al (w:equals ",$"))
						(if (w:equals "'")
							(SingleQuoteToken t:line al)
							(QuoteToken t:line al)
						)
					)
				)
				((&& this:ignoreComments (instance? t CommentToken))
					(return null)
				)
				(true
					t
				)
			)
		)
		(if (= left:endLine 0) (set left:endLine (this:peek -1):line))
		(define cont true)
		(while (&& cont (!= this:i (this:toks:size)) (> (this:prec) prec))
			(define w (this:peek 0):what)
			(cond
				((w:equals ":")
					(this:next)
					(define right (this:parse 1))
					(set left (ColonToken t:line left right))
				)
				((w:equals "{")
					(this:next)
					(define toks (this:subToks "}"))
					(set left (GenericToken t:line left toks))
				)
				((w:equals "[")
					(this:next)
					(define toks (this:subToks "]"))
					(toks:add 0 left)
					(set left (ArrayToken t:line toks))
				)
				(true
					(set cont false)
				)
			)
			(if cont (set left:endLine (this:peek -1):line))
		)
		left
	)
	((prec) int
		(this:peek 0):prec
	)
	((parseAll toks List{LexedToken}) List{LexedParsedToken}
		(set this:i 0)
		(set this:toks toks)
		(define out (ArrayList{LexedParsedToken}))
		(while (!= this:i (this:toks:size))
			(define t (this:parse 0))
			(if (!= t null) (out:add t))
		)
		out
	)
)

(define-class CompileScope () public
	(locals HashMap{String ClassType})
	(macroNames HashMap{String List{MacroInfo}} public)
	(classMacroNames HashMap{String List{MacroInfo}})
	(mcl ArrayClassLoader)
	(found HashMap{String Boolean})
	(macroIndex int)
	((<init>) void
		(super:<init>)
		(set this:locals (HashMap))
		(set this:macroNames (HashMap))
		(set this:classMacroNames (HashMap))
		(set this:mcl (Main:getClassLoader))
		(set this:found (HashMap))
		(set this:macroIndex 0)
	)
	((classExists name String) bool
		(if (this:found:containsKey name)
			(this:found:get name)
			(begin
				(define b
					(try
						(begin
							(((class Main):getClassLoader):loadClass name)
							true
						)
						(e ClassNotFoundException false)
						(e NoClassDefFoundError false)
					)
				)
				(this:found:put name b)
				b
			)
		)
	)
)

(define-class FileScope () public
	(cs CompileScope public)
	(path String public)
	(toks List{LexedParsedToken})
	(imports HashMap{String String})
	(starImports ArrayList{String})
	(includes MacroInfo public)
	(newClasses List{ClassInfo} public)
	(package_ String)
	((<init> cs CompileScope path String toks List{LexedParsedToken}) void
		(super:<init>)
		(set this:cs cs)
		(set this:path path)
		(set this:toks toks)
		(set this:imports (HashMap))
		(set this:starImports (ArrayList))
		(this:starImports:add "java.lang.")
		(this:starImports:add "sjava.std.")
		(set this:newClasses (ArrayList{ClassInfo}))
		(set this:package_
			(if
				(&&
					(> (toks:size) 0)
					(instance? (toks:get 0) BlockToken)
					(instance? ((as BlockToken (toks:get 0)):toks:get 0) VToken)
					((as VToken ((as BlockToken (toks:get 0)):toks:get 0)):val:equals "package")
				)
				((as VToken ((as BlockToken (toks:get 0)):toks:get 1)):val:concat ".")
				""
			)
		)
		(define includes (MacroInfo this "Includes"))
		(set this:includes includes)
		(includes:c:setModifiers Access:PUBLIC)
	)
	((getNewType tok Token) ClassType
		(instanceCond tok
			(GenericToken
				(define c (ClassType (this:package_:concat (as VToken tok:tok):val)))
				(define tparams (TypeVariable[] len:(tok:toks:size)))
				(forEach (param i) tok:toks
					(define name (as VToken param):val)
					(define tv (TypeVariable name))
					(aset tparams i tv)
				)
				(c:setTypeParameters tparams)
				c
			)
			(VToken
				(ClassType (this:package_:concat tok:val))
			)
			(true null)
		)
	)
	((compileRoot macros List{MacroInfo}) void
		(forEach tok this:toks
			(this:compileRoot macros (as BlockToken tok))
		)
	)
	((getMacroParams out List{Type} params BlockToken scope Map) bool
		(define varargs false)
		(define o (out:size))
		(forEach (tok i) (params:toks:subList 1 (params:toks:size))
			(define t Object (Main:getCompilerType "tokens.LexedParsedToken"))
			(define name (as VToken tok):val)
			(if (name:contains "@")
				(begin
					(set name (name:replace "@" ""))
					(set t (ArrayType (as Type t)))
					(set varargs true)
				)
			)
			(out:add (as Type t))
			(scope:put name (Arg (as Type t) (+ o i) 0))
		)
		varargs
	)
	((compileRoot macros List{MacroInfo} tok BlockToken) void
		(define first (tok:toks:get 0))
		(when (instance? first VToken)
			(cond
				((first:val:equals "define-class")
					(define c (this:getNewType (tok:toks:get 1)))
					(define name (c:getName))
					(define ci (ClassInfo this c))
					(set ci:supers (as BlockToken (tok:toks:get 2)))
					(this:newClasses:add ci)
					(this:cs:locals:put name ci:c)
					(define run true)
					(define i 3)
					(for () (&& run (!= i (tok:toks:size))) ()
						(set run (Main:compileClassMod (tok:toks:get i) ci:c))
						(if run (inc i))
					)
					(set ci:toks (tok:toks:subList i (tok:toks:size)))
				)
				((first:val:equals "import")
					(define import (as VToken (tok:toks:get 1)):val)
					(if (import:endsWith "*")
						(this:starImports:add (import:substring 0 (- (import:length) 1)))
						(this:imports:put (import:substring (+ (import:lastIndexOf ".") 1)) import)
					)
				)
				((first:val:equals "define-macro")
					(define scope (LinkedHashMap))
					(define params BlockToken (tok:toks:get 1))
					(define name (as VToken (params:toks:get 0)):val)
					(define types (ArrayList{Type} (Arrays:asList (Type[] (Main:getCompilerType "AMethodInfo") Type:intType (Main:getCompilerType "handlers.GenHandler")))))
					(define mods (| Access:PUBLIC Access:STATIC))
					(scope:put "mi" (Arg (Main:getCompilerType "AMethodInfo") 0 0))
					(define varargs (this:getMacroParams types params scope))
					(if varargs (set mods (| mods Access:TRANSIENT)))
					(define cname (concat "Macros" this:cs:macroIndex))
					(inc this:cs:macroIndex)
					(define macroi (MacroInfo this cname))
					(macroi:c:setModifiers Access:PUBLIC)
					(define macro (macroi:addMethod name types (Main:getCompilerType "tokens.LexedParsedToken") mods (tok:toks:subList 2 (tok:toks:size)) scope))
					(if (this:cs:macroNames:containsKey name)
						((this:cs:macroNames:get name):add macroi)
						(this:cs:macroNames:put name (ArrayList (Arrays:asList macroi)))
					)
					(macros:add macroi)
				)
				((first:val:equals "define-class-macro")
					(define scope (LinkedHashMap))
					(define params BlockToken (tok:toks:get 1))
					(define name (as VToken (params:toks:get 0)):val)
					(define types (ArrayList{Type} (Arrays:asList (Type[] (Main:getCompilerType "ClassInfo")))))
					(define mods (| Access:PUBLIC Access:STATIC))
					(scope:put "ci" (Arg (Main:getCompilerType "ClassInfo") 0 0))
					(define varargs (this:getMacroParams types params scope))
					(if varargs (set mods (| mods Access:TRANSIENT)))
					(define cname "Macros")
					(define macroi (MacroInfo this cname))
					(macroi:c:setModifiers Access:PUBLIC)
					(define macro (macroi:addClassMacroMethod name types Type:voidType mods (tok:toks:subList 2 (tok:toks:size)) scope))
					(if (this:cs:classMacroNames:containsKey name)
						((this:cs:classMacroNames:get name):add macroi)
						(this:cs:classMacroNames:put name (ArrayList (Arrays:asList macroi)))
					)
				)
				((! (first:val:equals "package"))
					(throw (RuntimeException first:val))
				)
			)
		)
	)
	((compileDefs) void
		(forEach ci this:newClasses
			(ci:compileDefs)
		)
	)
	((runClassMacros) void
		(forEach ci this:newClasses
			(ci:runClassMacros)
		)
	)
	((compileInclude tok IncludeToken) void public
		(define name ("$":concat (Integer:toString (this:includes:c:getMethodCount))))
		(define scope (LinkedHashMap))
		(scope:put "mi" (Arg (Main:getCompilerType "AMethodInfo") 0 0))
		(define params (Type[] (Main:getCompilerType "AMethodInfo") Type:intType (Main:getCompilerType "handlers.GenHandler")))
		(define mi (this:includes:addMethod name (Arrays:asList params) (Main:getCompilerType "tokens.LexedParsedToken") (| Access:PUBLIC Access:STATIC) tok:toks scope))
		(mi:compileMethodBody (GenHandler mi))
		(set tok:mi mi)
	)
)

(define-class ClassInfo () public
	(fs FileScope public)
	(c ClassType public)
	(supers BlockToken)
	(toks List{LexedParsedToken})
	(methods List{AMethodInfo} public)
	(anonClasses List{ClassInfo} public)
	(rc Class)
	(tvs HashMap{String TypeVariable})
	(classfile byte[])
	((<init> fs FileScope c ClassType) void public
		(super:<init>)
		(set this:fs fs)
		(set this:c c)
		(set this:methods (ArrayList{AMethodInfo}))
		(set this:anonClasses (ArrayList{ClassInfo}))
		(if (!= c null)
			(begin
				(this:c:setClassfileVersion ClassType:JDK_1_8_VERSION)
				(this:c:setSuper Type:javalangObjectType)
				(define args (c:getTypeParameters))
				(if (!= args null)
					(begin
						(set this:tvs (HashMap{String TypeVariable}))
						(forEach tv args
							(if (instance? tv TypeVariable)
								(this:tvs:put (tv:getName) (as TypeVariable tv))
							)
						)
					)
				)
			)
		)
	)
	((<init> fs FileScope name String) void public
		(this:<init> fs (ClassType name))
	)
	((getClassfile) byte[]
		(if (= this:classfile null)
			(set this:classfile (this:c:writeToArray))
		)
		this:classfile
	)
	((addToClassLoader cl ArrayClassLoader) void public
		(cl:addClass (this:c:getName) (this:getClassfile))
		(forEach anon this:anonClasses
			(anon:addToClassLoader cl)
		)
	)
	((getClazz cl ArrayClassLoader) Class public
		(define c Class null)
		(try (set c (cl:loadClass (this:c:getName))) (e ClassNotFoundException (throw (RuntimeException e))))
		c
	)
	((getClazz) Class public
		(if (= this:rc null)
			(begin
				(define cl (Main:getClassLoader))
				(this:addToClassLoader cl)
				(set this:rc (this:getClazz cl))
			)
		)
		this:rc
	)
	((writeFiles dir String) void public
		(define pre (concat dir "/" (this:fs:package_:replace "." "/")))
		((File pre):mkdirs)
		(try
			(org.apache.commons.io.FileUtils:writeByteArrayToFile (File (concat pre (this:c:getSimpleName) ".class")) (this:getClassfile))
			(e IOException (throw (RuntimeException e)))
		)
		(forEach anon this:anonClasses
			(anon:writeFiles dir)
		)
	)
	((getType name String allowNew bool) Type
		(define abs (name:contains "."))
		(cond
			((&& (!= this:tvs null) (this:tvs:containsKey name))
				(this:tvs:get name)
			)
			((Main:constTypes:containsKey name)
				(Main:constTypes:get name)
			)
			((&& allowNew (this:fs:cs:locals:containsKey name))
				(this:fs:cs:locals:get name)
			)
			((&& allowNew (! abs) (this:fs:cs:locals:containsKey (this:fs:package_:concat name)))
				(this:fs:cs:locals:get (this:fs:package_:concat name))
			)
			((this:fs:imports:containsKey name)
				(define fullName (this:fs:imports:get name))
				(if (&& allowNew (this:fs:cs:locals:containsKey fullName))
					(this:fs:cs:locals:get fullName)
					(if (this:fs:cs:classExists fullName)
						(Type:getType fullName)
						(throw (RuntimeException))
					)
				)
			)
			(true
				(define matches (ArrayList{Type}))
				(forEach starImport this:fs:starImports
					(define fullName (starImport:concat name))
					(if (&& allowNew (this:fs:cs:locals:containsKey fullName))
						(matches:add (this:fs:cs:locals:get fullName))
						(if (this:fs:cs:classExists fullName)
							(matches:add (Type:getType fullName))
						)
					)
				)
				(cond
					((= (matches:size) 1)
						(matches:get 0)
					)
					((> (matches:size) 1)
						(throw (RuntimeException (concat "Too many types match: " matches)))
					)
					((this:fs:cs:classExists name)
						(Type:getType name)
					)
					(true null)
				)
			)
		)
	)
	((getType tok Token allowNew bool) Type public
		(instanceCond tok
			(GenericToken
				(define c ClassType ((this:getType (as VToken tok:tok):val allowNew):getRawType))
				(define tparams
					(mapA param tok:toks
						(this:getType param allowNew)
					)
				)
				(ParameterizedType c tparams)
			)
			(ArrayToken
				(ArrayType (this:getType (tok:toks:get 0) allowNew))
			)
			(VToken
				(this:getType tok:val allowNew)
			)
			(true null)
		)
	)
	((getType tok Token) Type public
		(this:getType tok true)
	)
	((compileDef tok BlockToken) void public
		(if (instance? tok BlockToken)
			(begin
				(define first (tok:toks:get 0))
				(if (instance? first BlockToken) ;method definition
					(begin
						(define scope (LinkedHashMap))
						(define tup (Main:extractModifiers tok:toks 2))
						(define mods tup:_1)
						(define i tup:_2)
						(define n
							(if (= (& mods Access:STATIC) 0)
								1
								0
							)
						)
						(define exceptions ClassType[] null)
						(define annotations (ArrayList{AnnotationEntry}))
						(while
							(&&
								(!= i (tok:toks:size))
								(instance? (tok:toks:get i) SingleQuoteToken)
							)
							(begin
								(define toks (as BlockToken ((as SingleQuoteToken (tok:toks:get i)):toks:get 0)):toks)
								(define first VToken (toks:get 0))
								(if (first:val:equals "throws")
									(set exceptions
										(mapA tok (toks:subList 1 (toks:size))
											(as ClassType (this:getType tok))
										)
									)
									(annotations:add (AnnotationEntry (as ClassType (this:getType first))))
								)
								(inc i)
							)
						)
						(define types (Main:getParams this (as BlockToken first) scope 1 n))
						(define mi (this:addMethod (as VToken ((as BlockToken first):toks:get 0)):val types (this:getType (tok:toks:get 1)) mods (tok:toks:subList i (tok:toks:size)) scope))
						(if (!= exceptions null) (mi:method:setExceptions exceptions))
						(forEach annotation annotations
							(RuntimeAnnotationsAttr:maybeAddAnnotation mi:method annotation)
						)
					)
					(begin
						(define name (as VToken first):val)
						(if (! (name:endsWith "!"))
							(begin ;field definition
								(define tup (Main:extractModifiers tok:toks 2))
								(define mods tup:_1)
								(define i tup:_2)
								(define t (this:getType (tok:toks:get 1)))
								(this:c:addField name t mods)
							)
						)
					)
				)
			)
		)
	)
	((compileDefs) void
		(define c this:c)
		(forEach super this:supers:toks
			(define related Type (this:getType super))
			(if (related:isInterface)
				(c:addInterface related)
				(c:setSuper related)
			)
		)
		(forEach tok this:toks
			(this:compileDef (as BlockToken tok))
		)
	)
	((compileMethods) void public
		(forEach mi this:methods
			(mi:compileMethodBody (GenHandler mi))
		)
	)
	((runClassMacros) void
		(forEach tok this:toks
			(if
				(&&
					(instance? tok BlockToken)
					(instance? ((as BlockToken tok):toks:get 0) VToken)
					((as VToken ((as BlockToken tok):toks:get 0)):val:endsWith "!")
				)
				(this:runClassMacro (as BlockToken tok))
			)
		)
	)
	((runClassMacro tok BlockToken) void
		(define name (as VToken (tok:toks:get 0)):val)
		(set name (name:substring 0 (- (name:length) 1)))
		(define o 1)
		(define l (- (tok:toks:size) 1))
		(define types (Type[] len:(+ o l) (Main:getCompilerType "ClassInfo")))
		(for ((j 0)) (!= j l) (inc j)
			(aset types (+ o j) (Main:getCompilerType "tokens.LexedParsedToken"))
		)
		(define method Method null)
		(define ci ClassInfo null)
		(for ((i 0)) (= method null) (inc i)
			(set ci ((this:fs:cs:classMacroNames:get name):get i))
			(define filter (MFilter name types ci:c true))
			(filter:searchDeclared)
			(set method (filter:getMethod))
		)
		(ci:compileMethods)
		(define params (method:getGenericParameterTypes))
		(define classes (mapA t params (t:getReflectClass)))
		(define args (ArrayList (Arrays:asList (Object[] this))))
		(args:addAll
			(if (!= (& (method:getModifiers) Access:TRANSIENT) 0)
				(begin
					(define var (- (alen params) o))
					(define al (ArrayList (tok:toks:subList 1 var)))
					(define out (LexedParsedToken[] len:(- (tok:toks:size) var)))
					((tok:toks:subList var (tok:toks:size)):toArray out)
					(al:add out)
					al
				)
				(as ArrayList (tok:toks:subList 1 (tok:toks:size)))
			)
		)
		(try
			(((ci:getClazz):getMethod name classes):invoke null (args:toArray))
			(e NoSuchMethodException (throw (RuntimeException e)))
			(e IllegalAccessException (throw (RuntimeException e)))
			(e java.lang.reflect.InvocationTargetException (throw (RuntimeException e)))
		)
	)
	((addMethod name String params List{Type} ret Type mods int toks List{LexedParsedToken} scope LinkedHashMap addThis bool) AMethodInfo public
		(if (&& addThis (= (& mods Access:STATIC) 0))
			(scope:put "this" (Arg this:c 0 0))
		)
		(define out (MethodInfo this toks scope name params ret mods))
		(this:methods:add out)
		out
	)
	((addMethod name String params List{Type} ret Type mods int toks List{LexedParsedToken} scope LinkedHashMap) AMethodInfo public
		(this:addMethod name params ret mods toks scope true)
	)
	((addMethod name String ret Type mods int toks List{LexedParsedToken} scope LinkedHashMap{String Arg}) AMethodInfo public
		(define params (ArrayList{Type}))
		(forEach arg (scope:values)
			(params:add arg:type)
		)
		(this:addMethod name params ret mods toks scope)
	)
)

(define-class MacroInfo (ClassInfo) public
	((<init> fs FileScope name String) void
		(super:<init> fs name)
	)
	((getType tok Token) Type public
		(super:getType tok false)
	)
	((addClassMacroMethod name String params List{Type} ret Type mods int toks List{LexedParsedToken} scope LinkedHashMap) AMethodInfo public
		(define out (ClassMacroMethodInfo this toks scope name params ret mods))
		(this:methods:add out)
		out
	)
)

(define-class AMethodInfo () public abstract
	(ci ClassInfo public)
	(block BeginToken public)
	(method Method public)
	(levels ArrayList{ArrayDeque{Map{String AVar}}} public)
	(capturedLevels ArrayList{Map{String AVar}} public)
	(firstScope Map{String Arg})
	(labels ArrayDeque{Map{String Label}})
	(compiled bool)
	((<init> ci ClassInfo toks List{LexedParsedToken} firstScope LinkedHashMap{String Arg} method Method) void
		(super:<init>)
		(set this:ci ci)
		(when (&& (!= toks null) (!= (toks:size) 0))
			(set this:block (BeginToken (toks:get 0):line (ArrayList{Token} toks)))
		)
		(set this:method method)

		(set this:levels (ArrayList))
		(this:ensureLevels 0)
		(set this:capturedLevels (ArrayList))
		(forEach entry (firstScope:entrySet)
			(this:putVar (entry:getKey) (entry:getValue) (entry:getValue):level)
		)
		(set this:firstScope firstScope)
		(set this:labels (ArrayDeque))
		(set this:compiled false)
	)
	((<init> ci ClassInfo toks List{LexedParsedToken} firstScope LinkedHashMap{String Arg} name String params List{Type} ret Type mods int) void
		(this:<init>
			ci
			toks
			firstScope
			(if (!= toks null)
				(ci:c:addMethod name (params:toArray (Type[])) ret mods)
				null
			)
		)
	)
	((pushScope code CodeAttr label Map) void public
		(define output (!= code null))
		(forEach level this:levels
			(level:push (HashMap))
		)
		(this:labels:push label)
		;(if output (code:pushScope))
	)
	((popScope code CodeAttr) void public
		(define output (!= code null))
		(define it (this:levels:iterator))
		(while (it:hasNext)
			(define level (it:next))
			(if (= (level:size) 0)
				(it:remove)
				(level:pop)
			)
		)
		(this:labels:pop)
		;(if output (code:popScope))
	)
	((ensureLevels level int) void private
		(while (<= (this:levels:size) level)
			(define ad (ArrayDeque))
			(ad:push (LinkedHashMap))
			(this:levels:add ad)
		)
	)
	((putCapturedVar tok VToken v AVar) void public
		(while (<= (this:capturedLevels:size) tok:macro)
			(this:capturedLevels:add (LinkedHashMap))
		)
		((this:capturedLevels:get tok:macro):put tok:val v)
	)
	((getVar tok VToken) AVar public
		(if (< tok:macro (this:levels:size))
			(forEach scope (this:levels:get tok:macro)
				(if (scope:containsKey tok:val)
					(return (scope:get tok:val))
				)
			)
		)
		(if (< tok:macro (this:capturedLevels:size))
			((this:capturedLevels:get tok:macro):get tok:val)
			null
		)
	)
	((getLabel name String) Label public
		(forEach labelScope this:labels
			(if (labelScope:containsKey name)
				(return (labelScope:get name))
			)
		)
		null
	)
	((removeVar tok VToken) void public
		(forEach scope (this:levels:get tok:macro)
			(if (scope:containsKey tok:val)
				(begin
					(scope:remove tok:val)
					(return)
				)
			)
		)
	)
	((newVar code CodeAttr tok VToken type Type) Variable public
		(define output (!= code null))
		(define var (if output (code:addLocal (type:getRawType) tok:val) null))
		(this:putVar tok (Var var type))
		var
	)
	((putVar tok VToken v AVar) void public
		(this:putVar tok:val v tok:macro)
	)
	((putVar name String v AVar level int) void public
		(this:ensureLevels level)
		(((this:levels:get level):getFirst):put name v)
	)
	((getType tok Token) Type public
		(this:ci:getType tok)
	)
	((compileMethodBody h GenHandler) void public
		(when (&& (! this:compiled) (! (this:method:isAbstract)))
			(this:transformBlockToks this:block)
			(h:compile this:block null (this:method:getReturnType))

			(define filter (BridgeFilter this:method))
			(filter:searchAll)

			(define code (this:method:startCode))
			(forEach entry (this:firstScope:entrySet)
				(define arg (entry:getValue))
				((code:getArg arg:n):setName (entry:getKey))
			)
			(define ret (h:compile this:block code (this:method:getReturnType)))
			(code:popScope)

			(if (code:reachableHere)
				(code:emitReturn)
			)
			(set this:compiled true)
		)
	)
	((toString) String public
		(concat (super:toString) ":" this:method)
	)
	((transformBlockTok block BlockToken2 transform bool i int) Token public
		(define tok LexedParsedToken (block:toks:get i))
		(define ntok (this:transformBlock tok transform))
		(block:toks:set i ntok)
		(if (&& transform (instance? tok BlockToken) (> ((as BlockToken tok):toks:size) 0) (instance? ((as BlockToken tok):toks:get 0) VToken))
			(begin
				(define val (as VToken ((as BlockToken tok):toks:get 0)):val)
				(if (val:equals "label")
					(block:labels:put (as VToken ((as BlockToken tok):toks:get 1)):val (Label))
				)
			)
		)
		ntok
	)
	((transformBlockToks block BlockToken2 transform bool i int) BlockToken2 public
		(if (! block:isTransformed)
			(begin
				(while (!= i (block:toks:size))
					(this:transformBlockTok block transform i)
					(inc i)
				)
				(set block:isTransformed true)
			)
		)
		block
	)
	((transformBlockToks block BlockToken2 transform bool) BlockToken2 public
		(this:transformBlockToks block transform 0)
	)
	((transformBlockToks block BlockToken2) BlockToken2 public
		(this:transformBlockToks block true)
	)
	((transformToks l List{LexedParsedToken} transform bool) List{Token} public
		(define out (ArrayList{Token}))
		(forEach t l
			(out:add
				(this:transformBlock t
					(||
						transform
						(instance? t UnquoteToken)
					)
				)
			)
		)
		out
	)
	((transformToks l List{LexedParsedToken}) List{Token} public
		(this:transformToks l true)
	)
	((transformForm block BlockToken transform bool) Token public
		(define val (as VToken (block:toks:get 0)):val)
		(define rest (block:toks:subList 1 (block:toks:size)))
		(cond
			((val:equals "unquote")
				(return (this:transformBlock (UnquoteToken block:line (ArrayList rest) false)))
			)
			((val:equals "varunquote")
				(return (this:transformBlock (UnquoteToken block:line (ArrayList rest) true)))
			)
			((val:equals "include")
				(return (IncludeToken block:line (ArrayList rest)))
			)
		)
		(if transform
			(cond
				((val:equals "quote")
					(return (this:transformBlock (QuoteToken block:line (ArrayList rest))))
				)
				((val:equals "object")
					(define superTok BlockToken (rest:get 0))
					(return (ObjectToken block:line (this:getType (superTok:toks:get 0)) (superTok:toks:subList 1 (superTok:toks:size)) (rest:subList 1 (rest:size))))
				)
				((val:equals "lambda")
					(define scope (LinkedHashMap))
					(define FunctionN (instance? (rest:get 0) BlockToken))
					(if FunctionN
						(begin
							(define params (Main:getParams this:ci (as BlockToken (rest:get 0)) scope 0 1))
							(return (LambdaFnToken block:line null scope params (rest:subList 1 (rest:size))))
						)
						(begin
							(define t (this:getType (rest:get 0)))
							(define sam ((as ClassType (t:getRawType)):checkSingleAbstractMethod))
							(define args BlockToken (rest:get 1))
							(define params (ArrayList{Type} (args:toks:size)))
							(forEach (arg i) args:toks
								(define param (Main:resolveType t (aget (sam:getGenericParameterTypes) i)))
								(scope:put (as VToken arg):val (Arg param (+ i 1) 0))
								(params:add param)
							)
							(return (LambdaToken block:line (this:getType (rest:get 0)) scope params (rest:subList 2 (rest:size)) sam))
						)
					)
				)
				((this:ci:fs:cs:macroNames:containsKey val)
					(return (MacroIncludeToken block:line val (ArrayList rest)))
				)
				((val:equals "begin")
					(return (this:transformBlockToks (BeginToken block:line (ArrayList rest))))
				)
				((val:equals "sbegin")
					(return (this:transformBlockToks (SpecialBeginToken block:line (ArrayList rest))))
				)
				((val:equals "label")
					(return (LabelToken block:line (as VToken (block:toks:get 1)):val))
				)
				((val:equals "goto")
					(return (GotoToken block:line (as VToken (block:toks:get 1)):val))
				)
				((val:equals "define")
					(define type (this:getType (rest:get 1)))
					(define tok Token
						(cond
							((&& (= type null) (= (rest:size) 2))
								(this:transformBlock (rest:get 1))
							)
							((&& (!= type null) (= (rest:size) 3))
								(this:transformBlock (rest:get 2))
							)
							((&& (!= type null) (= (rest:size) 2))
								null
							)
							(true
								(throw (RuntimeException (block:toString)))
							)
						)
					)
					(define name (as VToken (rest:get 0)))
					(if (= type null) (set type Main:unknownType))
					(return (DefineToken block:line name type tok))
				)
				((val:equals "try")
					(define hasFinally
						(&&
							(!= (rest:size) 1)
							(instance? ((as BlockToken (rest:get (- (rest:size) 1))):toks:get 0) VToken)
							((as VToken ((as BlockToken (rest:get (- (rest:size) 1))):toks:get 0)):val:equals "finally")
						)
					)
					(define finallyToks List{Token} null)
					(if hasFinally
						(begin
							(define finallyToks (as BlockToken (rest:get (- (rest:size) 1))):toks)
							(set finallyToks (this:transformToks (finallyToks:subList 1 (finallyToks:size))))
							(set rest (rest:subList 0 (- (rest:size) 1)))
						)
					)
					(define catches
						(mapA catch (rest:subList 1 (rest:size))
							(define catch BlockToken catch)
							(Tuple3
								(as VToken (catch:toks:get 0))
								(this:getType (catch:toks:get 1))
								(this:transformToks (catch:toks:subList 2 (catch:toks:size)))
							)
						)
					)
					(return (TryToken block:line (this:transformBlock (rest:get 0)) (Arrays:asList catches) finallyToks))
				)
				((val:equals "instance?")
					(return (InstanceToken block:line (this:transformBlock (block:toks:get 1)) (this:getType (block:toks:get 2))))
				)
				((val:equals "set")
					(return (SetToken block:line (this:transformToks block:toks)))
				)
				((val:equals "aset")
					(define arrayN (- (rest:size) 2))
					(define array
						(if (= arrayN 1)
							(this:transformBlock (rest:get 0))
							(AGetToken block:line (this:transformToks (rest:subList 0 arrayN)))
						)
					)
					(return (ASetToken block:line array (this:transformBlock (rest:get arrayN)) (this:transformBlock (rest:get (+ arrayN 1)))))
				)
				((val:equals "aget")
					(return (AGetToken block:line (this:transformToks rest)))
				)
				((val:equals "alen")
					(return (ALenToken block:line (this:transformBlock (block:toks:get 1))))
				)
				((val:equals "as")
					(return (AsToken block:line (this:getType (block:toks:get 1)) (this:transformBlock (block:toks:get 2))))
				)
				((Main:binOps:containsKey val)
					(return (NumOpToken block:line val (this:transformToks rest)))
				)
				((|| (val:equals ">>") (val:equals "<<"))
					(return (ShiftToken block:line (this:transformBlock (rest:get 0)) (this:transformBlock (rest:get 1)) (val:equals ">>")))
				)
				((val:equals "if")
					(return (IfToken block:line (this:transformToks block:toks)))
				)
				((Main:isCompare val)
					(return (CompareToken block:line val (this:transformToks rest)))
				)
				((val:equals "throw")
					(return (ThrowToken block:line (this:transformBlock (block:toks:get 1))))
				)
				((val:equals "class")
					(return (ClassToken block:line (this:getType (block:toks:get 1))))
				)
				((val:equals "synchronized")
					(return (this:transformBlockToks (SynchronizedToken block:line (ArrayList block:toks))))
				)
				((val:equals "type")
					(return (TypeToken block:line (this:transformBlock (block:toks:get 1))))
				)
				((val:equals "return")
					(define tok (if (= (block:toks:size) 1) null (this:transformBlock (block:toks:get 1))))
					(return (ReturnToken block:line tok))
				)
				((val:equals "macro")
					(define l
						(Arrays:asList
							(mapA (tok i) rest
								(if (= i 0)
									tok
									(UnquoteToken tok:line (Arrays:asList (LexedParsedToken[] tok)) false)
								)
							)
						)
					)
					(return (QuoteToken2 block:line (BlockToken block:line l)))
				)
			)
		)
		null
	)
	((transformBlock_ block LexedParsedToken transform bool) Token
		(instanceCond block
			(BlockToken
				(cond
					((= (block:toks:size) 0)
						(if transform
							(return (EmptyToken block:line))
							(return (BlockToken block:line Collections:EMPTY_LIST))
						)
					)
					(true
						(define rest (block:toks:subList 1 (block:toks:size)))
						(define type (if transform (this:getType (block:toks:get 0)) null))
						(if (!= type null)
							(if (instance? type ArrayType)
								(begin
									(define len Token null)
									(if
										(&&
											(!= (rest:size) 0)
											(instance? (rest:get 0) ColonToken)
											(instance? (as ColonToken (rest:get 0)):left VToken)
											((as VToken (as ColonToken (rest:get 0)):left):val:equals "len")
										)
										(begin
											(set len (this:transformBlock (as ColonToken (rest:get 0)):right))
											(set rest (rest:subList 1 (rest:size)))
										)
										(begin
											(define tok ArrayToken (block:toks:get 0))
											(while (instance? (tok:toks:get 0) ArrayToken)
												(set tok (tok:toks:get 0))
											)
											(if (> (tok:toks:size) 1)
												(set len (this:transformBlock (tok:toks:get 1)))
											)
										)
									)
									(return (ArrayConstructorToken block:line type len (this:transformToks rest)))
								)
								(return (ConstructorToken block:line type (this:transformToks rest)))
							)
						)
						(cond
							((instance? (block:toks:get 0) VToken)
								(define o (this:transformForm block transform))
								(if (!= o null) (return o))
							)
							((&& transform (instance? (block:toks:get 0) ColonToken))
								(define first ColonToken (block:toks:get 0))
								(define out
									(CallToken
										block:line
										(this:transformBlock first:left true)
										(as VToken first:right):val
										(this:transformToks (block:toks:subList 1 (block:toks:size)))
									)
								)
								(return out)
							)
						)
						(if transform
							(return (DefaultToken block:line (this:transformToks block:toks)))
							(return (BlockToken block:line (Main:toLexedParsed (this:transformToks block:toks false))))
						)
					)
				)
			)
			(ColonToken
				(if transform
					(return
						(FieldToken block:line
							(this:transformBlock block:left)
							(as VToken block:right):val
						)
					)
					(return (ColonToken block:line (as LexedParsedToken (this:transformBlock block:left transform)) (as LexedParsedToken (this:transformBlock block:right transform))))
				)
			)
			(QuoteToken
				(if transform
					(return
						(QuoteToken2 block:line
							(this:transformBlock
								(block:toks:get 0)
								(instance? (block:toks:get 0) UnquoteToken)
							)
						)
					)
					(return (QuoteToken block:line (Main:toLexedParsed (this:transformToks block:toks false))))
				)
			)
			(UnquoteToken
				(return (UnquoteToken block:line (ArrayList block:toks) block:var))
			)
			(GenericToken
				(if transform
					(throw (RuntimeException))
					(return (GenericToken block:line (as LexedParsedToken (this:transformBlock block:tok transform)) (Main:toLexedParsed (this:transformToks block:toks transform))))
				)
			)
			(ArrayToken
				(if transform
					(throw (RuntimeException))
					(return (ArrayToken block:line (Main:toLexedParsed (this:transformToks block:toks transform))))
				)
			)
		)
		block
	)
	((transformBlock block LexedParsedToken transform bool) Token public
		(if (!= block:transformed null)
			block:transformed
			(begin
				(define out (this:transformBlock_ block transform))
				(set block:transformed out)
				out
			)
		)
	)
	((transformBlock block LexedParsedToken) Token public
		(this:transformBlock block true)
	)
)

(define-class MethodInfo (AMethodInfo) public
	((<init> ci ClassInfo toks List{LexedParsedToken} firstScope LinkedHashMap{String Arg} method Method) void public
		(super:<init> ci toks firstScope method)
	)
	((<init> ci ClassInfo toks List{LexedParsedToken} firstScope LinkedHashMap{String Arg} name String params List{Type} ret Type mods int) void
		(super:<init> ci toks firstScope name params ret mods)
	)
)

(define-class ClassMacroMethodInfo (AMethodInfo) public
	((<init> ci ClassInfo toks List{LexedParsedToken} firstScope LinkedHashMap{String Arg} name String params List{Type} ret Type mods int) void
		(super:<init> ci toks firstScope name params ret mods)
	)
)
