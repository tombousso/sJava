(import java.util.*)
(import java.nio.file.*)
(import gnu.bytecode.*)

(define-class Main () 'public
	(ML int 'static) ;max length of a special token
	(MP int 'static) ;max precedence
	(precs String[][]  'static) ;precedence to special token array
	(s2prec HashMap{String Integer} 'static) ;special token to precedence
	(specialChars HashMap{String Character} 'static)
	(unboxMethods HashMap{Type Method} 'static)
	(constTypes HashMap{String Type} 'static)
	(accessModifiers HashMap{String Short} 'static)
	(binOps HashMap{String Integer} 'static)
	(compare2Ops HashMap{String Integer} 'static)
	(compare1Ops HashMap{String Integer} 'static)
	(compareOpposites HashMap{Integer Integer} 'static)
	(unknownType Type 'static)
	(args String[] 'static)
	((main args String[]) void 'public 'static
		(set Main:args args)
		(set Main:unknownType null)

		(set Main:unboxMethods (HashMap{Type Method}))
		(Main:unboxMethods:put (Type:shortType:boxedType) (Type:javalangNumberType:getDeclaredMethod "shortValue" 0))
		(Main:unboxMethods:put (Type:intType:boxedType) (Type:javalangNumberType:getDeclaredMethod "intValue" 0))
		(Main:unboxMethods:put (Type:longType:boxedType) (Type:javalangNumberType:getDeclaredMethod "longValue" 0))
		(Main:unboxMethods:put (Type:doubleType:boxedType) (Type:javalangNumberType:getDeclaredMethod "doubleValue" 0))
		(Main:unboxMethods:put (Type:booleanType:boxedType) (Type:javalangBooleanType:getDeclaredMethod "booleanValue" 0))
		(Main:unboxMethods:put (Type:charType:boxedType) (Type:javalangCharacterType:getDeclaredMethod "charValue" 0))

		(set Main:constTypes (HashMap{String Type}))
		(Main:constTypes:put "bool" Type:booleanType)
		(Main:constTypes:put "byte" Type:byteType)
		(Main:constTypes:put "char" Type:charType)
		(Main:constTypes:put "double" Type:doubleType)
		(Main:constTypes:put "float" Type:floatType)
		(Main:constTypes:put "int" Type:intType)
		(Main:constTypes:put "long" Type:longType)
		(Main:constTypes:put "short" Type:shortType)
		(Main:constTypes:put "void" Type:voidType)

		(set Main:accessModifiers (HashMap{String Short}))
		(Main:accessModifiers:put "static" Access:STATIC)
		(Main:accessModifiers:put "public" Access:PUBLIC)
		(Main:accessModifiers:put "abstract" Access:ABSTRACT)
		(Main:accessModifiers:put "final" Access:FINAL)
		(Main:accessModifiers:put "private" Access:PRIVATE)
		(Main:accessModifiers:put "protected" Access:PROTECTED)
		(Main:accessModifiers:put "synchronized" Access:SYNCHRONIZED)
		(Main:accessModifiers:put "transient" Access:TRANSIENT)
		(Main:accessModifiers:put "volatile" Access:VOLATILE)
		(Main:accessModifiers:put "native" Access:NATIVE)
		(Main:accessModifiers:put "interface" Access:INTERFACE)
		(Main:accessModifiers:put "super" Access:SUPER)

		(set Main:binOps (HashMap{String Integer}))
		(Main:binOps:put "+" 96)
		(Main:binOps:put "-" 100)
		(Main:binOps:put "*" 104)
		(Main:binOps:put "/" 108)
		(Main:binOps:put "%" 112)
		(Main:binOps:put "&" 126)
		(Main:binOps:put "|" 128)
		(Main:binOps:put "^" 130)

		(set Main:compare2Ops (HashMap{String Integer}))
		;opposites
		(Main:compare2Ops:put "!=" 153)
		(Main:compare2Ops:put "=" 154)
		(Main:compare2Ops:put ">=" 155)
		(Main:compare2Ops:put "<" 156)
		(Main:compare2Ops:put "<=" 157)
		(Main:compare2Ops:put ">" 158)

		(set Main:compare1Ops (HashMap{String Integer}))
		;opposites
		(Main:compare1Ops:put "!=0" 153)
		(Main:compare1Ops:put "==0" 154)
		(Main:compare1Ops:put ">=0" 155)
		(Main:compare1Ops:put "<0" 156)
		(Main:compare1Ops:put "<=0" 157)
		(Main:compare1Ops:put ">0" 158)
		(Main:compare1Ops:put "!=null" 198)
		(Main:compare1Ops:put "==null" 199)

		(set Main:compareOpposites (HashMap{Integer Integer}))
		(Main:compareOpposites:put 153 154)
		(Main:compareOpposites:put 154 153)
		(Main:compareOpposites:put 155 156)
		(Main:compareOpposites:put 156 155)
		(Main:compareOpposites:put 157 158)
		(Main:compareOpposites:put 158 157)
		(Main:compareOpposites:put 198 199)
		(Main:compareOpposites:put 199 198)
		
		(set Main:precs (String[][]
			(String[] ":" "'")
			(String[] "(" ")" "{" "}")
			(String[] "\n" "\r\n")
			(String[] ";")
		))

		(set Main:specialChars (HashMap{String Character}))
		(Main:specialChars:put "space" #\space)
		(Main:specialChars:put "\\" #\\)

		(set Main:MP (- (alen Main:precs) 1))

		(set Main:ML 2)

		(set Main:s2prec (HashMap{String Integer}))

		(define i 0)

		(while (!= i (alen Main:precs))
			(define a (aget Main:precs i))
			(define j 0)
			(while (!= j (alen a))
				(Main:s2prec:put (aget a j) i)
				(set j (+ j 1))
			)
			(set i (+ i 1))
		)
		(define s (String (Files:readAllBytes (Paths:get (aget args 0) (String[])))))
		(define toks ((Lexer s):lex))
		((Parser toks):parse 0 (toks:size) Main:MP 0)
		;((System:console):readLine)
		((Compiler):compile toks (HashMap))
		;((System:console):readLine)
	)
	((resolveParam pt Type t Type) Type 'static 'public
		(if (&& (instance? t TypeVariable) (instance? pt ParameterizedType))
			(begin
				(define tvs ((as ClassType ((as ParameterizedType pt):getRawType)):getTypeParameters))
				(define s String ((as TypeVariable t):getName))
				(define end false)
				(define ret Type null)
				(define i 0)
				(while (! (|| end (= i (alen tvs))))
					(if (((aget tvs i):getName):equals s)
						(begin
							(set ret ((as ParameterizedType pt):getTypeArgumentType i))
							(set end true)
						)
					)
					(set i (+ i 1))
				)
				ret
			)
			(t:getRawType)
		)
	)
)

(define-class Token ()
	(what String)
	(val Object)
	(ops List{Token})
	(prec int)
	(line int)
	((<init> line0 int what0 String val0 Object) void
		(Object:<super>)
		(set this:what what0)
		(set this:val val0)
		(set this:line line0)
	)
	((<init> line0 int what0 String val0 Object prec0 int) void
		(Token:<super> line0 what0 val0)
		(set this:prec prec0)
	)
	((<init> line0 int what0 String val0 Object prec0 int ops0 List{Token}) void
		(Token:<super> line0 what0 val0 prec0)
		(set this:ops ops0)
	)
	;((repr) String 'public
	;	(((Integer:toString this:prec):concat
	;		"-"):concat
	;		(if (= this:val null)
	;			this:what
	;			((this:what:concat ":"):concat (this:val:toString))
	;		)
	;	)
	;)
	;((toString) String
	;	(define sops "")
	;	(if (!= this:ops null)
	;		(begin
	;			(set sops (sops:concat " { "))
	;			(define i 0)
	;			(while (!= i (this:ops:size))
	;				(set sops ((sops:concat ((this:ops:get i):toString)):concat " "))
	;				(set i (+ i 1))
	;			)
	;			(set sops (sops:concat "} "))
	;		)
	;	)
	;	((org.apache.commons.lang3.StringEscapeUtils:escapeJava (this:repr)):concat sops)
	;)
)

(define-class Lexer ()
	(code String)
	(i int)
	(ml int)
	(s String)
	(line int)
	((<init> code0 String) void
		(Object:<super>)
		(set this:code code0)
		(set this:ml (code0:length))
		(set this:line 1)
	)
	((getprec) int
		;check if code at i is a special token
		(define ii this:i)
		(define p -1)
		(define l Main:ML)
		(while (! (|| (>= p 0) (= l 0)))
			(if (<= (+ ii l) this:ml)
				(begin
					(set this:s (this:code:substring ii (+ ii l)))
					(if (Main:s2prec:containsKey this:s)
						(set p (Main:s2prec:get this:s))
					)
				)
			)
			(set l (- l 1))
		)
		p
	)
	((nextTok) void
		(while (! (|| (= this:i this:ml) (= (this:code:charAt this:i) #\space) (>= (this:getprec) 0)))
			(set this:i (+ this:i 1))
		)
	)
	((token) Token
		(while (! (|| (! (Character:isWhitespace (this:code:charAt this:i))) (>= (this:getprec) 0)))
			(set this:i (+ this:i 1))
		)
		(define p (this:getprec))
		(if (< p 0)
			(begin
				(define oi this:i)
				(define c (this:code:charAt this:i))
				(if (= c #\")
					(begin
						(set this:i (+ this:i 1))
						(define esc false)
						(while (! (&& (! esc) (= (this:code:charAt this:i) #\")))
							(set esc (&& (! esc) (= (this:code:charAt this:i) #\\)))
							(set this:i (+ this:i 1))
						)
						(set this:i (+ this:i 1))
						(Token this:line "S" (org.apache.commons.lang3.StringEscapeUtils:unescapeJava (this:code:substring (+ oi 1) (- this:i 1))))
					)
				(if (= c #\#)
					(begin
						(set this:i (+ this:i 2))
						(this:nextTok)
						(define schar (this:code:substring (+ oi 2) this:i))
						(Token this:line "C"
							(if (= (schar:length) 1)
								(schar:charAt 0)
								(Main:specialChars:get schar)
							)
						)
					)
				(if (|| (Character:isDigit c) (= c #\-))
					(begin
						(this:nextTok)
						(Token this:line "N" (this:code:substring oi this:i))
					)
					(begin
						(this:nextTok)
						(Token this:line "V" (this:code:substring oi this:i))
					)
				)
				)
				)
			)
			(begin
				(set this:i (+ this:i (this:s:length)))
				(if (this:s:contains "\n")
					(set this:line (+ this:line 1))
				)
				(Token this:line this:s null p)
			)
		)
	)
	((lex) ArrayList
		(set this:i 0)
		(define out (ArrayList))
		(while
			(!= this:i this:ml)
			(out:add (this:token))
		)
		out
	)
)

(define-class Parser ()
	(toks ArrayList{Token})
	((<init> toks0 ArrayList{Token}) void
		(Object:<super>)
		(set this:toks toks0)
	)
	;these methods return the number of tokens which they shifted down
	((block i int e int o String c String) int
		(define oi i)
		(define oe e)
		(define end false)
		(set i (+ i 1))
		(while (! end)
			(define t (this:toks:get i))
			(define w t:what)
			(if (w:equals o)
				(set e (- e (this:block i e o c)))
			)
			(if (w:equals c)
				(begin
					(define d (this:parse (+ oi 1) i Main:MP 0))
					(set i (- i d))
					(set e (- e d))
					(define n (- i oi))
					;(if (> n 2)
						(this:toks:set oi (Token (this:toks:get oi):line o null -1 (ArrayList (this:toks:subList (+ oi 1) i))))
						;(set! (toks oi) (toks (+ oi 1)))
					;)
					(this:shiftDown (+ oi 1) n)
					(set e (- e n))
					(set end true)
				)
			)
			(set i (+ i 1))
		)
		(- oe e)
	)
	((comment i int e int) int
		(define oi i)
		(define oe e)
		(define end false)
		(set i (+ i 1))
		(while (! end)
			(if (|| (= i (this:toks:size)) ((this:toks:get i):what:contains "\n"))
				(begin
					(define n (- i oi))
					(this:shiftDown oi n)
					(set e (- e n))
					(set end true)
				)
			)
			(set i (+ i 1))
		)
		(- oe e)
	)
	((parse i int e int p int mp int) int
		;parse from i to e starting at p to mp (minimum precedence)
		;(println i e p mp (toks:get i) (toks:get (- e 1)))
		(define oi i)
		(define oe e)
		(define end false)
		(while (! (|| end (= i e)))
			(define t (this:toks:get i))
			(define w t:what)
			(if (= t:prec p)
				(begin
					(if (w:equals "(")
						(set e (- e (this:block i e "(" ")")))
					)
					(if (w:equals "{")
						(begin
							(set e (- e (this:block i e "{" "}")))
							(this:toks:set (- i 1) (Token t:line "generic" "" -1 (ArrayList (Arrays:asList (Object[] (this:toks:get (- i 1)) (this:toks:get i))))))
							(this:shiftDown i 1)
							(set e (- e 1))
							(set i (- i 1))
						)
					)
					(if (w:equals ";")
						(begin
							(set e (- e (this:comment i e)))
							(set i (- i 1))
						)
					)
					(if (w:equals ":")
						(begin
							(this:toks:set (- i 1) (Token t:line w "" -1 (ArrayList (Arrays:asList (Object[] (this:toks:get (- i 1)) (this:toks:get (+ i 1)))))))
							(this:shiftDown i 2)
							(set e (- e 2))
							(set i (- i 1))
						)
					)
					(if (w:equals "'")
						(begin
							(this:toks:set i (Token t:line w "" -1 (ArrayList (Arrays:asList (Object[] (this:toks:get (+ i 1)))))))
							(this:shiftDown (+ i 1) 1)
							(set e (- e 1))
						)
					)
					(if (Character:isWhitespace (w:charAt 0))
						(begin
							(this:shiftDown i 1)
							(set e (- e 1))
							(set i (- i 1))
						)
					)
				)
			)
			(set i (+ i 1))
		)
		(if (> p mp)
			(set e (- e (this:parse oi e (- p 1) mp)))
		)
		(- oe e)
	)
	((shiftDown i int n int) void
		;shift down n elements at i
		(define l (this:toks:size))
		(define nl (- l n))
		(while (!= i nl)
			(this:toks:set i (this:toks:get (+ i n)))
			(set i (+ i 1))
		)
		((this:toks:subList (- l n) l):clear)
	)
)

(define-class AVar ()
	(type Type)
	((<init> type Type) void (Object:<super>) (set this:type type))
	((load code CodeAttr) void ())
	((store code CodeAttr) void ())
)

(define-class Var (AVar)
	(var Variable)
	((<init> var0 Variable type0 Type) void (AVar:<super> type0) (set this:var var0))
	((load code CodeAttr) void
		(code:emitLoad this:var)
	)
	((store code CodeAttr) void
		(code:emitStore this:var)
	)
)

(define-class Arg (AVar)
	(n int)
	((<init> n0 int type0 Type) void (AVar:<super> type0) (set this:n n0))
	((load code CodeAttr) void
		(code:emitLoad (code:getArg this:n))
	)
	((store code CodeAttr) void
		(code:emitStore (code:getArg this:n))
	)
)

(define-class Emitter () 'interface
	((emit compiler Compiler classes Classes c ClassType m Method code CodeAttr scopes ArrayDeque needed Type labels HashMap) Type 'public 'abstract)
)

(define-class TokensEmitter (Emitter)
	(toks List{Token})
	(i int)
	(l int)
	((<init> toks0 List{Token} i0 int l0 int) void
		(Object:<super>)
		(set this:toks toks0)
		(set this:i i0)
		(set this:l l0)
	)
	((emit compiler Compiler classes Classes c ClassType m Method code CodeAttr scopes ArrayDeque needed Type labels HashMap) Type 'public
		(define type Type:voidType)
		(define j this:i)
		(while (!= j this:l)
			(set type (compiler:compile_ classes (this:toks:get j) c m code scopes needed labels))
			(set j (+ j 1))
		)
		type
	)
)

(define-class TokenEmitter (Emitter)
	(tok Token)
	((<init> tok0 Token) void
		(Object:<super>)
		(set this:tok tok0)
	)
	((emit compiler Compiler classes Classes c ClassType m Method code CodeAttr scopes ArrayDeque needed Type labels HashMap) Type 'public
		(compiler:compile_ classes this:tok c m code scopes needed labels)
	)
)

(define-class Goto (Emitter)
	(label Label)
	((<init> label0 Label) void (Object:<super>) (set this:label label0))
	((emit compiler Compiler classes Classes c ClassType m Method code CodeAttr scopes ArrayDeque needed Type labels HashMap) Type 'public (if (! (= code null)) (code:emitGoto this:label)) Type:voidType)
)

(define-class Emitters (Emitter)
	(emitters Emitter[])
	((<init> emitters0 Emitter[]) void (Object:<super>) (set this:emitters emitters0))
	((emit compiler Compiler classes Classes c ClassType m Method code CodeAttr scopes ArrayDeque needed Type labels HashMap) Type 'public
		(define type Type Type:voidType)
		(define i 0)
		(while (< i (alen this:emitters))
			(set type ((aget this:emitters i):emit compiler classes c m code scopes needed labels))
			(set i (+ i 1))
		)
		type
	)
)

(define-class MethodInfo ()
	(method Method)
	(scope HashMap)
	((<init> method0 Method scope0 HashMap) void
		(Object:<super>)
		(set this:method method0)
		(set this:scope scope0)
	)
)

(define-class ClassInfo ()
	(type ClassType)
	(n int)
	((<init> type0 ClassType n0 int) void
		(Object:<super>)
		(set this:type type0)
		(set this:n n0)
	)
)

(define-class Classes ()
	(locals HashMap)
	(imports HashMap)
	(starImports ArrayList)
	(found HashMap{String Boolean})
	((<init> locals0 HashMap) void
		(Object:<super>)
		(set this:locals locals0)
		(set this:imports (HashMap))
		(set this:starImports (ArrayList))
		(this:starImports:add "java.lang.")
		(set this:found (HashMap{String Boolean}))
	)
	((classExists name String) bool
		(if (this:found:containsKey name)
			(this:found:get name)
			(begin
				(define b 
					(try
						(begin
							(java.lang.Class:forName name)
							true
						)
						false
					)
				)
				(this:found:put name b)
				b
			)
		)
	)
	((get name String) Type
		(define i 0)
		(define dims -1)
		(while (!= i -1)
			(set i (name:indexOf "[]" (+ i 1)))
			(set dims (+ dims 1))
		)
		(set name (name:replace "[" ""))
		(set name (name:replace "]" ""))
		(define type Type
			(if (Main:constTypes:containsKey name)
				(Main:constTypes:get name)
			(if (this:locals:containsKey name)
				(this:locals:get name)
			(if (this:imports:containsKey name)
				(this:imports:get name)
			(if (this:classExists name)
				(Type:getType name)
			(begin
				(define type Type null)
				(define i 0)
				(while (! (|| (! (= type null)) (= i (this:starImports:size))))
					(if (this:classExists ((as String (this:starImports:get i)):concat name))
						(set type (Type:getType ((as String (this:starImports:get i)):concat name)))
					)
					(set i (+ i 1))
				)
				type
			)
			)
			)
			)
			)
		)
		(set i 0)
		(while (!= i dims)
			(set type (ArrayType type))
			(set i (+ i 1))
		)
		type
	)
	((get tok Token) Type
		(if (tok:what:equals "generic")
			(begin
				(define c ClassType (this:get (as String (tok:ops:get 0):val)))
				(define params (tok:ops:get 1))
				(define tparams (Type[] len:(params:ops:size)))
				(define i 0)
				(while (!= i (params:ops:size))
					(aset tparams i (this:get (as String (params:ops:get i):val)))
					(set i (+ i 1))
				)
				(ParameterizedType c tparams)
			)
			(this:get (as String tok:val))
		)
	)
)

(define-class MFilter (Filter)
	(methods0 ArrayList{Method})
	(methods1 ArrayList{Method})
	(name String)
	(types Type[])
	(pt Type)
	((<init> name0 String types0 Type[] pt0 Type) void
		(Object:<super>)
		(set this:methods0 (ArrayList{Method}))
		(set this:methods1 (ArrayList{Method}))
		(set this:name name0)
		(set this:types types0)
		(set this:pt pt0)
	)
	((select v Object) bool 'public
		(define method Method v)
		(if ((method:getName):equals this:name)
			(if (= (alen (method:getParameterTypes)) (alen this:types))
				(begin
					(define stop false)
					(define minLevel 1)
					(define i 0)
					(while (! (|| stop (= i (alen this:types))))
						(define level ((Main:resolveParam this:pt (aget (method:getParameterTypes) i)):compare (aget this:types i)))
						(if (< level minLevel)
							(set minLevel level)
						)
						(if (< level 0)
							(set stop true)
						)
						(set i (+ i 1))
					)
					(if (! stop)
						(if (= minLevel 1)
							(this:methods1:add method)
							(this:methods0:add method)
						)
					)
				)
			)
		)
		false
	)
)

(define-class Compiler ()
	((<init>) void (Object:<super>))
	((isCompare s String) bool
		(|| (s:equals "!") (s:equals "&&") (s:equals "||") (Main:compare1Ops:containsKey s) (Main:compare2Ops:containsKey s))
	)
	((compile_types classes Classes newClasses ArrayList tok Token) void
		(if (&& (tok:what:equals "(") (> (tok:ops:size) 0))
			(begin
				(define first (tok:ops:get 0))
				(if (first:val:equals "define-class")
					(begin
						(define name String (tok:ops:get 1):val)
						(define c (ClassType name))
						(define supers (tok:ops:get 2):ops)
						(c:setSuper "java.lang.Object")
						(define i 0)
						(while (! (= i (supers:size)))
							(define related ClassType (classes:get (supers:get i)))
							(if (related:isInterface)
								(c:addInterface related)
								(c:setSuper related)
							)
							(set i (+ i 1))
						)
						(newClasses:add c)
						(classes:locals:put name c)
						(set i 3)
						(while (!= i (tok:ops:size))
							(this:compile_method_mods (tok:ops:get i) c)
							(set i (+ i 1))
						)
						(set tok:val c)
					)
				(if (first:val:equals "import")
					(begin
						(define import String (tok:ops:get 1):val)
						(if (import:contains "*")
							(classes:starImports:add (import:replace "*" ""))
							(classes:imports:put (import:substring (+ (import:lastIndexOf ".") 1)) (Type:getType import))
						)
					)
				)
				)
			)
		)
	)
	((compile_method_mods tok Token c ClassType) void
		(if (tok:what:equals "'")
			(begin
				(define nmod int (Main:accessModifiers:get (tok:ops:get 0):val))
				(c:setModifiers nmod)
			)
		)
	)
	((compile_method_defs classes Classes tok Token) void
		(if (&& (tok:what:equals "(") (> (tok:ops:size) 0))
			(begin
				(define first (tok:ops:get 0))
				(if (first:val:equals "define-class")
					(begin
						(define i 3)
						(while (!= i (tok:ops:size))
							(this:compile_method_def classes (tok:ops:get i) (as ClassType tok:val))
							(set i (+ i 1))
						)
						null
					)
				)
			)
		)
	)
	((compile_method_def classes Classes tok Token c ClassType) void
		(if (&& (tok:what:equals "(") (> (tok:ops:size) 0))
			(begin
				(define first (tok:ops:get 0))
				(if (first:what:equals "(") ;method definition
					(begin
						(define scope (HashMap))
						(define mods 0)
						(define end false)
						(define i 2)
						(while (! (|| end (= i (tok:ops:size))))
							(define mod (tok:ops:get i))
							(if (mod:what:equals "'")
								(set mods (| mods (Main:accessModifiers:get (mod:ops:get 0):val)))
								(set end true)
							)
							(set i (+ i 1))
						)
						(define n 0)
						(if (= (& mods Access:STATIC) 0)
							(begin
								(scope:put "this" (Arg 0 c))
								(set n 1)
							)
						)
						(define l (first:ops:size))
						(define types (Type[] len: (/ (- l 1) 2)))
						(set i 0)
						(while (!= i (alen types))
							(define type (classes:get (first:ops:get (+ (* i 2) 2))))
							(aset types i type)
							(scope:put (as String (first:ops:get (+ (* i 2) 1)):val) (Arg (+ n i) type))
							(set i (+ i 1))
						)
						(define m Method (c:addMethod (as String (first:ops:get 0):val) types (classes:get (tok:ops:get 1)) mods))
						(set tok:val (MethodInfo m scope))
					)
					(begin ;field definition
						(define mods 0)
						(define end false)
						(define i 2)
						(while (! (| (= i (tok:ops:size)) end))
							(define mod (tok:ops:get i))
							(if (mod:what:equals "'")
								(begin
									(define nmod (Main:accessModifiers:get (mod:ops:get 0):val))
									(set mods (| mods nmod))
								)
								(set end true)
							)
							(set i (+ i 1))
						)
						(c:addField (as String first:val) (classes:get (tok:ops:get 1)) mods)
					)
				)
			)
		)
	)
	((getVar scopes ArrayDeque name String) AVar
		(define found AVar null)
		(define it Iterator (scopes:iterator))
		(while (= found null)
			(define vars HashMap (it:next))
			(if (vars:containsKey name)
				(set found (vars:get name))
			)
		)
		found
	)
	((invertComp inv bool n int) int
		(if inv
			(Main:compareOpposites:get n)
			n
		)
	)
	((compile_root classes Classes tok Token) void
		(if (&& (tok:what:equals "(") (> (tok:ops:size) 0))
			(begin
				(define first (tok:ops:get 0))
				(if (first:val:equals "define-class")
					(this:compile_class classes tok)
				)
			)
		)
	)
	((compile_class classes Classes tok Token) void
		(define i 3)
		(while (!= i (tok:ops:size))
			(this:compile_method classes (tok:ops:get i) (as ClassType tok:val))
			(set i (+ i 1))
		)
	)
	((compile_method classes Classes tok Token c ClassType) void ()
		(if (instance? tok:val MethodInfo)
			(begin ;method definition
				(define mi MethodInfo tok:val)
				(if (! (mi:method:isAbstract))
					(begin
						(define code (mi:method:startCode))
						(define scopes (ArrayDeque))
						(code:pushScope)
						(scopes:push mi:scope)
						(this:compile_al classes tok:ops 2 (- (tok:ops:size) 1) c mi:method null scopes Type:voidType (HashMap))
						(this:compile_ classes (tok:ops:get (- (tok:ops:size) 1)) c mi:method null scopes (mi:method:getReturnType) (HashMap))
						(this:compile_al classes tok:ops 2 (- (tok:ops:size) 1) c mi:method code scopes Type:voidType (HashMap))
						(this:compile_ classes (tok:ops:get (- (tok:ops:size) 1)) c mi:method code scopes (mi:method:getReturnType) (HashMap))
						(code:popScope)
						(code:emitReturn)
					)
				)
			)
		)
	)
	((compile_al classes Classes toks List{Token} i int e int c ClassType m Method code CodeAttr scopes ArrayDeque needed Object labels HashMap) Type[]
		(define l (toks:size))
		(define types (Type[] len: (- e i)))
		(define j i)
		(while (! (>= j e))
			(aset types (- j i)
				(this:compile_ classes (toks:get j) c m code scopes
					(if (= needed null)
						null
						(if (instance? needed Type[])
							(aget (as Type[] needed) (- j i))
							needed
						)
					)
					labels
				)
			)
			(set j (+ j 1))
		)
		types
	)
	((emitInvoke name String type Type classes Classes tok Token c ClassType m Method code CodeAttr scopes ArrayDeque needed Type labels HashMap) Type
		(define output (!= code null))
		(define types (this:compile_al classes tok:ops 1 (tok:ops:size) c m null scopes Main:unknownType labels))
		(if (name:equals "<super>") (begin (if output (code:emitPushThis)) (set name "<init>")))
		(define filter (MFilter name types type))
		((as ObjectType (type:getRawType)):getMethods filter 2 null)
		(define method Method
			(if (> (filter:methods0:size) 0)
				(filter:methods0:get 0)
				(filter:methods1:get 0)
			)
		)
		(define params Type[] ((method:getParameterTypes):clone))
		(define i 0)
		(while (!= i (alen params))
			(aset params i (Main:resolveParam type (aget params i)))
			(set i (+ i 1))
		)
		(this:compile_al classes tok:ops 1 (tok:ops:size) c m code scopes params labels)
		(if output (code:emitInvoke method))
		(define out (Main:resolveParam type (method:getReturnType)))
		(if (! (Type:isSame out ((method:getReturnType):getRawType)))
			(if output (code:emitCheckcast (out:getRawType)))
		)
		out
	)
	;tok = condition
	((emitIf_ classes Classes inv bool tok Token i int compare String trueE Emitter falseE Emitter c ClassType m Method code CodeAttr scopes ArrayDeque needed Type labels HashMap) Type
		(define output (!= code null))
		(if (compare:equals "!")
			(begin
				(this:emitIf classes (! inv) tok i trueE falseE c m code scopes needed labels)
			)
		(if (|| (&& (! inv) (compare:equals "&&")) (&& inv (compare:equals "||")))
			(begin
				(define skipL (Label))
				(define falseL (Label))
				(define falseTok (Goto falseL))
				(define i 1)
				(while (!= i (- (tok:ops:size) 1))
					(this:emitIf classes (! inv) tok i falseTok null c m code scopes needed labels)
					(set i (+ i 1))
				)
				(this:emitIf classes (! inv) tok (- (tok:ops:size) 1) falseTok null c m code scopes needed labels)
				(if output (code:pushScope))
				(scopes:push (HashMap))
				(define type (trueE:emit this classes c m code scopes needed labels))
				(if output (code:popScope))
				(scopes:pop)
				(if output (code:emitGoto skipL))
				(if output (falseL:define code))
				(if (!= falseE null)
					(begin
						(if output (code:pushScope))
						(scopes:push (HashMap))
						(falseE:emit this classes c m code scopes needed labels)
						(if output (code:popScope))
						(scopes:pop)
					)
				)
				(if output (skipL:define code))
				type
			)
		(if (|| (&& (! inv) (compare:equals "||")) (&& inv (compare:equals "&&")))
			(begin
				(define skipL (Label))
				(define trueL (Label))
				(define trueTok (Goto trueL))
				(define i 1)
				(while (!= i (- (tok:ops:size) 1))
					(this:emitIf classes inv tok i trueTok null c m code scopes needed labels)
					(set i (+ i 1))
				)
				(this:emitIf classes inv tok (- (tok:ops:size) 1) trueTok null c m code scopes needed labels)
				(if (! (= falseE null))
					(begin
						(if output (code:pushScope))
						(scopes:push (HashMap))
						(falseE:emit this classes c m code scopes needed labels)
						(if output (code:popScope))
						(scopes:pop)
					)
				)
				(if output (code:emitGoto skipL))
				(if output (trueL:define code))
				(if output (code:pushScope))
				(scopes:push (HashMap))
				(define type (trueE:emit this classes c m code scopes needed labels))
				(if output (code:popScope))
				(scopes:pop)
				(if output (skipL:define code))
				type
			)
			(begin
				(define skip (Label))
				(if (Main:compare1Ops:containsKey compare)
					(begin
						(this:compile_ classes (tok:ops:get i) c m code scopes Main:unknownType labels)
						(if output (code:emitGotoIfCompare1 skip (this:invertComp inv (Main:compare1Ops:get compare))))
					)
					(begin
						(this:compile_ classes (tok:ops:get i) c m code scopes Main:unknownType labels)
						(this:compile_ classes (tok:ops:get (+ i 1)) c m code scopes Main:unknownType labels)
						(if output (code:emitGotoIfCompare2 skip (this:invertComp inv (Main:compare2Ops:get compare))))
					)
				)
				
				;(code:emitIf)
				(if output (code:pushScope))
				(scopes:push (HashMap))
				(define type (trueE:emit this classes c m code scopes needed labels))
				(if output (code:popScope))
				(scopes:pop)
				(define end (Label))
				(if (! (= falseE null))
					(if output (code:emitGoto end))
				)
				(if output (skip:define code))
				(if (! (= falseE null))
					(begin
						;(code:emitElse)
						(if output (code:pushScope))
						(scopes:push (HashMap))
						(falseE:emit this classes c m code scopes needed labels)
						(if output (code:popScope))
						(scopes:pop)
						(if output (end:define code))
					)
				)
				;(code:emitFi)
				type
			)
		)
		)
		)
	)
	((emitIf classes Classes inv bool tok Token i int trueE Emitter falseE Emitter c ClassType m Method code CodeAttr scopes ArrayDeque needed Type labels HashMap) Type
		(define cond (tok:ops:get i))
		(if (&& (cond:what:equals "(") (this:isCompare (as String (cond:ops:get 0):val)))
			(this:emitIf_ classes inv cond 1 (as String (cond:ops:get 0):val) trueE falseE c m code scopes needed labels)
			(this:emitIf_ classes inv tok i "!=0" trueE falseE c m code scopes needed labels)
		)
	)
	((compile_ classes Classes tok Token c ClassType m Method code CodeAttr scopes java.util.ArrayDeque needed Type labels java.util.HashMap) Type
		(define output (!= code null))
		(if output (code:putLineNumber "abc.java" tok:line))
		(define result Type
			(if (tok:what:equals "S")
				(begin
					(if output (code:emitPushString (as String tok:val)))
					Type:javalangStringType
				)
			(if (tok:what:equals "C")
				(begin
					(define c int (as Character tok:val))
					(if (! (instance? needed PrimType))
						(begin
							(if output (code:emitPushInt c))
							Type:charType
						)
						(begin
							(if output (code:emitPushConstant c needed))
							needed
						)
					)
				)
			(if (tok:what:equals "N")
				(begin
					(define val String tok:val)
					(if (val:contains ".")
						(begin
							(if output (code:emitPushDouble (java.lang.Double:parseDouble val)))
							Type:doubleType
						)
						(begin
							(if (! (instance? needed PrimType))
								(begin
									(if output (code:emitPushInt (java.lang.Integer:parseInt val)))
									Type:intType
								)
								(begin
									(if output (code:emitPushConstant (java.lang.Integer:parseInt val) needed))
									needed
								)
							)
						)
					)
				)
			(if (tok:what:equals ":")
				(begin
					(define first (tok:ops:get 0))
					(define class ClassType (this:compile_ classes first c m code scopes Main:unknownType labels))
					(define field Field (class:getField (as String (tok:ops:get 1):val) -1))
					(if (field:getStaticFlag)
						(if output (code:emitGetStatic field))
						(if output (code:emitGetField field))
					)
					(field:getType)
				)
			(if (tok:what:equals "V")
				(if (tok:val:equals "this")
					(begin
						(if output (code:emitPushThis))
						c
					)
				(if (tok:val:equals "false")
					(begin
						(if output (code:emitPushInt 0))
						Type:booleanType
					)
				(if (tok:val:equals "true")
					(begin
						(if output (code:emitPushInt 1))
						Type:booleanType
					)
				(if (tok:val:equals "null")
					(begin
						(if output (code:emitPushNull))
						Type:nullType
					)
					(begin
						(define class ClassType (classes:get tok))
						(if (= class null)
							(begin
								(define found AVar (this:getVar scopes (as String tok:val)))
								(if output (found:load code))
								found:type
							)
							class
						)
					)
				)
				)
				)
				)
			(if (&& (tok:what:equals "(") (> (tok:ops:size) 0))
				(begin
					(define first (tok:ops:get 0))
					(if (first:val:equals "begin")
						(begin
							(if output (code:pushScope))
							(scopes:push (HashMap))
							(this:compile_al classes tok:ops 1 (- (tok:ops:size) 1) c m code scopes Type:voidType labels)
							(define type (this:compile_ classes (tok:ops:get (- (tok:ops:size) 1)) c m code scopes needed labels))
							(if output (code:popScope))
							(scopes:pop)
							type
						)
					(if (first:val:equals "label")
						(begin
							(define name String (tok:ops:get 1):val)
							(if (labels:containsKey name)
								(if output ((as Label (labels:get name)):define code))
								(begin
									(define label (Label))
									(label:define code)
									(labels:put name label)
								)
							)
							Type:voidType
						)
					(if (first:val:equals "goto")
						(begin
							(define name String (tok:ops:get 1):val)
							(if (labels:containsKey name)
								(if output (code:emitGoto (as Label (labels:get name))))
								(begin
									(define label Label (Label))
									(if output (code:emitGoto label))
									(labels:put name label)
								)
							)
							Type:voidType
						)
					(if (first:val:equals "define")
						(begin
							(define type Type
								(if (= (tok:ops:size) 4)
									(begin
										(define type Type (classes:get (tok:ops:get 2)))
										(this:compile_ classes (tok:ops:get 3) c m code scopes type labels)
										type
									)
									(this:compile_ classes (tok:ops:get 2) c m code scopes Main:unknownType labels)
								)
							)
							(define name String (tok:ops:get 1):val)
							(define var Variable (if output (code:addLocal type name) null))
							(if output (code:emitStore var))
							((as HashMap (scopes:getFirst)):put name (Var var type))
							Type:voidType
						)
					(if (first:val:equals "try")
						(begin
							(if output (code:emitTryStart false needed))
							(define type (this:compile_ classes (tok:ops:get 1) c m code scopes needed labels))
							(if output (code:emitCatchStart Type:javalangThrowableType))
							(if output (code:emitPop 1))
							(this:compile_ classes (tok:ops:get 2) c m code scopes needed labels)
							(if output (code:emitCatchEnd))
							(if output (code:emitTryCatchEnd))
							type
						)
					(if (first:val:equals "instance?")
						(begin
							(this:compile_ classes (tok:ops:get 1) c m code scopes Main:unknownType labels)
							(if output (code:emitInstanceof (classes:get (tok:ops:get 2))))
							Type:booleanType
						)
					(if (first:val:equals "set")
						(begin
							(define out (tok:ops:get 1))
							(if (out:what:equals ":")
								(begin
									(define first (out:ops:get 0))
									(define class ClassType (this:compile_ classes first c m code scopes Main:unknownType labels))
									(define field Field (class:getField (as String (out:ops:get 1):val) -1))
									(this:compile_ classes (tok:ops:get 2) c m code scopes (field:getType) labels)
									(if (field:getStaticFlag)
										(if output (code:emitPutStatic field))
										(if output (code:emitPutField field))
									)
								)
								(begin
									(define var (this:getVar scopes (as String out:val)))
									(this:compile_ classes (tok:ops:get 2) c m code scopes var:type labels)
									(if output (var:store code))
								)
							)
							Type:voidType
						)
					(if (first:val:equals "aset")
						(begin
							(define type ArrayType (this:compile_ classes (tok:ops:get 1) c m code scopes Main:unknownType labels))
							(this:compile_ classes (tok:ops:get 2) c m code scopes Main:unknownType labels)
							(this:compile_ classes (tok:ops:get 3) c m code scopes type:elements labels)
							(if output (code:emitArrayStore))
							Type:voidType
						)
					(if (first:val:equals "aget")
						(begin
							(define type ArrayType (this:compile_ classes (tok:ops:get 1) c m code scopes Main:unknownType labels))
							(this:compile_ classes (tok:ops:get 2) c m code scopes Type:intType labels)
							(if output (code:emitArrayLoad))
							type:elements
						)
					(if (first:val:equals "alen")
						(begin
							(this:compile_ classes (tok:ops:get 1) c m code scopes Main:unknownType labels)
							(if output (code:emitArrayLength))
							Type:intType
						)
					(if (first:val:equals "as")
						(begin
							(define cast (classes:get (tok:ops:get 1)))
							(define out (this:compile_ classes (tok:ops:get 2) c m code scopes (cast:getRawType) labels))
							(if (instance? cast ParameterizedType)
								cast
								out
							)
						)
					(if (first:val:equals "if")
						(begin
							(this:emitIf classes false tok 1 (TokenEmitter (tok:ops:get 2)) (if (= (tok:ops:size) 4) (TokenEmitter (tok:ops:get 3)) null) c m code scopes needed labels)
						)
					(if (first:val:equals "while")
						(begin
							(define start Label (Label))
							(if output (start:define code))
							(this:emitIf classes false tok 1 (Emitters (Emitter[] (TokensEmitter tok:ops 2 (tok:ops:size)) (Goto start))) null c m code scopes needed labels)
						)
					(if (this:isCompare (as String first:val))
						(begin
							(this:emitIf_ classes false tok 1 (as String first:val) (TokenEmitter (Token tok:line "V" "true")) (TokenEmitter (Token tok:line "V" "false")) c m code scopes Type:booleanType labels)
						)
					(if (Main:binOps:containsKey first:val)
						(begin
							(define types (Arrays:asList (this:compile_al classes tok:ops 1 (tok:ops:size) c m null scopes Main:unknownType labels)))
							(define otype Type Type:voidType)
							(if (types:contains Type:doubleType)
								(set otype Type:doubleType)
							(if (types:contains Type:longType)
								(set otype Type:longType)
								(set otype Type:intType)
							)
							)
							(this:compile_ classes (tok:ops:get 1) c m code scopes otype labels)
							(define i 2)
							(while (!= i (tok:ops:size))
								(this:compile_ classes (tok:ops:get i) c m code scopes otype labels)
								(if output (code:emitBinop (Main:binOps:get first:val) otype))
								(set i (+ i 1))
							)
							otype
						)
						(begin
							(define first (tok:ops:get 0))
							(if (first:what:equals ":")
								(begin ;method call
									(define name String (first:ops:get 1):val)
									(this:emitInvoke name (this:compile_ classes (first:ops:get 0) c m code scopes Main:unknownType labels) classes tok c m code scopes Main:unknownType labels)
								)
								(begin ;constructor
									(define type Type (classes:get first))
									(if (instance? type ArrayType)
										(begin
											(define array ArrayType type)
											(define len Token (if (> (tok:ops:size) 1) (tok:ops:get 1) null))
											(define i0
												(if (&& (!= len null) (len:what:equals ":") ((len:ops:get 0):val:equals "len"))
													(begin (this:compile_ classes (len:ops:get 1) c m code scopes Main:unknownType labels) 2)
													(begin (if output (code:emitPushInt (- (tok:ops:size) 1))) 1)
												)
											)
											(if output (code:emitNewArray array:elements))
											(define i i0)
											(while (!= i (tok:ops:size))
												(if output (code:emitDup))
												(if output (code:emitPushInt (- i i0)))
												(this:compile_ classes (tok:ops:get i) c m code scopes Main:unknownType labels)
												(if output (code:emitArrayStore))
												(set i (+ i 1))
											)
											type
										)
										(begin
											(define class ClassType (type:getRawType))
											(if output (code:emitNew class))
											(if output (code:emitDup))
											(this:emitInvoke "<init>" type classes tok c m code scopes Main:unknownType labels)
											type
										)
									)
								)
							)
						)
					)
					)
					)
					)
					)
					)
					)
					)
					)
					)
					)
					)
					)
					)
					)
				)
				Type:voidType
			)
			)
			)
			)
			)
			)
		)
		(if (= needed Main:unknownType)
			result
		(if (= needed Type:voidType)
			(begin
				(if (!= result Type:voidType)
					(if output (code:emitPop 1))
				)
				Type:voidType
			)
		(if (! (Type:isSame needed result))
			(begin
				(if (instance? result PrimType)
					(begin
						(if (instance? needed ClassType)
							(if output (code:emitInvoke (((as PrimType result):boxedType):getMethod "valueOf" (Type[] result))))
							(if output (code:emitConvert (as PrimType result) (as PrimType needed)))
						)
					)
				(if (instance? needed PrimType)
					(begin
						(define unbox (Main:unboxMethods:get result))
						(if output (code:emitInvoke unbox))
						(if output (code:emitConvert (as PrimType (unbox:getReturnType)) (as PrimType needed)))
					)
					(if output (code:emitCheckcast needed))
				)
				)
				needed
			)
			result
		)
		)
		)
	)
	((compile toks ArrayList{Token} locals HashMap) void
		(define classes (Classes locals))
		(define newClasses (ArrayList))

		(define i 0)
		(while (!= i (toks:size))
			(this:compile_types classes newClasses (toks:get i))
			(set i (+ i 1))
		)

		(set i 0)
		(while (!= i (toks:size))
			(this:compile_method_defs classes (toks:get i))
			(set i (+ i 1))
		)

		(set i 0)
		(while (!= i (toks:size))
			(this:compile_root classes (toks:get i))
			(set i (+ i 1))
		)

		(define cl (ArrayClassLoader))

		((java.io.File "out"):mkdir)

		(set i 0)
		(while (!= i (newClasses:size))
			(define class ClassType (newClasses:get i))
			(define classFile (class:writeToArray))
			(cl:addClass (class:getSimpleName) classFile)
			(Files:write (Paths:get (("out/":concat (class:getSimpleName)):concat ".class") (String[])) classFile (OpenOption[]))
			(set i (+ i 1))
		)
	)
)
