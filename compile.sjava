(import java.util.*)
(import java.nio.file.*)
(import gnu.bytecode.*)
(import java.io.*)
(import net.sourceforge.argparse4j.ArgumentParsers)
(import net.sourceforge.argparse4j.inf.*)

(define-class Main () 'public
	(ML int 'static) ;max length of a special token
	(MP int 'static) ;max precedence
	(precs String[][]  'static) ;precedence to special token array
	(s2prec HashMap{String Integer} 'static) ;special token to precedence
	(specialChars HashMap{String Character} 'static)
	(unboxMethods HashMap{Type Method} 'static)
	(constTypes HashMap{String Type} 'static)
	(accessModifiers HashMap{String Short} 'static)
	(binOps HashMap{String Integer} 'static)
	(compare2Ops HashMap{String Integer} 'static)
	(compare1Ops HashMap{String Integer} 'static)
	(compareOpposites HashMap{Integer Integer} 'static)
	(unknownType Type 'static)
	(args String[] 'static)
	((main args String[]) void 'public 'static
		(set Main:args args)
		(set Main:unknownType (Type:getType "unknownType"))

		(set Main:unboxMethods (HashMap{Type Method}))
		(Main:unboxMethods:put (Type:shortType:boxedType) (Type:javalangNumberType:getDeclaredMethod "shortValue" 0))
		(Main:unboxMethods:put (Type:intType:boxedType) (Type:javalangNumberType:getDeclaredMethod "intValue" 0))
		(Main:unboxMethods:put (Type:longType:boxedType) (Type:javalangNumberType:getDeclaredMethod "longValue" 0))
		(Main:unboxMethods:put (Type:doubleType:boxedType) (Type:javalangNumberType:getDeclaredMethod "doubleValue" 0))
		(Main:unboxMethods:put (Type:booleanType:boxedType) (Type:javalangBooleanType:getDeclaredMethod "booleanValue" 0))
		(Main:unboxMethods:put (Type:charType:boxedType) (Type:javalangCharacterType:getDeclaredMethod "charValue" 0))

		(set Main:constTypes (HashMap{String Type}))
		(Main:constTypes:put "bool" Type:booleanType)
		(Main:constTypes:put "byte" Type:byteType)
		(Main:constTypes:put "char" Type:charType)
		(Main:constTypes:put "double" Type:doubleType)
		(Main:constTypes:put "float" Type:floatType)
		(Main:constTypes:put "int" Type:intType)
		(Main:constTypes:put "long" Type:longType)
		(Main:constTypes:put "short" Type:shortType)
		(Main:constTypes:put "void" Type:voidType)

		(set Main:accessModifiers (HashMap{String Short}))
		(Main:accessModifiers:put "static" Access:STATIC)
		(Main:accessModifiers:put "public" Access:PUBLIC)
		(Main:accessModifiers:put "abstract" Access:ABSTRACT)
		(Main:accessModifiers:put "final" Access:FINAL)
		(Main:accessModifiers:put "private" Access:PRIVATE)
		(Main:accessModifiers:put "protected" Access:PROTECTED)
		(Main:accessModifiers:put "synchronized" Access:SYNCHRONIZED)
		(Main:accessModifiers:put "transient" Access:TRANSIENT)
		(Main:accessModifiers:put "volatile" Access:VOLATILE)
		(Main:accessModifiers:put "native" Access:NATIVE)
		(Main:accessModifiers:put "interface" Access:INTERFACE)
		(Main:accessModifiers:put "super" Access:SUPER)

		(set Main:binOps (HashMap{String Integer}))
		(Main:binOps:put "+" 96)
		(Main:binOps:put "-" 100)
		(Main:binOps:put "*" 104)
		(Main:binOps:put "/" 108)
		(Main:binOps:put "%" 112)
		(Main:binOps:put "&" 126)
		(Main:binOps:put "|" 128)
		(Main:binOps:put "^" 130)

		(set Main:compare2Ops (HashMap{String Integer}))
		;opposites
		(Main:compare2Ops:put "!=" 153)
		(Main:compare2Ops:put "=" 154)
		(Main:compare2Ops:put ">=" 155)
		(Main:compare2Ops:put "<" 156)
		(Main:compare2Ops:put "<=" 157)
		(Main:compare2Ops:put ">" 158)

		(set Main:compare1Ops (HashMap{String Integer}))
		;opposites
		(Main:compare1Ops:put "!=0" 153)
		(Main:compare1Ops:put "==0" 154)
		(Main:compare1Ops:put ">=0" 155)
		(Main:compare1Ops:put "<0" 156)
		(Main:compare1Ops:put "<=0" 157)
		(Main:compare1Ops:put ">0" 158)
		(Main:compare1Ops:put "!=null" 198)
		(Main:compare1Ops:put "==null" 199)

		(set Main:compareOpposites (HashMap{Integer Integer}))
		(Main:compareOpposites:put 153 154)
		(Main:compareOpposites:put 154 153)
		(Main:compareOpposites:put 155 156)
		(Main:compareOpposites:put 156 155)
		(Main:compareOpposites:put 157 158)
		(Main:compareOpposites:put 158 157)
		(Main:compareOpposites:put 198 199)
		(Main:compareOpposites:put 199 198)
		
		(set Main:precs (String[][]
			(String[] "`" "'")
			(String[] ",")
			(String[] ":" "'")
			(String[] "(" ")" "{" "}")
			(String[] "\n" "\r\n")
			(String[] ";")
		))

		(set Main:specialChars (HashMap{String Character}))
		(Main:specialChars:put "space" #\space)
		(Main:specialChars:put "\\" #\\)

		(set Main:MP (- (alen Main:precs) 1))

		(set Main:ML 2)

		(set Main:s2prec (HashMap{String Integer}))

		(define i 0)

		(while (!= i (alen Main:precs))
			(define a (aget Main:precs i))
			(define j 0)
			(while (!= j (alen a))
				(Main:s2prec:put (aget a j) i)
				(set j (+ j 1))
			)
			(set i (+ i 1))
		)

		(define parser (ArgumentParsers:newArgumentParser "sJava compiler"))
		((parser:addArgument (String[] "-d")):setDefault "out")
		((parser:addArgument (String[] "file")):nargs "*")

		(define res Namespace null)
		(set res (parser:parseArgs args))
		(define fileNames List{String} (res:getList "file"))
		(define files (HashMap{String List{Token}}))
		(define it (fileNames:iterator))

		(while (it:hasNext)
			(define name String (it:next))
			(define s (String (Files:readAllBytes (Paths:get name (String[])))))
			(define toks ((Lexer s):lex))
			((Parser toks):parse 0 (toks:size) Main:MP 0)
			(files:put name toks)
		)
		;((System:console):readLine)
		((Compiler):compile files (res:getString "d"))
		;((System:console):readLine)
	)
	((resolveParam pt Type t Type) Type 'static 'public
		(if (&& (instance? pt ParameterizedType) (instance? t TypeVariable))
			(begin
				(define tvs ((as ClassType ((as ParameterizedType pt):getRawType)):getTypeParameters))
				(define s String ((as TypeVariable t):getName))
				(define end false)
				(define ret Type null)
				(define i 0)
				(while (! (|| end (= i (alen tvs))))
					(if (((aget tvs i):getName):equals s)
						(begin
							(set ret ((as ParameterizedType pt):getTypeArgumentType i))
							(set end true)
						)
					)
					(set i (+ i 1))
				)
				ret
			)
		(if (&& (instance? pt ParameterizedType) (instance? t ParameterizedType))
			(begin
				(define types ((as ParameterizedType t):getTypeArgumentTypes))
				(define parameterized (Type[] len:(alen types)))
				(define i 0)
				(while (!= i (alen types))
					(aset parameterized i (Main:resolveParam pt (aget types i)))
					(set i (+ i 1))
				)
				(ParameterizedType (as ClassType (t:getRawType)) parameterized)
			)
			(t:getRawType)
		)
		)
	)
	((shiftDown toks List i int n int) void 'static
		;shift down n elements at i
		(define l (toks:size))
		(define nl (- l n))
		(while (!= i nl)
			(toks:set i (toks:get (+ i n)))
			(set i (+ i 1))
		)
		((toks:subList (- l n) l):clear)
	)
)

(define-class Token (Serializable) 'public
	(line int 'public)
	(what String 'public)
	(prec int 'public)
	(ops List{Token} 'public)
	((<init>) void 'public
		(Object:<super>)
		(set this:prec -1)
	)
	((<init> line0 int what0 String) void
		(set this:what what0)
		(set this:line line0)
		(Token:<super>)
	)
	((<init> line0 int what0 String prec0 int) void
		(Token:<super> line0 what0)
		(set this:prec prec0)
	)
	((<init> line0 int what0 String prec0 int ops0 List{Token}) void 'public
		(Token:<super> line0 what0 prec0)
		(set this:ops ops0)
	)
	((repr) String 'public
		((this:getClass):getName)
	)
	((toString) String
		(define sops "")
		(if (!= this:ops null)
			(begin
				(set sops (sops:concat " { "))
				(define i 0)
				(while (!= i (this:ops:size))
					(set sops ((sops:concat ((this:ops:get i):toString)):concat " "))
					(set i (+ i 1))
				)
				(set sops (sops:concat "} "))
			)
		)
		((org.apache.commons.lang3.StringEscapeUtils:escapeJava (this:repr)):concat sops)
	)
)

(define-class SToken (Token) 'public
	(val String 'public)
	((<init> line int val String) void
		(Token:<super> line "S")
		(set this:val val)
	)
	((<init>) void 'public
		(Token:<super>)
	)
)

(define-class NToken (Token) 'public
	(sval String 'public)
	(val Number 'public)
	((<init> line int sval String) void
		(Token:<super> line "N" 3)
		(set this:sval sval)
	)
	((<init>) void 'public
		(Token:<super>)
	)
)

(define-class CToken (Token) 'public
	(val Character)
	((<init> line int val Character) void
		(Token:<super> line "C")
		(set this:val val)
	)
	((<init>) void 'public
		(Token:<super>)
	)
)

(define-class VToken (Token) 'public
	(val String 'public)
	(macro bool 'public)
	((<init> line int val String macro bool) void
		(Token:<super> line "V")
		(set this:val val)
		(set this:macro macro)
	)
	((<init> line int val String) void
		(VToken:<super> line val false)
	)
	((toString) String
		this:val
	)
	((<init>) void 'public
		(Token:<super>)
	)
)

(define-class Lexer ()
	(code String)
	(i int)
	(ml int)
	(s String)
	(line int)
	((<init> code0 String) void
		(Object:<super>)
		(set this:code code0)
		(set this:ml (code0:length))
		(set this:line 1)
	)
	((getprec) int
		;check if code at i is a special token
		(define ii this:i)
		(define p -1)
		(define l Main:ML)
		(while (! (|| (>= p 0) (= l 0)))
			(if (<= (+ ii l) this:ml)
				(begin
					(set this:s (this:code:substring ii (+ ii l)))
					(if (Main:s2prec:containsKey this:s)
						(set p (Main:s2prec:get this:s))
					)
				)
			)
			(set l (- l 1))
		)
		p
	)
	((nextTok) void
		(while (! (|| (= this:i this:ml) (= (this:code:charAt this:i) #\space) (>= (this:getprec) 0)))
			(set this:i (+ this:i 1))
		)
	)
	((token) Token
		(while (! (|| (! (Character:isWhitespace (this:code:charAt this:i))) (>= (this:getprec) 0)))
			(set this:i (+ this:i 1))
		)
		(define p (this:getprec))
		(if (< p 0)
			(begin
				(define oi this:i)
				(define c (this:code:charAt this:i))
				(if (= c #\")
					(begin
						(set this:i (+ this:i 1))
						(define esc false)
						(while (! (&& (! esc) (= (this:code:charAt this:i) #\")))
							(set esc (&& (! esc) (= (this:code:charAt this:i) #\\)))
							(set this:i (+ this:i 1))
						)
						(set this:i (+ this:i 1))
						(SToken this:line (org.apache.commons.lang3.StringEscapeUtils:unescapeJava (this:code:substring (+ oi 1) (- this:i 1))))
					)
				(if (= c #\#)
					(begin
						(set this:i (+ this:i 2))
						(this:nextTok)
						(define schar (this:code:substring (+ oi 2) this:i))
						(CToken this:line
							(if (= (schar:length) 1)
								(schar:charAt 0)
								(Main:specialChars:get schar)
							)
						)
					)
				(if (|| (Character:isDigit c) (&& (= c #\-) (Character:isDigit (this:code:charAt (+ this:i 1)))))
					(begin
						(this:nextTok)
						(NToken this:line (this:code:substring oi this:i))
					)
					(begin
						(this:nextTok)
						(define s (this:code:substring oi this:i))
						(if (|| (s:equals "null") (s:equals "true") (s:equals "false"))
							(Token this:line s)
							(VToken this:line s)
						)
					)
				)
				)
				)
			)
			(begin
				(set this:i (+ this:i (this:s:length)))
				(if (this:s:contains "\n")
					(set this:line (+ this:line 1))
				)
				(Token this:line this:s p)
			)
		)
	)
	((lex) ArrayList
		(set this:i 0)
		(define out (ArrayList))
		(while
			(!= this:i this:ml)
			(out:add (this:token))
		)
		out
	)
)

(define-class BlockToken (Token) 'public
	(labels HashMap)
	((<init> line0 int ops0 List{Token}) void 'public
		(Token:<super> line0 "block" -1 ops0)
	)
	((<init>) void 'public
		(Token:<super>)
	)
)

(define-class GenericToken (Token) 'public
	(tok Token 'public)
	(params List{Token} 'public)
	((<init> line0 int tok Token params List{Token}) void 'public
		(Token:<super> line0 "generic")
		(set this:tok tok)
		(set this:params params)
	)
	((<init>) void 'public
		(Token:<super>)
	)
)

(define-class ColonToken (Token) 'public
	((<init> line0 int ops List{Token}) void 'public
		(Token:<super> line0 ":" -1 ops)
	)
	((<init>) void 'public
		(Token:<super>)
	)
)

(define-class QuoteToken (Token) 'public
	(quasi bool 'public)
	((<init> line0 int ops List{Token} quasi bool) void
		(Token:<super> line0 "quote" -1 ops)
		(set this:quasi quasi)
	)
	((<init>) void 'public
		(Token:<super>)
	)
)

(define-class UnquoteToken (Token) 'public
	((<init> line0 int ops List{Token}) void
		(Token:<super> line0 "unquote" -1 ops)
	)
	((<init>) void 'public
		(Token:<super>)
	)
)

(define-class Parser ()
	(toks ArrayList{Token})
	((<init> toks0 ArrayList{Token}) void
		(Object:<super>)
		(set this:toks toks0)
	)
	;these methods return the number of tokens which they shifted down
	((block i int e int o String c String) int
		(define oi i)
		(define oe e)
		(define end false)
		(set i (+ i 1))
		(while (! end)
			(define t (this:toks:get i))
			(define w t:what)
			(if (w:equals o)
				(set e (- e (this:block i e o c)))
			)
			(if (w:equals c)
				(begin
					(define d (this:parse (+ oi 1) i Main:MP 0))
					(set i (- i d))
					(set e (- e d))
					(define n (- i oi))
					;(if (> n 2)
						(this:toks:set oi (BlockToken (this:toks:get oi):line (ArrayList (this:toks:subList (+ oi 1) i))))
						;(set! (toks oi) (toks (+ oi 1)))
					;)
					(Main:shiftDown this:toks (+ oi 1) n)
					(set e (- e n))
					(set end true)
				)
			)
			(set i (+ i 1))
		)
		(- oe e)
	)
	((generic i int e int o String c String) int
		(define oi i)
		(define oe e)
		(define end false)
		(set i (+ i 1))
		(while (! end)
			(define t Token (this:toks:get i))
			(define w t:what)
			(if (w:equals o)
				(begin
					(set e (- e (this:generic i e o c)))
					(set i (- i 1))
				)
			)
			(if (w:equals c)
				(begin
					(define d (this:parse (+ oi 1) i Main:MP 0))
					(set i (- i d))
					(set e (- e d))
					(define n (+ (- i oi) 1))
					(this:toks:set (- oi 1) (GenericToken t:line (this:toks:get (- oi 1)) (ArrayList (this:toks:subList (+ oi 1) i))))
					(Main:shiftDown this:toks oi n)
					(set e (- e n))
					(set end true)
				)
			)
			(set i (+ i 1))
		)
		(- oe e)
	)
	((comment i int e int) int
		(define oi i)
		(define oe e)
		(define end false)
		(set i (+ i 1))
		(while (! end)
			(if (|| (= i (this:toks:size)) ((this:toks:get i):what:contains "\n"))
				(begin
					(define n (- i oi))
					(Main:shiftDown this:toks oi n)
					(set e (- e n))
					(set end true)
				)
			)
			(set i (+ i 1))
		)
		(- oe e)
	)
	((parse i int e int p int mp int) int
		;parse from i to e starting at precedence p, until mp (minimum precedence)
		(define oi i)
		(define oe e)
		(define end false)
		(while (! (|| end (= i e)))
			(define t (this:toks:get i))
			(define w t:what)
			(if (= t:prec p)
				(begin
					(if (w:equals "(")
						(set e (- e (this:block i e "(" ")")))
					)
					(if (w:equals "{")
						(begin
							(set e (- e (this:generic i e "{" "}")))
							(set i (- i 1))
						)
					)
					(if (w:equals "N")
						(begin
							(define t NToken t)
							(if (t:sval:contains ".")
								(set t:val (Double:parseDouble t:sval))
								(set t:val (Integer:parseInt t:sval))
							)
						)
					)
					(if (w:equals ";")
						(begin
							(set e (- e (this:comment i e)))
							(set i (- i 1))
						)
					)
					(if (w:equals ":")
						(begin
							(this:toks:set (- i 1) (ColonToken t:line (ArrayList (Arrays:asList (Object[] (this:toks:get (- i 1)) (this:toks:get (+ i 1)))))))
							(Main:shiftDown this:toks i 2)
							(set e (- e 2))
							(set i (- i 1))
						)
					)
					(if (|| (w:equals "'") (w:equals "`") (w:equals ","))
						(begin
							(define al (ArrayList (Arrays:asList (Object[] (this:toks:get (+ i 1))))))
							(define new
								(if (w:equals ",")
									(UnquoteToken t:line al)
									(QuoteToken t:line al (w:equals "`"))
								)
							)
							(this:toks:set i new)
							(Main:shiftDown this:toks (+ i 1) 1)
							(set e (- e 1))
						)
					)
					(if (Character:isWhitespace (w:charAt 0))
						(begin
							(Main:shiftDown this:toks i 1)
							(set e (- e 1))
							(set i (- i 1))
						)
					)
				)
			)
			(set i (+ i 1))
		)
		(if (> p mp)
			(set e (- e (this:parse oi e (- p 1) mp)))
		)
		(- oe e)
	)
)

(define-class AVar ()
	(type Type)
	((<init> type Type) void (Object:<super>) (set this:type type))
	((load code CodeAttr) Type this:type)
	((store code CodeAttr) void ())
)

(define-class Var (AVar)
	(var Variable)
	((<init> var0 Variable type0 Type) void (AVar:<super> type0) (set this:var var0))
	((load code CodeAttr) Type
		(define output (!= code null))
		(if output (code:emitLoad this:var))
		this:type
	)
	((store code CodeAttr) void
		(define output (!= code null))
		(if output (code:emitStore this:var))
	)
)

(define-class Arg (AVar)
	(n int)
	((<init> n0 int type0 Type) void (AVar:<super> type0) (set this:n n0))
	((load code CodeAttr) Type
		(define output (!= code null))
		(if output (code:emitLoad (code:getArg this:n)))
		this:type
	)
	((store code CodeAttr) void
		(define output (!= code null))
		(if output (code:emitStore (code:getArg this:n)))
	)
)

(define-class FileScope ()
	(locals HashMap)
	(imports HashMap)
	(starImports ArrayList)
	(found HashMap{String Boolean})
	(macros ClassType)
	(macrosC Class)
	(includes ClassType)
	(includesC Class)
	(newClasses List{ClassType})
	(package String)
	(macroNames Set{String})
	((<init> locals0 HashMap) void
		(Object:<super>)
		(set this:locals locals0)
		(set this:imports (HashMap))
		(set this:starImports (ArrayList))
		(this:starImports:add "java.lang.")
		(set this:found (HashMap{String Boolean}))
		(set this:newClasses (ArrayList{ClassType}))
	)
	((classExists name String) bool
		(if (this:found:containsKey name)
			(this:found:get name)
			(begin
				(define b
					(try
						(begin
							(java.lang.Class:forName name)
							true
						)
						e
						false
					)
				)
				(this:found:put name b)
				b
			)
		)
	)
	((get name String) Type
		(define i 0)
		(define dims -1)
		(while (!= i -1)
			(set i (name:indexOf "[]" (+ i 1)))
			(set dims (+ dims 1))
		)
		(set name (name:replace "[" ""))
		(set name (name:replace "]" ""))
		(define type Type
			(if (Main:constTypes:containsKey name)
				(Main:constTypes:get name)
			(if (this:locals:containsKey name)
				(this:locals:get name)
			(if (this:imports:containsKey name)
				(this:imports:get name)
			(if (this:classExists name)
				(Type:getType name)
			(begin
				(define type Type Main:unknownType)
				(define i 0)
				(while (! (|| (! (= type Main:unknownType)) (= i (this:starImports:size))))
					(if (this:classExists ((as String (this:starImports:get i)):concat name))
						(set type (Type:getType ((as String (this:starImports:get i)):concat name)))
					)
					(set i (+ i 1))
				)
				type
			)
			)
			)
			)
			)
		)
		(set i 0)
		(while (!= i dims)
			(set type (ArrayType type))
			(set i (+ i 1))
		)
		type
	)
	((get tok Token) Type
		(if (instance? tok GenericToken)
			(begin
				(define tok GenericToken tok)
				(define c ClassType (this:get (as VToken tok:tok):val))
				(define params tok:params)
				(define tparams (Type[] len:(params:size)))
				(define i 0)
				(while (!= i (params:size))
					(aset tparams i (this:get (params:get i)))
					(set i (+ i 1))
				)
				(ParameterizedType c tparams)
			)
			(this:get (as VToken tok):val)
		)
	)
)

(define-class ClassToken (Token)
	(c ClassType 'public)
	((<init> line int c ClassType ops List{Token}) void
		(Token:<super> line "class" -1 ops)
		(set this:c c)
	)
	((<init>) void 'public
		(Token:<super>)
	)
)

(define-class AMethodToken (Token)
	(c ClassType)
	(block BlockToken)
	(method Method)
	(scopes ArrayDeque)
	(labels ArrayDeque)
	(mscopes ArrayDeque)
	((<init> c ClassType line int block BlockToken method Method scope HashMap) void
		(Token:<super> line "method" -1 (Arrays:asList (Token[] block)))
		(set this:c c)
		(set this:block block)
		(set this:method method)
		(set this:scopes (ArrayDeque))
		(this:scopes:push scope)
		(set this:labels (ArrayDeque))
		(set this:mscopes (ArrayDeque))
	)
	((pushScope code CodeAttr label HashMap) void
		(define output (!= code null))
		(this:scopes:push (HashMap))
		(this:labels:push label)
		(if output (code:pushScope))
	)
	((popScope code CodeAttr) void
		(define output (!= code null))
		(this:scopes:pop)
		(this:labels:pop)
		(if output (code:popScope))
	)
	((getVar name String scopes ArrayDeque) AVar
		(define found AVar null)
		(define it Iterator (scopes:iterator))
		(while (= found null)
			(define vars HashMap (it:next))
			(if (vars:containsKey name)
				(set found (vars:get name))
			)
		)
		found
	)
	((getVar name String) AVar
		(this:getVar name this:scopes)
	)
	((getLabel name String) Label
		(define found Label null)
		(define it Iterator (this:labels:iterator))
		(while (= found null)
			(define vars HashMap (it:next))
			(if (vars:containsKey name)
				(set found (vars:get name))
			)
		)
		found
	)
	((newVar code CodeAttr tok VToken type Type) Variable
		(define output (!= code null))
		(define name tok:val)
		(define var Variable (if output (code:addLocal (type:getRawType) name) null))
		(if tok:macro
			((as HashMap (this:mscopes:getFirst)):put name (Var var type))
			((as HashMap (this:scopes:getFirst)):put name (Var var type))
		)
		var
	)
)

(define-class MethodToken (AMethodToken)
	((<init> c ClassType line int block BlockToken method Method scope HashMap) void
		(AMethodToken:<super> c line block method scope)
	)
)

(define-class MacroToken (AMethodToken)
	((<init> c ClassType line int block BlockToken method Method scope HashMap) void
		(AMethodToken:<super> c line block method scope)
	)
)

(define-class IncludeToken (AMethodToken)
	((<init> c ClassType line int block BlockToken method Method scope HashMap) void
		(AMethodToken:<super> c line block method scope)
	)
)

(define-class Compiler ()
	((<init>) void (Object:<super>))
	((compileMacros fs FileScope toks List{Token} macroNames Set{String}) void
		(define i 0)
		(define macros fs:macros)
		(while (!= i (toks:size))
			(define tok (toks:get i))
			(if (&& (instance? tok BlockToken) (> (tok:ops:size) 0) (instance? (tok:ops:get 0) VToken))
				(begin
					(define first VToken (tok:ops:get 0))
					(if (first:val:equals "define-macro")
						(begin
							(define scope (HashMap))
							(define params (tok:ops:get 1))
							(define name (as VToken (params:ops:get 0)):val)
							(define o 3)
							(define types (Type[] len:(+ o (- (params:ops:size) 1)) (Type:getType "FileScope") (Type:getType "AMethodToken") (Type:getType "gnu.bytecode.Type")))
							(define mods (| Access:PUBLIC Access:STATIC))
							(begin
								(define i 0)
								(while (!= (+ o i) (alen types))
									(define t (Type:getType "Token"))
									(define name (as VToken (params:ops:get (+ i 1))):val)
									(if (name:contains "@")
										(begin
											(set name (name:replace "@" ""))
											(set mods (| mods Access:TRANSIENT))
											(set t (ArrayType t))
										)
									)
									(aset types (+ o i) t)
									(scope:put name (Arg (+ o i) t))
									(set i (+ i 1))
								)
							)
							(Compiler:compileBlock (as BlockToken tok))
							(toks:set i (MacroToken macros tok:line (as BlockToken tok) (macros:addMethod name types (Type:getType "Token") mods) scope))
							(macroNames:add name)
						)
					)
				)
			)
			(set i (+ i 1))
		)
		(set i 0)
		(while (!= i (toks:size))
			(define tok (toks:get i))
			(if (instance? tok MacroToken)
				(begin
					(this:compileMethodBody (as AMethodToken tok) fs 2)
					(Main:shiftDown toks i 1)
					(set i (- i 1))
				)
			)
			(set i (+ i 1))
		)
	)
	((compileIncludes fs FileScope toks ArrayList{Token}) void
		(define includes (ClassType "Includes"))
		(set fs:includes includes)
		(includes:setSuper "java.lang.Object")
		(includes:setModifiers Access:PUBLIC)
		(this:compileIncludes fs includes toks 0)
		(define cl (ArrayClassLoader))
		(cl:addClass "Includes" (includes:writeToArray))
		(set fs:includesC (cl:loadClass "Includes" true))
	)
	((compileIncludes fs FileScope includes ClassType toks List{Token} n int) int
		(define i 0)
		(while (!= i (toks:size))
			(define tok (toks:get i))
			(if (&& (!= tok:ops null) (> (tok:ops:size) 0))
				(if (&& (instance? (tok:ops:get 0) VToken) ((as VToken (tok:ops:get 0)):val:equals "include"))
					(begin
						(define name ("$":concat (Integer:toString i)))
						(define mi (IncludeToken includes tok:line (as BlockToken tok) (includes:addMethod name (Type[]) (Type:getType "Token") (| Access:PUBLIC Access:STATIC)) (HashMap)))
						(toks:set i mi)
						(this:compileMethodBody mi fs 1)
						(set n (+ n 1))
					)
					(set n (this:compileIncludes fs includes tok:ops n))
				)
			)
			(set i (+ i 1))
		)
		n
	)
	((isCompare s String) bool
		(|| (s:equals "!") (s:equals "&&") (s:equals "||") (Main:compare1Ops:containsKey s) (Main:compare2Ops:containsKey s))
	)
	((compileClass fs FileScope tok Token) Token
		(if (instance? (tok:ops:get 0) VToken)
			(begin
				(define first VToken (tok:ops:get 0))
				(if (first:val:equals "define-class")
					(begin
						(define name (as VToken (tok:ops:get 1)):val)
						(if (!= fs:package null)
							(set name ((fs:package:concat "."):concat name))
						)
						(define c (ClassType name))
						(c:setClassfileVersion ClassType:JDK_1_5_VERSION)
						(define supers (tok:ops:get 2):ops)
						(c:setSuper "java.lang.Object")
						(define i 0)
						(while (! (= i (supers:size)))
							(define related ClassType (fs:get (supers:get i)))
							(if (related:isInterface)
								(c:addInterface related)
								(c:setSuper related)
							)
							(set i (+ i 1))
						)
						(fs:newClasses:add c)
						(fs:locals:put name c)
						(set i 2)
						(define run true)
						(while (&& run (!= i (tok:ops:size)))
							(set i (+ i 1))
							(set run (this:compileClassMod (tok:ops:get i) c))
						)
						(set tok (ClassToken tok:line c (tok:ops:subList i (tok:ops:size))))
					)
				(if (first:val:equals "import")
					(begin
						(define import (as VToken (tok:ops:get 1)):val)
						(if (import:contains "*")
							(fs:starImports:add (import:replace "*" ""))
							(fs:imports:put (import:substring (+ (import:lastIndexOf ".") 1)) (Type:getType import))
						)
					)
				)
				)
			)
		)
		tok
	)
	((compileClassMod tok Token c ClassType) bool
		(if (instance? tok QuoteToken)
			(begin
				(define nmod int (Main:accessModifiers:get (as VToken (tok:ops:get 0)):val))
				(c:setModifiers nmod)
				true
			)
			false
		)
	)
	((compileMethodDefs fs FileScope tok Token) void
		(if (instance? tok ClassToken)
			(begin
				(define tok ClassToken tok)
				(define i 0)
				(while (!= i (tok:ops:size))
					(tok:ops:set i (this:compileMethodDef fs (tok:ops:get i) tok:c))
					(set i (+ i 1))
				)
			)
		)
	)
	((getParams fs FileScope tok Token scope HashMap n int) Type[]
		(define types (Type[] len: (/ (- (tok:ops:size) 1) 2)))
		(define j 0)
		(while (!= j (alen types))
			(define type (fs:get (tok:ops:get (+ (* j 2) 2))))
			(aset types j type)
			(scope:put (as VToken (tok:ops:get (+ (* j 2) 1))):val (Arg (+ n j) type))
			(set j (+ j 1))
		)
		types
	)
	((compileMethodDef fs FileScope tok Token c ClassType) Token
		(define first (tok:ops:get 0))
		(if (instance? first BlockToken) ;method definition
			(begin
				(define scope (HashMap))
				(define mods 0)
				(define end false)
				(define i 2)
				(while (! (|| end (= i (tok:ops:size))))
					(define mod (tok:ops:get i))
					(if (instance? mod QuoteToken)
						(begin
							(set mods (| mods (Main:accessModifiers:get (as VToken (mod:ops:get 0)):val)))
							(set i (+ i 1))
						)
						(set end true)
					)
				)
				(define n 0)
				(if (= (& mods Access:STATIC) 0)
					(begin
						(scope:put "this" (Arg 0 c))
						(set n 1)
					)
				)
				(define types (this:getParams fs first scope n))
				(define m Method (c:addMethod (as VToken (first:ops:get 0)):val types (fs:get (tok:ops:get 1)) mods))
				(define block (BlockToken tok:line (ArrayList (tok:ops:subList i (tok:ops:size)))))
				(Compiler:compileBlock block)
				(set tok (MethodToken c tok:line block m scope))
			)
			(begin ;field definition
				(define mods 0)
				(define end false)
				(define i 2)
				(while (! (| (= i (tok:ops:size)) end))
					(define mod (tok:ops:get i))
					(if (instance? mod QuoteToken)
						(begin
							(define nmod (Main:accessModifiers:get (as VToken (mod:ops:get 0)):val))
							(set mods (| mods nmod))
						)
						(set end true)
					)
					(set i (+ i 1))
				)
				(c:addField (as VToken first):val (fs:get (tok:ops:get 1)) mods)
			)
		)
		tok
	)
	((compileBlock block Token) void 'static
		(if (!= block:ops null)
			(begin
				(if (instance? block BlockToken)
					(set (as BlockToken block):labels (HashMap))
				)
				(define i 0)
				(while (!= i (block:ops:size))
					(define tok (block:ops:get i))
					(Compiler:compileBlock tok)
					(if (&& (instance? tok BlockToken) (> (tok:ops:size) 0) (instance? (tok:ops:get 0) VToken))
						(begin
							(define val (as VToken (tok:ops:get 0)):val)
							(if (val:equals "label")
								((as BlockToken block):labels:put (as VToken (tok:ops:get 1)):val (Label))
							)
							(if (val:equals "mvar")
								(begin
									(define v VToken (tok:ops:get 1))
									(set v:macro true)
									(block:ops:set i v)
								)
							)
						)
					)
					(set i (+ i 1))
				)
			)
		)
	)
	((compileMethods fs FileScope tok Token) void
		(if (instance? tok ClassToken)
			(begin
				(define tok ClassToken tok)
				(define i 0)
				(while (!= i (tok:ops:size))
					(this:compileMethod fs (tok:ops:get i))
					(set i (+ i 1))
				)
			)
		)
	)
	((compileMethod fs FileScope tok Token) void ()
		(if (instance? tok MethodToken)
			(begin ;method definition
				(define tok MethodToken tok)
				(if (! (tok:method:isAbstract))
					(this:compileMethodBody tok fs 0)
				)
			)
		)
	)
	((compileMethodBody mi AMethodToken fs FileScope i int) void
		(define tok mi:block)
		(define h GenHandler:inst)
		(mi:pushScope null tok:labels)
		(h:compileAll fs tok:ops i (- (tok:ops:size) 1) mi null Type:voidType)
		(h:compile fs (tok:ops:get (- (tok:ops:size) 1)) mi null (mi:method:getReturnType))
		(mi:popScope null)
		(define code (mi:method:startCode))
		(mi:pushScope code tok:labels)
		(h:compileAll fs tok:ops i (- (tok:ops:size) 1) mi code Type:voidType)
		(h:compile fs (tok:ops:get (- (tok:ops:size) 1)) mi code (mi:method:getReturnType))
		(mi:popScope code)
		(code:emitReturn)
	)
	((compile files HashMap{String ArrayList{Token}} dir String) void
		(define macros (ClassType "Macros"))
		(macros:setSuper "java.lang.Object")
		(macros:setModifiers Access:PUBLIC)

		(define locals (HashMap))
		(define fileScopes (HashMap{String FileScope}))
		(define macroNames (HashSet{String}))

		(begin
			(define it ((files:entrySet):iterator))
			(while (it:hasNext)
				(define entry (it:next))
				(define fs (FileScope locals))
				(set fs:macros macros)
				(fileScopes:put (entry:getKey) fs)
				(define toks (entry:getValue))
				(if (&&
						(> (toks:size) 0)
						(instance? (toks:get 0) BlockToken)
						(instance? ((toks:get 0):ops:get 0) VToken)
						((as VToken ((toks:get 0):ops:get 0)):val:equals "package")
					)
					(set fs:package (as VToken ((toks:get 0):ops:get 1)):val)
				)
				(set fs:macroNames macroNames)

				(define i 0)
				(while (!= i (toks:size))
					(toks:set i (this:compileClass fs (toks:get i)))
					(set i (+ i 1))
				)
			)
		)

		(begin
			(define it ((files:entrySet):iterator))
			(while (it:hasNext)
				(define entry (it:next))
				(define toks (entry:getValue))
				(define i 0)
				(while (!= i (toks:size))
					(this:compileMethodDefs (fileScopes:get (entry:getKey)) (toks:get i))
					(set i (+ i 1))
				)
			)
		)

		(begin
			(define it ((files:entrySet):iterator))
			(while (it:hasNext)
				(define entry (it:next))
				(define toks (entry:getValue))
				(this:compileMacros (fileScopes:get (entry:getKey)) toks macroNames)
			)
		)

		(define cl (ArrayClassLoader))
		(define classFile (macros:writeToArray))
		(cl:addClass "Macros" classFile)
		(define macrosC (cl:loadClass "Macros" true))

		(begin
			(define it ((files:entrySet):iterator))
			(while (it:hasNext)
				(define entry (it:next))
				(define toks (entry:getValue))
				(define fs (fileScopes:get (entry:getKey)))
				(set fs:macrosC macrosC)
				(this:compileIncludes fs toks)
			)
		)

		(begin
			(define it ((files:entrySet):iterator))
			(while (it:hasNext)
				(define entry (it:next))
				(define toks (entry:getValue))
				(define i 0)
				(while (!= i (toks:size))
					(this:compileMethods (fileScopes:get (entry:getKey)) (toks:get i))
					(set i (+ i 1))
				)
			)
		)

		(define cl (ArrayClassLoader))

		(begin
			(define it ((fileScopes:entrySet):iterator))
			(while (it:hasNext)
				(define entry (it:next))
				(define fileScopes (entry:getValue))
				(define newClasses fileScopes:newClasses)
				(define i 0)
				(while (!= i (newClasses:size))
					(define class ClassType (newClasses:get i))
					(define classFile (class:writeToArray))
					(cl:addClass (class:getSimpleName) classFile)
					(define pre
						(if (= fileScopes:package null)
							dir
							((dir:concat (fileScopes:package:replace "." "/")):concat "/")
						)
					)
					((java.io.File pre):mkdirs)
					(Files:write (Paths:get ((pre:concat (class:getSimpleName)):concat ".class") (String[])) classFile (OpenOption[]))
					(set i (+ i 1))
				)
			)
		)

		(define argTypes (Class[] (Class:forName "[Ljava.lang.String;")))
		(define main java.lang.reflect.Method null)

		; (if false
		; 	(begin
		; 		(define i 0)
		; 		(while (!= i (newClasses:size))
		; 			(define class ClassType (newClasses:get i))
		; 			(try
		; 				(set main ((cl:loadClass (class:getSimpleName) true):getMethod "main" argTypes))
		; 				e
		; 				()
		; 			)
		; 			(set i (+ i 1))
		; 		)

		; 		(if (!= main null)
		; 			(main:invoke
		; 				null
		; 				(Object[] (String[]))
		; 			)
		; 		)
		; 	)
		; )
	)
)


(define-class Emitter ()
	((<init>) void
		(Object:<super>)
	)
	((emit h Handler fs FileScope mi AMethodToken code CodeAttr needed Type) Type 'public
		(define types (this:emitAll h fs mi code needed))
		(if (= types null)
			null
			(begin
				(define l (alen types))
				(if (= l 0)
					null
					(aget types (- l 1))
				)
			)
		)
	)
	((emitAll h Handler fs FileScope mi AMethodToken code CodeAttr needed Object) Type[] 'public (Type[] (this:emit h fs mi code (as Type needed))))
)

(define-class TokenEmitter (Emitter)
	(tok Token)
	((<init> tok0 Token) void
		(Emitter:<super>)
		(set this:tok tok0)
	)
	((emit h Handler fs FileScope mi AMethodToken code CodeAttr needed Type) Type 'public
		(h:compile fs this:tok mi code needed)
	)
)

(define-class Goto (Emitter)
	(label Label)
	((<init> label0 Label) void (Emitter:<super>) (set this:label label0))
	((emit h Handler fs FileScope mi AMethodToken code CodeAttr needed Type) Type 'public (if (! (= code null)) (code:emitGoto this:label)) Type:voidType)
)

(define-class Null (Emitter)
	((<init>) void (Emitter:<super>))
	((emit h Handler fs FileScope mi AMethodToken code CodeAttr needed Type) Type 'public (if (! (= code null)) (code:emitPushNull)) Type:nullType)
)

(define-class LoadAVar (Emitter)
	(avar AVar)
	((<init> avar AVar) void
		(Emitter:<super>)
		(set this:avar avar)
	)
	((emit h Handler fs FileScope mi AMethodToken code CodeAttr needed Type) Type 'public
		(this:avar:load code)
	)
)

(define-class Emitters (Emitter)
	(emitters List{Emitter})
	((<init> emitters Emitter[]) void (Emitter:<super>) (set this:emitters (Arrays:asList emitters)))
	((<init> emitters List{Emitter}) void (Emitter:<super>) (set this:emitters emitters))
	((emitAll h Handler fs FileScope mi AMethodToken code CodeAttr needed Object) Type[] 'public
		(define types (Type[] len:(this:emitters:size)))
		(define i 0)
		(while (< i (alen types))
			(aset types i ((this:emitters:get i):emit h fs mi code
				(if (instance? needed Type[])
					(aget (as Type[] needed) i)
					(as Type needed)
				)
			))
			(set i (+ i 1))
		)
		types
	)
	((tokenEmitters toks List{Token} i int e int) List{Emitter} 'static
		(define out (ArrayList{Emitter}))
		(while (!= i e)
			(out:add (TokenEmitter (toks:get i)))
			(set i (+ i 1))
		)
		out
	)
)

(define-class MFilter (Filter)
	(methods0 ArrayList{Method})
	(methods1 ArrayList{Method})
	(varmethods ArrayList{Method})
	(name String)
	(types Type[])
	(pt Type)
	((<init> name0 String types0 Type[] pt0 Type) void
		(Object:<super>)
		(set this:methods0 (ArrayList{Method}))
		(set this:methods1 (ArrayList{Method}))
		(set this:varmethods (ArrayList{Method}))
		(set this:name name0)
		(set this:types types0)
		(set this:pt pt0)
	)
	((select v Object) bool 'public
		(define method Method v)
		(if ((method:getName):equals this:name)
			(begin
				(define varargs (!= (& (method:getModifiers) Access:TRANSIENT) 0))
				(define na (alen this:types))
				(define np (alen (method:getParameterTypes)))
				(if (|| (= na np) (&& varargs (>= na (- np 1))))
					(begin
						(define stop false)
						(define maxLevel 0)
						(define i 0)
						(while (! (|| stop (= i (alen this:types))))
							(define at
								(if (&&
										varargs
										(>= i (- np 1))
										(||
											(!= i (- np 1))
											(< ((Main:resolveParam this:pt (aget (method:getParameterTypes) i)):compare (aget this:types i)) 0)
										)
									)
									(as ArrayType (aget (method:getParameterTypes) (- np 1))):elements
									(aget (method:getParameterTypes) i)
								)
							)
							(define level ((Main:resolveParam this:pt at):compare (aget this:types i)))
							(if (> level maxLevel)
								(set maxLevel level)
							)
							(if (< level 0)
								(set stop true)
							)
							(set i (+ i 1))
						)
						(if (! stop)
							(if varargs
								(this:varmethods:add method)
								(if (= maxLevel 0)
									(this:methods0:add method)
									(this:methods1:add method)
								)
							)
						)
					)
				)
			)
		)
		false
	)
	((getMethod) Method
		(if (= (this:methods0:size) 0)
			(if (= (this:methods1:size) 0)
				(this:varmethods:get 0)
				(this:methods1:get 0)
			)
			(this:methods0:get 0)
		)
	)
)

(define-class Handler () 'public
	((<init>) void (Object:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool false)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type null)
	((compile fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type
		(this:compile null fs tok mi code needed)
	)
	((compile fs FileScope tok Token mi AMethodToken code CodeAttr) Type 'public
		(this:compile fs tok mi code Main:unknownType)
	)
	((compileAll fs FileScope toks List{Token} i int e int mi AMethodToken code CodeAttr needed Object) Type[]
		(define l (toks:size))
		(define types (Type[] len: (- e i)))
		(define j i)
		(while (! (>= j e))
			(aset types (- j i)
				(this:compile fs (toks:get j) mi code
					(if (instance? needed Type[])
						(aget (as Type[] needed) (- j i))
						needed
					)
				)
			)
			(set j (+ j 1))
		)
		types
	)
	((tryHandlers h Handler default Type handlers Handler[] fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'static
		(define i 0)
		(define type default)
		(define run true)
		(while (&& run (< i (alen handlers)))
			(define s (aget handlers i))
			(if (s:valid fs tok mi needed)
				(begin
					(set type (s:compile h fs tok mi code needed))
					(set run false)
				)
			)
			(set i (+ i 1))
		)
		type
	)
	((castMaybe code CodeAttr result Type needed Type) Type
		(define output (!= code null))
		(if (= needed Main:unknownType)
			result
		(if (= needed Type:voidType)
			(begin
				(if (!= result Type:voidType)
					(if output (code:emitPop 1))
				)
				Type:voidType
			)
		(if (! (Type:isSame needed result))
			(begin
				(if (instance? result PrimType)
					(begin
						(if (instance? needed ClassType)
							(if output (code:emitInvoke (((as PrimType result):boxedType):getMethod "valueOf" (Type[] result))))
							(if output (code:emitConvert (as PrimType result) (as PrimType needed)))
						)
					)
				(if (instance? needed PrimType)
					(begin
						(define unbox (Main:unboxMethods:get result))
						(if output (code:emitInvoke unbox))
						(if output (code:emitConvert (as PrimType (unbox:getReturnType)) (as PrimType needed)))
					)
					(if output (code:emitCheckcast (needed:getRawType)))
				)
				)
				needed
			)
			result
		)
		)
		)
	)
)

(define-class GenHandler (Handler) 'public
	(inst Handler 'static 'public)
	((<clinit>) void 'static (set GenHandler:inst (GenHandler)))
	(handlers Handler[])
	((<init> handlers Handler[]) void
		(Handler:<super>)
		(set this:handlers handlers)
	)
	((<init>) void
		(GenHandler:<super> (Handler[]
			SHandler:inst
			CHandler:inst
			NHandler:inst
			ColonHandler:inst
			QuasiHandler:inst
			ConstsHandler:inst
			VHandler:inst
			IncludeHandler:inst
			BlockHandler:inst
		))
	)
	((compile fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type
		(define output (!= code null))
		(if output (code:putLineNumber "abc.java" tok:line))
		(try
			(begin
				(define type (Handler:tryHandlers this Type:voidType this:handlers fs tok mi code needed))
				(this:castMaybe code type needed)
			)
			e
			(begin
				(System:out:println ("Error compiling line ":concat (Integer:toString tok:line)))
				(throw e)
			)
		)
	)
)

(define-class IncludeHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set IncludeHandler:inst (IncludeHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(instance? tok IncludeToken)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define t Token ((fs:includesC:getMethod ((as IncludeToken tok):method:getName) (Class[])):invoke null (Object[])))
		(h:compile fs t mi code needed)
	)
)

(define-class SHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set SHandler:inst (SHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(instance? tok SToken)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(if output (code:emitPushString (as SToken tok):val))
		Type:javalangStringType
	)
)

(define-class CHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set CHandler:inst (CHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(instance? tok CToken)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define c int (as CToken tok):val)
		(if (! (instance? needed PrimType))
			(begin
				(if output (code:emitPushInt c))
				Type:charType
			)
			(begin
				(if output (code:emitPushConstant c needed))
				needed
			)
		)
	)
)

(define-class NHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set NHandler:inst (NHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(instance? tok NToken)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define tok NToken tok)
		(if (instance? tok:val Double)
			(begin
				(if output (code:emitPushDouble (as Double tok:val)))
				Type:doubleType
			)
			(begin
				(if (! (instance? needed PrimType))
					(begin
						(if output (code:emitPushInt (as Integer tok:val)))
						Type:intType
					)
					(begin
						(if output (code:emitPushConstant (as Integer tok:val) needed))
						needed
					)
				)
			)
		)
	)
)

(define-class ColonHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set ColonHandler:inst (ColonHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(instance? tok ColonToken)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:ops:get 0))
		(define class ClassType (h:compile fs first mi code Main:unknownType))
		(define field Field (class:getField (as VToken (tok:ops:get 1)):val -1))
		(if (field:getStaticFlag)
			(if output (code:emitGetStatic field))
			(if output (code:emitGetField field))
		)
		(field:getType)
	)
)

(define-class QuasiHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set QuasiHandler:inst (QuasiHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(instance? tok QuoteToken)
	)
	((compilequasi h Handler fs FileScope o Object mi AMethodToken code CodeAttr needed Type macro bool) Type
		(define output (!= code null))
		(define result
			(if (= o null)
				(begin
					(if output (code:emitPushNull))
					Type:nullType
				)
			(if (instance? o Token)
				(begin
					(define tok Token o)
					(if (instance? tok VToken)
						(set (as VToken tok):macro true)
					)
					(define t (if (instance? tok UnquoteToken) (h:compile fs (tok:ops:get 0) mi null Main:unknownType) null))
					(if (&& (instance? tok UnquoteToken) (|| (= t (Type:getType "Token")) (&& (instance? t ArrayType) (= (as ArrayType t):elements (Type:getType "Token"))) (Type:isSame (t:getRawType) (Type:getType "java.util.List"))))
						(h:compile fs (tok:ops:get 0) mi code Main:unknownType)
						(if (instance? tok UnquoteToken)
							(begin
								(define const (tok:ops:get 0))
								(define t (h:compile fs const mi null Main:unknownType))
								(define type ClassType
									(if (= t Type:charType)
										(Type:getType "CToken")
									(if (instance? t PrimType)
										(Type:getType "NToken")
										(Type:getType "SToken")
									)
									)
								)
								(if output (code:emitNew type))
								(if output (code:emitDup))
								(if output (code:emitInvoke (type:getDeclaredMethod "<init>" 0)))
								(if output (code:emitDup))
								(h:compile fs const mi code Type:objectType)
								(if output (code:emitPutField (type:getField "val")))
								(Type:getType "Token")
							)	
							(begin
								(define type ClassType (Type:getType ((o:getClass):getName)))
								(if output (code:emitNew type))
								(if output (code:emitDup))
								(if output (code:emitInvoke (type:getDeclaredMethod "<init>" 0)))
								(define super type)
								(while (!= super null)
									(define field (super:getFields))
									(while (!= field null)
										(if (!= (& (field:getModifiers) Access:PUBLIC) 0)
											(begin
												(if output (code:emitDup))
												(if (= (field:getType) Type:intType)
													(this:compilequasi h fs ((field:getReflectField):getInt tok) mi code (field:getType) macro)
													(this:compilequasi h fs ((field:getReflectField):get tok) mi code (field:getType) macro)
												)
												(if output (code:emitPutField field))
											)
										)
										(set field (field:getNext))
									)
									(set super (super:getSuperclass))
								)
								(Type:getType "Token")
							)
						)
					)
				)
			(if (instance? o String)
				(begin
					(if output (code:emitPushString (as String o)))
					Type:javalangStringType
				)
			(if (instance? o Integer)
				(begin
					(if output (code:emitPushInt (as Integer o)))
					Type:intType
				)
			(if (instance? o Boolean)
				(begin
					(if output (code:emitPushInt (as int (as Boolean o))))
					Type:booleanType
				)
			(if (instance? o List)
				(begin
					(define o List o)
					(define al ClassType (Type:getType "java.util.ArrayList"))
					(if output (code:emitNew al))
					(if output (code:emitDup))
					(if output (code:emitInvoke (al:getMethod "<init>" (Type[]))))
					(define i 0)
					(while (!= i (o:size))
						(define t (this:compilequasi h fs (o:get i) mi null Main:unknownType macro))
						(if (= t (Type:getType "Token"))
							(begin
								(if output (code:emitDup))
								(this:compilequasi h fs (o:get i) mi code Main:unknownType macro)
								(if output (code:emitInvoke (al:getMethod "add" (Type[] Type:objectType))))
								(if output (code:emitPop 1))
							)
						(if (instance? t ArrayType)
							(begin
								(if output (code:emitDup))
								(this:compilequasi h fs (o:get i) mi code Main:unknownType macro)
								(if output (code:emitInvoke ((as ClassType (Type:getType "java.util.Collections")):getDeclaredMethod "addAll" 2)))
								(if output (code:emitPop 1))
							)
							(begin
								(if output (code:emitDup))
								(this:compilequasi h fs (o:get i) mi code Main:unknownType macro)
								(if output (code:emitInvoke ((as ClassType (Type:getType "java.util.List")):getDeclaredMethod "addAll" 1)))
								(if output (code:emitPop 1))
							)
						)
						)
						(set i (+ i 1))
					)
					al
				)
				Main:unknownType
			)
			)
			)
			)
			)
			)
		)
		(this:castMaybe code result needed)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(this:compilequasi h fs (tok:ops:get 0) mi code (Type:getType "Token") (tok:what:equals "`"))
	)
)

(define-class ConstsHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void (set ConstsHandler:inst (ConstsHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(|| (tok:what:equals "true") (tok:what:equals "false") (tok:what:equals "null"))
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(if (tok:what:equals "true")
			(begin
				(if output (code:emitPushInt 1))
				Type:booleanType
			)
		(if (tok:what:equals "false")
			(begin
				(if output (code:emitPushInt 0))
				Type:booleanType
			)
			(begin
				(if output (code:emitPushNull))
				Type:nullType
			)
		)
		)
	)
)

(define-class VHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set VHandler:inst (VHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(instance? tok VToken)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define class ClassType (fs:get tok))
		(if (= class Main:unknownType)
			(begin
				(define tok VToken tok)
				(define found AVar (mi:getVar tok:val (if tok:macro mi:mscopes mi:scopes)))
				(found:load code)
			)
			class
		)
	)
)

(define-class BeginBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set BeginBlockHandler:inst (BeginBlockHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(if (instance? (tok:ops:get 0) VToken)
			(begin
				(define first VToken (tok:ops:get 0))
				(first:val:equals "begin")
			)
			false
		)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first VToken (tok:ops:get 0))
		(if first:macro (mi:mscopes:push (HashMap)))
		(mi:pushScope code (as BlockToken tok):labels)
		(h:compileAll fs tok:ops 1 (- (tok:ops:size) 1) mi code Type:voidType)
		(define type (h:compile fs (tok:ops:get (- (tok:ops:size) 1)) mi code needed))
		(if first:macro (mi:mscopes:pop))
		(mi:popScope code)
		type
	)
)

(define-class LabelBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set LabelBlockHandler:inst (LabelBlockHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(if (instance? (tok:ops:get 0) VToken)
			(begin
				(define first VToken (tok:ops:get 0))
				(first:val:equals "label")
			)
			false
		)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:ops:get 0))
		(define label (mi:getLabel (as VToken (tok:ops:get 1)):val))
		(if output (label:define code))
		Type:voidType
	)
)

(define-class GotoBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set GotoBlockHandler:inst (GotoBlockHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(if (instance? (tok:ops:get 0) VToken)
			(begin
				(define first VToken (tok:ops:get 0))
				(first:val:equals "goto")
			)
			false
		)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:ops:get 0))
		(define label (mi:getLabel (as VToken (tok:ops:get 1)):val))
		(if output (code:emitGoto label))
		Type:voidType
	)
)

(define-class DefineBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set DefineBlockHandler:inst (DefineBlockHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(if (instance? (tok:ops:get 0) VToken)
			(begin
				(define first VToken (tok:ops:get 0))
				(first:val:equals "define")
			)
			false
		)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:ops:get 0))
		(define type Type
			(if (= (tok:ops:size) 4)
				(begin
					(define type Type (fs:get (tok:ops:get 2)))
					(h:compile fs (tok:ops:get 3) mi code type)
					type
				)
				(h:compile fs (tok:ops:get 2) mi code Main:unknownType)
			)
		)
		(define var (mi:newVar code (as VToken (tok:ops:get 1)) type))
		(if output (code:emitStore var))
		Type:voidType
	)
)

(define-class TryBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set TryBlockHandler:inst (TryBlockHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(if (instance? (tok:ops:get 0) VToken)
			(begin
				(define first VToken (tok:ops:get 0))
				(first:val:equals "try")
			)
			false
		)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:ops:get 0))
		(if output (code:emitTryStart false null))
		(define type (h:compile fs (tok:ops:get 1) mi code needed))
		(define var (mi:newVar code (as VToken (tok:ops:get 2)) Type:javalangThrowableType))
		(if output (code:emitCatchStart var))
		(h:compile fs (tok:ops:get 3) mi code Main:unknownType)
		(if output (code:emitCatchEnd))
		(if output (code:emitTryCatchEnd))
		type
	)
)

(define-class InstanceBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set InstanceBlockHandler:inst (InstanceBlockHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(if (instance? (tok:ops:get 0) VToken)
			(begin
				(define first VToken (tok:ops:get 0))
				(first:val:equals "instance?")
			)
			false
		)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:ops:get 0))
		(h:compile fs (tok:ops:get 1) mi code Main:unknownType)
		(if output (code:emitInstanceof (fs:get (tok:ops:get 2))))
		Type:booleanType
	)
)

(define-class SetBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set SetBlockHandler:inst (SetBlockHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(if (instance? (tok:ops:get 0) VToken)
			(begin
				(define first VToken (tok:ops:get 0))
				(first:val:equals "set")
			)
			false
		)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:ops:get 0))
		(define out (tok:ops:get 1))
		(if (instance? out ColonToken)
			(begin
				(define first (out:ops:get 0))
				(define class ClassType (h:compile fs first mi code Main:unknownType))
				(define field Field (class:getField (as VToken (out:ops:get 1)):val -1))
				(h:compile fs (tok:ops:get 2) mi code (field:getType))
				(if (field:getStaticFlag)
					(if output (code:emitPutStatic field))
					(if output (code:emitPutField field))
				)
			)
			(begin
				(define tname VToken (tok:ops:get 1))
				(define name tname:val)
				(define var
					(if tname:macro
						(mi:getVar name mi:mscopes)
						(mi:getVar name mi:scopes)
					)
				)
				(h:compile fs (tok:ops:get 2) mi code var:type)
				(var:store code)
			)
		)
		Type:voidType
	)
)

(define-class ASetBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set ASetBlockHandler:inst (ASetBlockHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(if (instance? (tok:ops:get 0) VToken)
			(begin
				(define first VToken (tok:ops:get 0))
				(first:val:equals "aset")
			)
			false
		)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:ops:get 0))
		(define type ArrayType (h:compile fs (tok:ops:get 1) mi code Main:unknownType))
		(h:compile fs (tok:ops:get 2) mi code Main:unknownType)
		(h:compile fs (tok:ops:get 3) mi code type:elements)
		(if output (code:emitArrayStore))
		Type:voidType
	)
)

(define-class AGetBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set AGetBlockHandler:inst (AGetBlockHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(if (instance? (tok:ops:get 0) VToken)
			(begin
				(define first VToken (tok:ops:get 0))
				(first:val:equals "aget")
			)
			false
		)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:ops:get 0))
		(define type ArrayType (h:compile fs (tok:ops:get 1) mi code Main:unknownType))
		(h:compile fs (tok:ops:get 2) mi code Type:intType)
		(if output (code:emitArrayLoad))
		type:elements
	)
)

(define-class ALenBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set ALenBlockHandler:inst (ALenBlockHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(if (instance? (tok:ops:get 0) VToken)
			(begin
				(define first VToken (tok:ops:get 0))
				(first:val:equals "alen")
			)
			false
		)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:ops:get 0))
		(h:compile fs (tok:ops:get 1) mi code Main:unknownType)
		(if output (code:emitArrayLength))
		Type:intType
	)
)

(define-class AsBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set AsBlockHandler:inst (AsBlockHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(if (instance? (tok:ops:get 0) VToken)
			(begin
				(define first VToken (tok:ops:get 0))
				(first:val:equals "as")
			)
			false
		)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:ops:get 0))
		(define cast (fs:get (tok:ops:get 1)))
		(define out (h:compile fs (tok:ops:get 2) mi code (cast:getRawType)))
		(if (instance? cast ParameterizedType)
			cast
			out
		)
	)
)

(define-class BinOpsBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set BinOpsBlockHandler:inst (BinOpsBlockHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(if (instance? (tok:ops:get 0) VToken)
			(begin
				(define first VToken (tok:ops:get 0))
				(Main:binOps:containsKey first:val)
			)
			false
		)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first VToken (tok:ops:get 0))
		(define types (Arrays:asList (h:compileAll fs tok:ops 1 (tok:ops:size) mi null Main:unknownType)))
		(define otype Type Type:voidType)
		(if (types:contains Type:doubleType)
			(set otype Type:doubleType)
		(if (types:contains Type:longType)
			(set otype Type:longType)
			(set otype Type:intType)
		)
		)
		(h:compile fs (tok:ops:get 1) mi code otype)
		(define i 2)
		(while (!= i (tok:ops:size))
			(h:compile fs (tok:ops:get i) mi code otype)
			(if output (code:emitBinop (Main:binOps:get first:val) otype))
			(set i (+ i 1))
		)
		otype
	)
)

(define-class IfBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set IfBlockHandler:inst (IfBlockHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(if (instance? (tok:ops:get 0) VToken)
			(begin
				(define first VToken (tok:ops:get 0))
				(first:val:equals "if")
			)
			false
		)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:ops:get 0))
		(BlockHandler:emitIf h fs false tok 1 (TokenEmitter (tok:ops:get 2)) (if (= (tok:ops:size) 4) (TokenEmitter (tok:ops:get 3)) null) mi code needed)
	)
)

(define-class MacroBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set MacroBlockHandler:inst (MacroBlockHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(if (instance? (tok:ops:get 0) VToken)
			(begin
				(define first VToken (tok:ops:get 0))
				(first:val:equals "macro")
			)
			false
		)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:ops:get 0))
		(define name String (as VToken (tok:ops:get 1)):val)
		(define emitters List{Emitter} (ArrayList (Arrays:asList (Emitter[]
			(LoadAVar (Arg 0 (Type:getType "FileScope")))
			(LoadAVar (Arg 1 (Type:getType "AMethodToken")))
			(LoadAVar (Arg 2 (Type:getType "gnu.bytecode.Type")))
		))))
		(emitters:addAll (Emitters:tokenEmitters tok:ops 2 (tok:ops:size)))
		(BlockHandler:emitInvoke h name fs:macros fs (Emitters emitters) mi code Main:unknownType)
	)
)

(define-class WhileBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set WhileBlockHandler:inst (WhileBlockHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(if (instance? (tok:ops:get 0) VToken)
			(begin
				(define first VToken (tok:ops:get 0))
				(first:val:equals "while")
			)
			false
		)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:ops:get 0))
		(mi:pushScope code (as BlockToken tok):labels)
		(define start Label (Label))
		(if output (start:define code))
		(define t (BlockHandler:emitIf h fs false tok 1 (Emitters (Emitter[] (Emitters (Emitters:tokenEmitters tok:ops 2 (tok:ops:size))) (Goto start))) null mi code needed))
		(mi:popScope code)
		t
	)
)

(define-class CompareBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set CompareBlockHandler:inst (CompareBlockHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(if (instance? (tok:ops:get 0) VToken)
			(begin
				(define first VToken (tok:ops:get 0))
				(BlockHandler:isCompare first:val)
			)
			false
		)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:ops:get 0))
		(BlockHandler:emitIf_ h fs false tok 1 (as VToken first):val (TokenEmitter (Token tok:line "true")) (TokenEmitter (Token tok:line "false")) mi code Type:booleanType)
	)
)

(define-class ColonBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set ColonBlockHandler:inst (ColonBlockHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(if (instance? (tok:ops:get 0) ColonToken)
			true
			false
		)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:ops:get 0))
		(define name (as VToken (first:ops:get 1)):val)
		(BlockHandler:emitInvoke h name (h:compile fs (first:ops:get 0) mi code Main:unknownType) fs (Emitters (Emitters:tokenEmitters tok:ops 1 (tok:ops:size))) mi code Main:unknownType)
	)
)

(define-class ConsBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set ConsBlockHandler:inst (ConsBlockHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		true
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define first (tok:ops:get 0))
		(define type Type (fs:get first))
		(if (instance? type ArrayType)
			(begin
				(define array ArrayType type)
				(define len Token (if (> (tok:ops:size) 1) (tok:ops:get 1) null))
				(define i0
					(if (&& (!= len null) (instance? len ColonToken) ((as VToken (len:ops:get 0)):val:equals "len"))
						(begin (h:compile fs (len:ops:get 1) mi code Main:unknownType) 2)
						(begin (if output (code:emitPushInt (- (tok:ops:size) 1))) 1)
					)
				)
				(if output (code:emitNewArray array:elements))
				(define i i0)
				(while (!= i (tok:ops:size))
					(if output (code:emitDup))
					(if output (code:emitPushInt (- i i0)))
					(h:compile fs (tok:ops:get i) mi code array:elements)
					(if output (code:emitArrayStore))
					(set i (+ i 1))
				)
				type
			)
			(begin
				(define class ClassType (type:getRawType))
				(if output (code:emitNew class))
				(if output (code:emitDup))
				(BlockHandler:emitInvoke h "<init>" type fs (Emitters (Emitters:tokenEmitters tok:ops 1 (tok:ops:size))) mi code Main:unknownType)
				type
			)
		)
	)
)

(define-class ThrowBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set ThrowBlockHandler:inst (ThrowBlockHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(if (instance? (tok:ops:get 0) VToken)
			(begin
				(define first VToken (tok:ops:get 0))
				(first:val:equals "throw")
			)
			false
		)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(h:compile fs (tok:ops:get 1) mi code Main:unknownType)
		(if output (code:emitThrow))
		Type:voidType
	)
)

(define-class ClassBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set ClassBlockHandler:inst (ClassBlockHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(if (instance? (tok:ops:get 0) VToken)
			(begin
				(define first VToken (tok:ops:get 0))
				(first:val:equals "class")
			)
			false
		)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(if output (code:emitPushClass (as ObjectType (fs:get (tok:ops:get 1)))))
		Type:javalangClassType
	)
)

(define-class MacroCallBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set MacroCallBlockHandler:inst (MacroCallBlockHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(&& (instance? (tok:ops:get 0) VToken) (fs:macroNames:contains (as VToken (tok:ops:get 0)):val))
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(define name (as VToken (tok:ops:get 0)):val)
		(define o 3)
		(define l (- (tok:ops:size) 1))
		(define types (Type[] len:(+ o l) (Type:getType "FileScope") (Type:getType "AMethodToken") (Type:getType "gnu.bytecode.Type")))
		(define j 0)
		(while (!= j l)
			(aset types (+ o j) (Type:getType "Token"))
			(set j (+ j 1))
		)
		(define filter (MFilter name types (Type:getType "Token")))
		(fs:macros:getMethods filter 0 null)
		(define method (filter:getMethod))
		(define params (method:getParameterTypes))
		(define classes (Class[] len:(alen params)))
		(set j 0)
		(while (!= j (alen params))
			(aset classes j ((aget params j):getReflectClass))
			(set j (+ j 1))
		)
		(define args (ArrayList (Arrays:asList (Object[] fs mi needed))))
		(args:addAll
			(if (&& (> (alen params) 0) (instance? (aget params (- (alen params) 1)) ArrayType))
				(begin
					(define var (- (alen params) o))
					(define al (ArrayList (tok:ops:subList 1 var)))
					(define out (Token[] len:(- (tok:ops:size) var)))
					((tok:ops:subList var (tok:ops:size)):toArray out)
					(al:add out)
					al
				)
				(tok:ops:subList 1 (tok:ops:size))
			)
		)
		(define t (BlockToken tok:line (Arrays:asList (Token[] (VToken tok:line "begin" true) (as Token ((fs:macrosC:getMethod name classes):invoke null (args:toArray)))))))
		(Compiler:compileBlock t)
		(h:compile fs t mi code needed)
	)
)

(define-class SynchronizedBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set SynchronizedBlockHandler:inst (SynchronizedBlockHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(if (instance? (tok:ops:get 0) VToken)
			(begin
				(define first VToken (tok:ops:get 0))
				(first:val:equals "synchronized")
			)
			false
		)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(h:compile fs (tok:ops:get 1) mi code Main:unknownType)
		(mi:pushScope code (as BlockToken tok):labels)
		(if output (code:emitDup))
		(if output (code:emitMonitorEnter))
		(h:compileAll fs tok:ops 2 (- (tok:ops:size) 1) mi code Type:voidType)
		(define type (h:compile fs (tok:ops:get (- (tok:ops:size) 1)) mi code needed))
		(if output (code:emitMonitorExit))
		(mi:popScope code)
		type
	)
)

(define-class TypeBlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set TypeBlockHandler:inst (TypeBlockHandler)))
	((<init>) void (Handler:<super>))
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(if (instance? (tok:ops:get 0) VToken)
			(begin
				(define first VToken (tok:ops:get 0))
				(first:val:equals "type")
			)
			false
		)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define output (!= code null))
		(if output (code:emitGetStatic ((ClassType:make "GenHandler"):getField "inst")))
		(define emitters (Emitter[]
			(LoadAVar (Arg 0 (Type:getType "FileScope")))
			(TokenEmitter (tok:ops:get 1))
			(LoadAVar (Arg 1 (Type:getType "AMethodToken")))
			(Null)
		))
		(BlockHandler:emitInvoke h "compile" (Type:getType "Handler") fs (Emitters emitters) mi code needed)
		(Type:getType "gnu.bytecode.Type")
	)
)

(define-class BlockHandler (Handler)
	(inst Handler 'static)
	((<clinit>) void 'static (set BlockHandler:inst (BlockHandler)))
	(handlers Handler[])
	((<init> handlers Handler[]) void
		(Handler:<super>)
		(set this:handlers handlers)
	)
	((<init>) void
		(BlockHandler:<super> (Handler[]
			BeginBlockHandler:inst
			LabelBlockHandler:inst
			GotoBlockHandler:inst
			DefineBlockHandler:inst
			TryBlockHandler:inst
			InstanceBlockHandler:inst
			SetBlockHandler:inst
			ASetBlockHandler:inst
			AGetBlockHandler:inst
			ALenBlockHandler:inst
			AsBlockHandler:inst
			BinOpsBlockHandler:inst
			IfBlockHandler:inst
			MacroBlockHandler:inst
			WhileBlockHandler:inst
			CompareBlockHandler:inst
			ColonBlockHandler:inst
			ThrowBlockHandler:inst
			ClassBlockHandler:inst
			MacroCallBlockHandler:inst
			SynchronizedBlockHandler:inst
			TypeBlockHandler:inst
			ConsBlockHandler:inst
		))
	)
	((valid fs FileScope tok Token mi AMethodToken needed Type) bool 'public
		(&& (instance? tok BlockToken) (> (tok:ops:size) 0))
	)
	((isCompare s String) bool 'static
		(|| (s:equals "!") (s:equals "&&") (s:equals "||") (Main:compare1Ops:containsKey s) (Main:compare2Ops:containsKey s))
	)
	((invertComp inv bool n int) int 'static
		(if inv
			(Main:compareOpposites:get n)
			n
		)
	)
	((emitInvoke h Handler name String type Type fs FileScope emitter Emitters mi AMethodToken code CodeAttr needed Type) Type 'static
		(define output (!= code null))
		(define types (emitter:emitAll h fs mi null Main:unknownType))
		(if (name:equals "<super>") (begin (if output (code:emitPushThis)) (set name "<init>")))
		(define filter (MFilter name types type))
		((as ObjectType (type:getRawType)):getMethods filter 2 null)
		(define method (filter:getMethod))
		(define params (method:getParameterTypes))
		(define varargs (!= (& (method:getModifiers) Access:TRANSIENT) 0))
		(begin
			(define j 0)
			(define n
				(if (&&
					varargs
					(||
						(< (alen types) (alen params))
						(< ((Main:resolveParam type (aget params (- (alen params) 1))):compare (aget types (- (alen params) 1))) 0)
					)
				) 1 0)
			)
			(while (!= j (- (alen params) n))
				((emitter:emitters:get j):emit h fs mi code (Main:resolveParam type (aget params j)))
				(set j (+ j 1))
			)
			(if (= n 1)
				(begin
					(define at ArrayType (aget params (- (alen params) 1)))
					(define et (Main:resolveParam type at:elements))
					(if output (code:emitPushInt (+ 1 (- (alen types) (alen params)))))
					(if output (code:emitNewArray at:elements))
					(define oj j)
					(while (!= j (alen types))
						(if output (code:emitDup))
						(if output (code:emitPushInt (- j oj)))
						((emitter:emitters:get j):emit h fs mi code et)
						(if output (code:emitArrayStore))
						(set j (+ j 1))
					)
				)
			)
		)
		(if output (code:emitInvoke method))
		(define out (Main:resolveParam type (method:getReturnType)))
		(if (! (Type:isSame out ((method:getReturnType):getRawType)))
			(if output (code:emitCheckcast (out:getRawType)))
		)
		out
	)
	;tok = condition
	((emitIf_ h Handler fs FileScope inv bool tok Token i int compare String trueE Emitter falseE Emitter mi AMethodToken code CodeAttr needed Type) Type 'static
		(define output (!= code null))
		(if (compare:equals "!")
			(begin
				(BlockHandler:emitIf h fs (! inv) tok i trueE falseE mi code needed)
			)
		(if (|| (&& (! inv) (compare:equals "&&")) (&& inv (compare:equals "||")))
			(begin
				(define skipL (Label))
				(define falseL (Label))
				(define falseTok (Goto falseL))
				(define i 1)
				(while (!= i (- (tok:ops:size) 1))
					(BlockHandler:emitIf h fs (! inv) tok i falseTok null mi code needed)
					(set i (+ i 1))
				)
				(BlockHandler:emitIf h fs (! inv) tok (- (tok:ops:size) 1) falseTok null mi code needed)
				(define type (trueE:emit h fs mi code needed))
				(if output (code:emitGoto skipL))
				(if output (falseL:define code))
				(if (!= falseE null)
					(begin
						(falseE:emit h fs mi code needed)
					)
				)
				(if output (skipL:define code))
				type
			)
		(if (|| (&& (! inv) (compare:equals "||")) (&& inv (compare:equals "&&")))
			(begin
				(define skipL (Label))
				(define trueL (Label))
				(define trueTok (Goto trueL))
				(define i 1)
				(while (!= i (- (tok:ops:size) 1))
					(BlockHandler:emitIf h fs inv tok i trueTok null mi code needed)
					(set i (+ i 1))
				)
				(BlockHandler:emitIf h fs inv tok (- (tok:ops:size) 1) trueTok null mi code needed)
				(if (! (= falseE null))
					(begin
						(falseE:emit h fs mi code needed)
					)
				)
				(if output (code:emitGoto skipL))
				(if output (trueL:define code))
				(define type (trueE:emit h fs mi code needed))
				(if output (skipL:define code))
				type
			)
			(begin
				(define skip (Label))
				(if (Main:compare1Ops:containsKey compare)
					(begin
						(h:compile fs (tok:ops:get i) mi code Main:unknownType)
						(if output (code:emitGotoIfCompare1 skip (BlockHandler:invertComp inv (Main:compare1Ops:get compare))))
					)
					(begin
						(h:compile fs (tok:ops:get i) mi code Main:unknownType)
						(h:compile fs (tok:ops:get (+ i 1)) mi code Main:unknownType)
						(if output (code:emitGotoIfCompare2 skip (BlockHandler:invertComp inv (Main:compare2Ops:get compare))))
					)
				)
				;(code:emitIf)
				(define type (trueE:emit h fs mi code needed))
				(define end (Label))
				(if (! (= falseE null))
					(if output (code:emitGoto end))
				)
				(if output (skip:define code))
				(if (! (= falseE null))
					(begin
						;(code:emitElse)
						(falseE:emit h fs mi code needed)
						(if output (end:define code))
					)
				)
				;(code:emitFi)
				type
			)
		)
		)
		)
	)
	((emitIf h Handler fs FileScope inv bool tok Token i int trueE Emitter falseE Emitter mi AMethodToken code CodeAttr needed Type) Type 'static
		(define cond (tok:ops:get i))
		(if (&& (instance? cond BlockToken) (instance? (cond:ops:get 0) VToken) (BlockHandler:isCompare (as VToken (cond:ops:get 0)):val))
			(BlockHandler:emitIf_ h fs inv cond 1 (as VToken (cond:ops:get 0)):val trueE falseE mi code needed)
			(BlockHandler:emitIf_ h fs inv tok i "!=0" trueE falseE mi code needed)
		)
	)
	((compile h Handler fs FileScope tok Token mi AMethodToken code CodeAttr needed Type) Type 'public
		(define type (Handler:tryHandlers h null this:handlers fs tok mi code needed))
		type
	)
)
