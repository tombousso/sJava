buildDir = "bin/"

buildscript {
	repositories {
		jcenter()
	}

	dependencies {
		classpath "com.stehno.vanilla:vanilla-core:0.4.0"
	}
}

ext.JARS = fileTree(dir: "lib", include: ["*.jar"])

def same(a, b) {
	def diffs = new com.stehno.vanilla.io.DirectoryDifferenceCollector().scan(a, b)	
	return diffs.filesOnlyInA.isEmpty() && diffs.filesOnlyInB.isEmpty() && diffs.modifiedFiles.isEmpty()
}

class SJavaCompile extends AbstractCompile {
	String targetCompatibility = "1.8"
	String sourceCompatibility = "1.8"
	@InputFiles
	def compilerClasspath = project.files("bin/main")
	@InputFiles
	def compilerLibs = project.ext.JARS
	@OutputDirectory
	File destinationDir
	@InputFiles
	FileCollection classpath = project.files()
	@TaskAction
	void compile() {
		def classpath_ = classpath
		project.javaexec {
			classpath = compilerClasspath + compilerLibs + classpath_
			main = "sjava.compiler.Main"
			args = ["build"] + source + ["-d", destinationDir]
		}
	}
}

def STD_MACROS = files("std/macros.sjava").collect { it.getCanonicalPath() }
def STD_LIB = files("std/FunctionN.sjava", "std/TupleN.sjava").collect { it.getCanonicalPath() }

task compiler1_2(type: JavaExec) {
	onlyIf { !file("bin/1-2").exists() }
	doFirst { file("bin/1-2").deleteDir() }
	inputs.files("compiler1.scm", "compiler2/compiler2.sjava")
	outputs.dir("bin/1-2")
	main = "kawa.repl"
	classpath = JARS
	args = [file("compiler1.scm"), file("compiler2/compiler2.sjava")]
}

task compiler2_2(type: JavaExec, dependsOn: [compiler1_2]) {
	doFirst { file("bin/2-2").deleteDir() }
	inputs.files("compiler2/compiler2.sjava")
	outputs.dir("bin/2-2")
	main = "compiler2.Main"
	classpath = JARS + files("bin/1-2")
	args = [file("compiler2/compiler2.sjava"), "-d", "${projectDir}/bin/2-2/"]
}

task compiler2_3(type: JavaExec, dependsOn: [compiler2_2]) {
	doFirst { file("bin/2-3").deleteDir() }
	inputs.files("compiler2/macros.sjava")
	inputs.files(STD_LIB)
	inputs.dir("compiler3")
	outputs.dir("bin/2-3")
	main = "compiler2.Main"
	classpath = JARS + files("bin/2-2")
	args = ["${projectDir}/compiler2/macros.sjava"] + STD_LIB + fileTree("compiler3").files + ["-d", "${projectDir}/bin/2-3/"]
}

task compiler(type: SJavaCompile, dependsOn: [compiler2_3]) {
	doFirst { file("bin/main").deleteDir() }
	inputs.files(STD_MACROS)
	source = fileTree("compiler3") + fileTree("std")
	destinationDir = file("bin/main")
	compilerClasspath = files("bin/2-3")
}

task compiler3_3(type: SJavaCompile, dependsOn: [compiler]) {
	doFirst { file("bin/3-3").deleteDir() }
	source = fileTree("compiler3")
	destinationDir = file("bin/3-3")
}

task diff(dependsOn: [compiler2_2, compiler3_3]) {
	doLast {
		println("diff2_2: "+(same(file("bin/1-2"), file("bin/2-2")) ? "good" : "bad"))
		println("diff3_3: "+(same(file("bin/main/sjava/compiler"), file("bin/3-3/sjava/compiler")) ? "good" : "bad"))
	}
}

task jar(type: Zip, dependsOn: [compiler]) {
	archiveName = "sjava.jar"
	from(file("MANIFEST.MF"), { into("META-INF") })
	from(fileTree("bin/main/sjava/compiler"), { into("sjava/compiler") })
	from(fileTree("bin/main/sjava/std"), { into("sjava/std") })
}

task java_sources(type: JavaExec, dependsOn: [compiler]) {
	doFirst {
		file("generated-java").deleteDir()
		file("generated-java/sjava/compiler").mkdirs()
		file("generated-java/sjava/sjava").mkdirs()
	}
	main = "-jar"
	args = [
		file("fernflower.jar"),
		"-nls=1",
		"-ind=    ",
		"-dgs=1",
		file("bin/main/sjava/"),
		file("generated-java/sjava/")
	]
}

task java_compile(type: JavaCompile, dependsOn: [compiler3_3]) {
	outputs.upToDateWhen { false }
	source = fileTree(dir: "generated-java", include: "**/*.java")
	destinationDir = file("generated-java")
	classpath = JARS
	sourceCompatibility = "1.8"
	targetCompatibility = "1.8"
	dependencyCacheDir = file("${buildDir}/tmp/dependency-cache")
	doLast {
		file("bin/java-3-3").deleteDir()
		task java_compile_test(type: SJavaCompile) {
			compilerClasspath = files("generated-java")
			source = fileTree("compiler3") + STD_LIB
			destinationDir = file("bin/java-3-3")
		}
		java_compile_test.execute()
		println("java version works: "+same(file("bin/main/sjava"), file("bin/java-3-3/sjava")))
	}
}

def buildTasks = []

file("examples").listFiles().each { f ->
	if(f.name.endsWith(".sjava")) {
		def root = f.name.substring(0, f.name.indexOf("."))
		buildTasks += task "build_${root}"(type: SJavaCompile, dependsOn: [compiler]) {
			source = f
			destinationDir = file("bin")
		}
		task "run_${root}"(type: JavaExec, dependsOn: ["build_${root}"]) {
			main = "examples.${root}.Main"
			classpath = files("bin", "bin/main")
		}
	} else if (f.isDirectory()) {
		def root = f.name;
		buildTasks += task "build_${root}"(type: SJavaCompile, dependsOn: [compiler]) {
			source = fileTree(f)
			destinationDir = file("bin")
		}
		task "run_${root}"(type: JavaExec, dependsOn: ["build_${root}"]) {
			main = "examples.${root}.Main"
			classpath = files("bin", "bin/main")
		}
	}
}

task tester(type: JavaExec, dependsOn: buildTasks) {
	main = "sjava.compiler.Tester"
	classpath = JARS + files("bin/main") + files("bin")
}
